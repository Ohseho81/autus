#!/bin/bash
# ═══════════════════════════════════════════════════════════════
# AUTUS Pre-Commit Hook — Secret Detection
# ═══════════════════════════════════════════════════════════════
# Prevents accidental commit of secrets, API keys, JWT tokens.
# Install: git config core.hooksPath .githooks

RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  exit 0
fi

ISSUES=0

for FILE in $STAGED_FILES; do
  # Skip binary files and lock files
  case "$FILE" in
    *.lock|*.png|*.jpg|*.ico|*.woff*|*.ttf|*.eot) continue ;;
  esac

  # Skip if file doesn't exist (deleted)
  [ -f "$FILE" ] || continue

  CONTENT=$(git show ":$FILE" 2>/dev/null || cat "$FILE")

  # 1. JWT tokens (eyJ...)
  if echo "$CONTENT" | grep -qE 'eyJ[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}'; then
    echo -e "${RED}[SECRET DETECTED]${NC} JWT token found in: $FILE"
    ISSUES=$((ISSUES + 1))
  fi

  # 2. Supabase anon/service keys
  if echo "$CONTENT" | grep -qE '(SUPABASE_ANON_KEY|SUPABASE_SERVICE_KEY|SUPABASE_SERVICE_ROLE_KEY)\s*[=:]\s*"?eyJ'; then
    echo -e "${RED}[SECRET DETECTED]${NC} Supabase key found in: $FILE"
    ISSUES=$((ISSUES + 1))
  fi

  # 3. Generic API key patterns (sk-, pk_, api_key=xxx)
  if echo "$CONTENT" | grep -qE '(sk-[a-zA-Z0-9]{20,}|pk_[a-zA-Z0-9]{20,})'; then
    echo -e "${YELLOW}[WARNING]${NC} Possible API key in: $FILE"
    ISSUES=$((ISSUES + 1))
  fi

  # 4. Hardcoded passwords
  if echo "$CONTENT" | grep -qiE '(password|passwd|secret)\s*[=:]\s*"[^"]{8,}"'; then
    # Allow .env.example and sample files
    case "$FILE" in
      *.example|*.sample) continue ;;
    esac
    echo -e "${YELLOW}[WARNING]${NC} Possible hardcoded password in: $FILE"
    ISSUES=$((ISSUES + 1))
  fi

  # 5. PII data files that should never be committed
  case "$FILE" in
    *.csv)
      echo -e "${RED}[PII RISK]${NC} CSV file staged: $FILE — add to .gitignore"
      ISSUES=$((ISSUES + 1))
      ;;
    *.xlsx|*.docx)
      echo -e "${YELLOW}[WARNING]${NC} Binary document staged: $FILE"
      ISSUES=$((ISSUES + 1))
      ;;
  esac
done

if [ $ISSUES -gt 0 ]; then
  echo ""
  echo -e "${RED}Found $ISSUES potential secret/PII issues.${NC}"
  echo "To bypass (if intentional): git commit --no-verify"
  echo ""
  exit 1
fi

exit 0
