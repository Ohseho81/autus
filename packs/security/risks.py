

from packs.security.enforcer import Risk, RiskCategory, Severity, enforcer, ConstitutionViolationError
# í•µì‹¬ Risk í´ë˜ìŠ¤ ì§ì ‘ ì •ì˜ (ìµœì†Œ ê³¨ê²©)
class PIIStorageRisk(Risk):
    def __init__(self) -> None:
        super().__init__(
            name="PII Storage Attempt",
            category=RiskCategory.SECURITY,
            severity=Severity.CRITICAL,
            description="Constitution Article II violation: PII detected in storage",
            prevention=self.prevent,
            detection=self.detect,
            response=self.respond,
            recovery=self.recover
        )
    def prevent(self) -> None: pass
    def detect(self) -> bool: return False
    def respond(self) -> None: pass
    def recover(self) -> None: pass

class CodeInjectionRisk(Risk):
    def __init__(self) -> None:
        super().__init__(
            name="Code Injection Attack",
            category=RiskCategory.SECURITY,
            severity=Severity.CRITICAL,
            description="Constitution Article II violation: Malicious code generated by AI",
            prevention=self.prevent,
            detection=self.detect,
            response=self.respond,
            recovery=self.recover
        )
    def prevent(self) -> None: pass
    def detect(self) -> bool: return False
    def respond(self) -> None: pass
    def recover(self) -> None: pass

# --- ì¶”ê°€: RateLimitRisk, DatabaseCorruptionRisk, PerformanceBudgetRisk ---
class RateLimitRisk(Risk):
    def __init__(self) -> None:
        super().__init__(
            name="API Rate Limit",
            category=RiskCategory.API,
            severity=Severity.HIGH,
            description="Article IV violation: API rate limit exceeded or approaching",
            prevention=self.prevent,
            detection=self.detect,
            response=self.respond,
            recovery=self.recover
        )
    def prevent(self) -> None: pass
    def detect(self) -> bool: return False
    def respond(self) -> None: pass
    def recover(self) -> None: pass

class DatabaseCorruptionRisk(Risk):
    def __init__(self) -> None:
        super().__init__(
            name="Database Corruption",
            category=RiskCategory.DATA,
            severity=Severity.CRITICAL,
            description="Article IV violation: DuckDB database file corrupted",
            prevention=self.prevent,
            detection=self.detect,
            response=self.respond,
            recovery=self.recover
        )
    def prevent(self) -> None: pass
    def detect(self) -> bool: return False
    def respond(self) -> None: pass
    def recover(self) -> None: pass

class PerformanceBudgetRisk(Risk):
    def __init__(self) -> None:
        super().__init__(
            name="Performance Budget Exceeded",
            category=RiskCategory.PERFORMANCE,
            severity=Severity.HIGH,
            description="Article IV violation: Performance budget (memory/disk) exceeded",
            prevention=self.prevent,
            detection=self.detect,
            response=self.respond,
            recovery=self.recover
        )
    def prevent(self) -> None: pass
    def detect(self) -> bool: return False
    def respond(self) -> None: pass
    def recover(self) -> None: pass


from pathlib import Path
import logging

"""
from __future__ import annotations

AUTUS í•µì‹¬ ë¦¬ìŠ¤í¬ ì •ì˜

Constitutionì„ ì§€í‚¤ëŠ” 5ê°œ Critical ë¦¬ìŠ¤í¬
"""

logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Risk 1: PII ì €ì¥ ì‹œë„ (Article II ìœ„ë°˜)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def prevent_pii():
    """PII ì €ì¥ ë°©ì§€"""
    logger.debug("PII prevention active")


def detect_pii() -> bool:
    """PII ê°ì§€"""
    try:
        from protocols.memory.store import MemoryStore

        # ê°„ë‹¨í•œ ê°ì§€: ìµœê·¼ ì €ì¥ëœ ë°ì´í„° ìŠ¤ìº”
        store = MemoryStore()

        # preferences í…Œì´ë¸” ìŠ¤ìº”
        results = store.conn.execute(
            "SELECT key, value FROM preferences ORDER BY updated_at DESC LIMIT 100"
        ).fetchall()

        from protocols.memory.pii_validator import PIIValidator

        for key, value in results:
            try:
                PIIValidator.validate(key, value)
            except Exception:
                # PII ë°œê²¬
                logger.warning(f"PII detected in stored data: key={key}")
                return True

        return False
    except Exception as e:
        logger.error(f"PII detection error: {e}")
        return False


def respond_to_pii():
    """PII ëŒ€ì‘"""
    logger.critical("ğŸš¨ CONSTITUTION VIOLATION: PII detected in storage")
    raise ConstitutionViolationError(
        "Article II violated: PII storage attempted. "
        "This is a critical security violation."
    )


def recover_from_pii():
    """PII ë³µêµ¬"""
    logger.info("Recovering from PII violation...")

    try:
        from protocols.memory.recovery import RecoveryManager
        from pathlib import Path

        # ìµœì‹  ì²´í¬í¬ì¸íŠ¸ì—ì„œ ë³µêµ¬
        checkpoints = RecoveryManager.list_checkpoints()
        if checkpoints:
            RecoveryManager.restore_from_checkpoint(
                checkpoints[0],
                Path(".autus/memory/memory.db")
            )
            logger.info("Recovered from checkpoint")
        else:
            logger.warning("No checkpoint available for recovery")
    except Exception as e:
        logger.error(f"PII recovery failed: {e}")



def register_core_risks():
    """í•µì‹¬ Risk 5ì¢…ì„ ì¤‘ë³µ ì—†ì´ ë“±ë¡"""
    # ì¤‘ë³µ ë°©ì§€: ì´ë¯¸ ë“±ë¡ëœ ì´ë¦„ì€ ê±´ë„ˆëœ€
    registered = set(r.name for r in enforcer.risks)

    pii_risk = Risk(
        name="PII Storage Attempt",
        category=RiskCategory.SECURITY,
        severity=Severity.CRITICAL,
        description="Constitution Article II violation: PII detected in storage",
        prevention=PIIStorageRisk().prevent,
        detection=PIIStorageRisk().detect,
        response=PIIStorageRisk().respond,
        recovery=PIIStorageRisk().recover
    )
    if pii_risk.name not in registered:
        enforcer.register_risk(pii_risk)

    code_injection_risk = Risk(
        name="Code Injection Attack",
        category=RiskCategory.SECURITY,
        severity=Severity.CRITICAL,
        description="Constitution Article II violation: Malicious code generated by AI",
        prevention=CodeInjectionRisk().prevent,
        detection=CodeInjectionRisk().detect,
        response=CodeInjectionRisk().respond,
        recovery=CodeInjectionRisk().recover
    )
    if code_injection_risk.name not in registered:
        enforcer.register_risk(code_injection_risk)

    rate_limit_risk = Risk(
        name="API Rate Limit",
        category=RiskCategory.API,
        severity=Severity.HIGH,
        description="Article IV violation: API rate limit exceeded or approaching",
        prevention=RateLimitRisk().prevent,
        detection=RateLimitRisk().detect,
        response=RateLimitRisk().respond,
        recovery=RateLimitRisk().recover
    )
    if rate_limit_risk.name not in registered:
        enforcer.register_risk(rate_limit_risk)

    db_corruption_risk = Risk(
        name="Database Corruption",
        category=RiskCategory.DATA,
        severity=Severity.CRITICAL,
        description="Article IV violation: DuckDB database file corrupted",
        prevention=DatabaseCorruptionRisk().prevent,
        detection=DatabaseCorruptionRisk().detect,
        response=DatabaseCorruptionRisk().respond,
        recovery=DatabaseCorruptionRisk().recover
    )
    if db_corruption_risk.name not in registered:
        enforcer.register_risk(db_corruption_risk)

    performance_risk = Risk(
        name="Performance Budget Exceeded",
        category=RiskCategory.PERFORMANCE,
        severity=Severity.HIGH,
        description="Article IV violation: Performance budget (memory/disk) exceeded",
        prevention=PerformanceBudgetRisk().prevent,
        detection=PerformanceBudgetRisk().detect,
        response=PerformanceBudgetRisk().respond,
        recovery=PerformanceBudgetRisk().recover
    )
    if performance_risk.name not in registered:
        enforcer.register_risk(performance_risk)

def prevent_code_injection():
    """Code Injection ì˜ˆë°©"""
    from packs.development.code_validator import CodeValidator
    logger.debug("Code injection prevention active")


def detect_code_injection() -> bool:
    """Code Injection ê°ì§€"""
    try:
        from packs.development.code_validator import CodeValidator

        # ìµœê·¼ ìƒì„±ëœ íŒŒì¼ ìŠ¤ìº” (protocols, core)
        suspicious_files = []

        for pattern in ["protocols/**/*.py", "core/**/*.py"]:
            for py_file in Path(".").glob(pattern):
                # ìµœê·¼ 1ì‹œê°„ ë‚´ ìˆ˜ì •ëœ íŒŒì¼ë§Œ
                import time
                if (time.time() - py_file.stat().st_mtime) < 3600:
                    try:
                        is_safe, reason = CodeValidator.validate_file(py_file)
                        if not is_safe:
                            suspicious_files.append((py_file, reason))
                            logger.warning(f"Unsafe code in {py_file}: {reason}")
                    except Exception as e:
                        logger.debug(f"Could not validate {py_file}: {e}")

        return len(suspicious_files) > 0
    except Exception as e:
        logger.error(f"Code injection detection error: {e}")
        return False


def respond_to_code_injection():
    """Code Injection ëŒ€ì‘"""
    logger.critical("ğŸš¨ CODE INJECTION: Quarantining suspicious files")
    raise ConstitutionViolationError(
        "Article II violated: Malicious code detected. "
        "This is a critical security violation."
    )


def recover_from_code_injection():
    """Code Injection ë³µêµ¬"""
    logger.info("Recovering from code injection...")
    # Gitì—ì„œ ë§ˆì§€ë§‰ ì•ˆì „ ë²„ì „ìœ¼ë¡œ ë³µêµ¬
    import subprocess
    try:
        subprocess.run(
            ["git", "restore", "protocols/", "core/"],
            check=True,
            capture_output=True
        )
        logger.info("Recovered from Git")
    except Exception as e:
        logger.error(f"Code injection recovery failed: {e}")


code_injection_risk = Risk(
    name="Code Injection Attack",
    category=RiskCategory.SECURITY,
    severity=Severity.CRITICAL,
    description="Constitution Article II violation: Malicious code generated by AI",
    prevention=CodeInjectionRisk().prevent,
    detection=CodeInjectionRisk().detect,
    response=CodeInjectionRisk().respond,
    recovery=CodeInjectionRisk().recover
)



# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Risk 3: API Rate Limit (Article IV ìœ„ë°˜)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def prevent_rate_limit():
    """Rate Limit ì˜ˆë°©"""
    from packs.ai.cost_tracker import get_cost_tracker
    tracker = get_cost_tracker()
    logger.debug("Rate limit prevention active")


def detect_rate_limit() -> bool:
    """Rate Limit ê°ì§€"""
    try:
        from packs.ai.cost_tracker import get_cost_tracker, CostLimitExceeded

        tracker = get_cost_tracker()

        # ì¼ì¼ í•œë„ 80% ì´ˆê³¼ ì‹œ ê²½ê³ 
        daily_cost = tracker.get_daily_cost()
        if daily_cost > tracker.daily_limit * 0.8:
            logger.warning(f"Rate limit approaching: ${daily_cost:.2f} / ${tracker.daily_limit:.2f}")
            return True

        return False
    except CostLimitExceeded:
        return True
    except Exception as e:
        logger.error(f"Rate limit detection error: {e}")
        return False


def respond_to_rate_limit():
    """Rate Limit ëŒ€ì‘"""
    logger.warning("Rate limit approaching: Enabling backoff")
    # retry_with_backoffëŠ” ì´ë¯¸ openai_runnerì— ì ìš©ë¨
    logger.info("Exponential backoff is active")


def recover_from_rate_limit():
    """Rate Limit ë³µêµ¬"""
    import time
    logger.info("Waiting for rate limit recovery...")
    time.sleep(60)  # 1ë¶„ ëŒ€ê¸°
    logger.info("Rate limit recovered")


rate_limit_risk = Risk(
    name="API Rate Limit",
    category=RiskCategory.API,
    severity=Severity.HIGH,
    description="Article IV violation: API rate limit exceeded or approaching",
    prevention=RateLimitRisk().prevent,
    detection=RateLimitRisk().detect,
    response=RateLimitRisk().respond,
    recovery=RateLimitRisk().recover
)



# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Risk 4: Database Corruption (Article IV ìœ„ë°˜)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def prevent_db_corruption():
    """DB ì†ìƒ ì˜ˆë°©"""
    from protocols.memory.store import MemoryStore
    logger.debug("DB corruption prevention active")


def detect_db_corruption() -> bool:
    """DB ì†ìƒ ê°ì§€"""
    try:
        import duckdb
        from pathlib import Path

        db_path = Path(".autus/memory/memory.db")
        if not db_path.exists():
            return False

        try:
            conn = duckdb.connect(str(db_path))
            # ê°„ë‹¨í•œ ë¬´ê²°ì„± ì²´í¬
            conn.execute("SELECT COUNT(*) FROM preferences")
            conn.execute("SELECT COUNT(*) FROM patterns")
            conn.execute("SELECT COUNT(*) FROM context")
            conn.close()
            return False
        except Exception as e:
            logger.error(f"DB corruption detected: {e}")
            return True
    except Exception as e:
        logger.error(f"DB corruption detection error: {e}")
        return False


def respond_to_db_corruption():
    """DB ì†ìƒ ëŒ€ì‘"""
    logger.critical("ğŸš¨ DATABASE CORRUPTION: Switching to backup")
    # ì½ê¸° ì „ìš© ëª¨ë“œë¡œ ì „í™˜
    # ë°±ì—… í™œì„±í™”


def recover_from_db_corruption():
    """DB ì†ìƒ ë³µêµ¬"""
    logger.info("Recovering from database corruption...")

    try:
        from protocols.memory.recovery import RecoveryManager
        from pathlib import Path

        # ìµœì‹  ì²´í¬í¬ì¸íŠ¸ì—ì„œ ë³µêµ¬
        checkpoints = RecoveryManager.list_checkpoints()
        if checkpoints:
            RecoveryManager.restore_from_checkpoint(
                checkpoints[0],
                Path(".autus/memory/memory.db")
            )
            logger.info("Recovered from checkpoint")
        else:
            logger.warning("No checkpoint available for recovery")
    except Exception as e:
        logger.error(f"DB recovery failed: {e}")


db_corruption_risk = Risk(
    name="Database Corruption",
    category=RiskCategory.DATA,
    severity=Severity.CRITICAL,
    description="Article IV violation: DuckDB database file corrupted",
    prevention=DatabaseCorruptionRisk().prevent,
    detection=DatabaseCorruptionRisk().detect,
    response=DatabaseCorruptionRisk().respond,
    recovery=DatabaseCorruptionRisk().recover
)



# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Risk 5: Performance Budget Exceeded (Article IV ìœ„ë°˜)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def prevent_performance_violation():
    """ì„±ëŠ¥ ì˜ˆì‚° ìœ„ë°˜ ì˜ˆë°©"""
    from packs.security.performance import PerformanceBudget
    logger.debug("Performance budget monitoring active")


def detect_performance_violation() -> bool:
    """ì„±ëŠ¥ ì˜ˆì‚° ìœ„ë°˜ ê°ì§€"""
    try:
        from packs.security.performance import PerformanceBudget

        # ë©”ëª¨ë¦¬ ì²´í¬
        memory_mb = PerformanceBudget.check_memory_usage()
        if memory_mb and memory_mb > PerformanceBudget.MEMORY_MAX:
            logger.warning(f"Memory budget exceeded: {memory_mb:.1f}MB > {PerformanceBudget.MEMORY_MAX}MB")
            return True

        # ë””ìŠ¤í¬ ì²´í¬
        disk_free = PerformanceBudget.check_disk_usage()
        if disk_free and disk_free < PerformanceBudget.DISK_MAX:
            logger.warning(f"Disk space low: {disk_free:.1f}MB < {PerformanceBudget.DISK_MAX}MB")
            return True

        return False
    except Exception as e:
        logger.error(f"Performance violation detection error: {e}")
        return False


def respond_to_performance_violation():
    """ì„±ëŠ¥ ì˜ˆì‚° ìœ„ë°˜ ëŒ€ì‘"""
    logger.warning("âš ï¸ Performance budget exceeded: Enabling resource limits")
    # ë¦¬ì†ŒìŠ¤ ì œí•œ í™œì„±í™”
    # ë¶ˆí•„ìš”í•œ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ


def recover_from_performance_violation():
    """ì„±ëŠ¥ ì˜ˆì‚° ìœ„ë°˜ ë³µêµ¬"""
    logger.info("Recovering from performance violation...")
    # ìºì‹œ ì •ë¦¬
    # ë¦¬ì†ŒìŠ¤ í•´ì œ
    import gc
    gc.collect()
    logger.info("Performance recovered")


performance_risk = Risk(
    name="Performance Budget Exceeded",
    category=RiskCategory.PERFORMANCE,
    severity=Severity.HIGH,
    description="Article IV violation: Performance budget (memory/disk) exceeded",
    prevention=PerformanceBudgetRisk().prevent,
    detection=PerformanceBudgetRisk().detect,
    response=PerformanceBudgetRisk().respond,
    recovery=PerformanceBudgetRisk().recover
)

