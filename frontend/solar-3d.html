<!DOCTYPE html>
<html>
<head>
  <title>AUTUS Solar System 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      overflow: hidden;
      font-family: -apple-system, sans-serif;
    }
    #info {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      z-index: 100;
    }
    #info h1 { font-size: 18px; font-weight: 300; margin-bottom: 10px; }
    #stats {
      display: flex;
      gap: 15px;
      margin-top: 15px;
    }
    .stat {
      background: rgba(255,255,255,0.1);
      padding: 10px 15px;
      border-radius: 8px;
    }
    .stat-value { font-size: 20px; font-weight: 600; }
    .stat-label { font-size: 10px; color: #888; }
    #status {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 30px;
      border-radius: 20px;
      font-size: 14px;
    }
    .STABLE { background: rgba(0,255,136,0.2); color: #0f8; }
    .WARNING { background: rgba(255,170,0,0.2); color: #fa0; }
    .COLLAPSE { background: rgba(255,68,68,0.2); color: #f44; }
    #connection {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
    }
    .connected { background: rgba(0,255,136,0.2); color: #0f8; }
    .disconnected { background: rgba(255,68,68,0.2); color: #f44; }
    #legend {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      font-size: 11px;
      color: #aaa;
    }
    #legend div { margin: 5px 0; display: flex; align-items: center; gap: 8px; }
    #legend .dot { width: 10px; height: 10px; border-radius: 50%; }
  </style>
</head>
<body>
  <div id="info">
    <h1>AUTUS SOLAR SYSTEM</h1>
    <div id="stats">
      <div class="stat">
        <div class="stat-value" id="tick">0</div>
        <div class="stat-label">TICK</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="energy">100%</div>
        <div class="stat-label">ENERGY</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="entropy">0%</div>
        <div class="stat-label">ENTROPY</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="risk">0%</div>
        <div class="stat-label">RISK</div>
      </div>
    </div>
  </div>
  
  <div id="connection" class="disconnected">● Connecting...</div>
  <div id="status" class="STABLE">STABILITY: STABLE</div>
  
  <div id="legend">
    <div><span class="dot" style="background:#ffaa00"></span> Sun (Energy)</div>
    <div><span class="dot" style="background:#4a9eff"></span> Focus (Gravity)</div>
    <div><span class="dot" style="background:#00ff88"></span> Growth</div>
    <div><span class="dot" style="background:#ff6b6b"></span> Pressure</div>
    <div><span class="dot" style="background:#a855f7"></span> Entropy</div>
    <div><span class="dot" style="background:#fbbf24"></span> Effort</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    camera.position.set(0, 30, 50);
    camera.lookAt(0, 0, 0);
    
    // Stars background
    const starsGeometry = new THREE.BufferGeometry();
    const starPositions = [];
    for (let i = 0; i < 2000; i++) {
      starPositions.push((Math.random() - 0.5) * 500);
      starPositions.push((Math.random() - 0.5) * 500);
      starPositions.push((Math.random() - 0.5) * 500);
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    const stars = new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 }));
    scene.add(stars);
    
    // Sun
    const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);
    
    // Sun glow
    const sunGlowGeometry = new THREE.SphereGeometry(6, 32, 32);
    const sunGlowMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffaa00, 
      transparent: true, 
      opacity: 0.3 
    });
    const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
    scene.add(sunGlow);
    
    // Planets
    const planets = {};
    const planetData = [
      { name: 'focus', color: 0x4a9eff, size: 1.2, distance: 10, speed: 0.02 },
      { name: 'effort', color: 0xfbbf24, size: 1.0, distance: 14, speed: 0.015 },
      { name: 'growth', color: 0x00ff88, size: 1.5, distance: 18, speed: 0.01 },
      { name: 'pressure', color: 0xff6b6b, size: 1.3, distance: 23, speed: 0.008 },
      { name: 'entropy', color: 0xa855f7, size: 1.8, distance: 28, speed: 0.005 },
    ];
    
    planetData.forEach(p => {
      // Orbit ring
      const orbitGeometry = new THREE.RingGeometry(p.distance - 0.1, p.distance + 0.1, 64);
      const orbitMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.1,
        side: THREE.DoubleSide 
      });
      const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);
      
      // Planet
      const geometry = new THREE.SphereGeometry(p.size, 32, 32);
      const material = new THREE.MeshBasicMaterial({ color: p.color });
      const planet = new THREE.Mesh(geometry, material);
      planet.userData = { ...p, angle: Math.random() * Math.PI * 2 };
      scene.add(planet);
      planets[p.name] = planet;
    });
    
    // State
    let currentState = {
      tick: 0,
      energy: 1,
      entropy: 0,
      risk: 0,
      stability: 'STABLE',
      gravity: 0.3,
      effort: 0,
      growth: 0.5,
      pressure: 0.5
    };
    
    // Update planets based on state
    function updatePlanets() {
      // Sun size based on energy
      const sunScale = 0.7 + currentState.energy * 0.6;
      sun.scale.set(sunScale, sunScale, sunScale);
      sunGlow.scale.set(sunScale * 1.2, sunScale * 1.2, sunScale * 1.2);
      
      // Planet distances based on values
      if (planets.focus) {
        planets.focus.userData.distance = 8 + currentState.gravity * 8;
      }
      if (planets.effort) {
        planets.effort.userData.distance = 12 + currentState.effort * 6;
      }
      if (planets.entropy) {
        planets.entropy.userData.distance = 20 + currentState.entropy * 15;
        planets.entropy.userData.size = 1 + currentState.entropy * 2;
        planets.entropy.scale.set(
          planets.entropy.userData.size,
          planets.entropy.userData.size,
          planets.entropy.userData.size
        );
      }
    }
    
    // Animation
    function animate() {
      requestAnimationFrame(animate);
      
      // Rotate sun
      sun.rotation.y += 0.002;
      
      // Orbit planets
      Object.values(planets).forEach(planet => {
        planet.userData.angle += planet.userData.speed;
        const dist = planet.userData.distance;
        planet.position.x = Math.cos(planet.userData.angle) * dist;
        planet.position.z = Math.sin(planet.userData.angle) * dist;
      });
      
      // Slow camera rotation
      const time = Date.now() * 0.0001;
      camera.position.x = Math.sin(time) * 50;
      camera.position.z = Math.cos(time) * 50;
      camera.lookAt(0, 0, 0);
      
      renderer.render(scene, camera);
    }
    animate();
    
    // Fetch state
    const API = 'https://solar.autus-ai.com';
    
    async function fetchState() {
      try {
        const res = await fetch(`${API}/realtime/state`);
        const state = await res.json();
        
        currentState = {
          tick: state.tick || 0,
          energy: state.energy || (1 - (state.entropy || 0)),
          entropy: state.entropy || 0,
          risk: state.risk || 0,
          stability: state.stability || 'STABLE',
          gravity: state.gravity || 0.3,
          effort: state.effort || 0,
          growth: state.growth || 0.5,
          pressure: state.pressure || 0.5
        };
        
        updateUI();
        updatePlanets();
        
        document.getElementById('connection').className = 'connected';
        document.getElementById('connection').textContent = '● Connected';
      } catch (e) {
        document.getElementById('connection').className = 'disconnected';
        document.getElementById('connection').textContent = '● Disconnected';
      }
    }
    
    function updateUI() {
      document.getElementById('tick').textContent = currentState.tick;
      document.getElementById('energy').textContent = Math.round(currentState.energy * 100) + '%';
      document.getElementById('entropy').textContent = Math.round(currentState.entropy * 100) + '%';
      document.getElementById('risk').textContent = Math.round(currentState.risk * 100) + '%';
      
      const statusEl = document.getElementById('status');
      statusEl.className = currentState.stability;
      statusEl.textContent = `STABILITY: ${currentState.stability}`;
    }
    
    // Poll every second
    setInterval(fetchState, 1000);
    fetchState();
    
    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
