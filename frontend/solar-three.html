<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS SOLAR — Three.js Implementation</title>
  <!--
    ╔═══════════════════════════════════════════════════════════════╗
    ║  AUTUS SOLAR — THREE.JS IMPLEMENTATION (LOCK)                 ║
    ║                                                               ║
    ║  스펙:                                                        ║
    ║  - Three.js r160+                                             ║
    ║  - WebGLRenderer                                              ║
    ║  - PerspectiveCamera (FOV 45)                                 ║
    ║  - 60 FPS 목표                                                ║
    ║                                                               ║
    ║  목표: "1초 안에 지금 안전한가를 알게 한다"                   ║
    ╚═══════════════════════════════════════════════════════════════╝
  -->
  <style>
    :root {
      --bg: #050608;
      --text: #E6E6E6;
      --green: #6EDC9A;
      --yellow: #FFD166;
      --red: #EF476F;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      font-family: 'Inter', 'SF Pro Display', system-ui, sans-serif;
      color: var(--text);
      cursor: default;
      user-select: none;
    }
    
    /* Three.js 캔버스 */
    #three-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    /* UI 오버레이 */
    #ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    /* RISK % */
    #risk-display {
      position: fixed;
      bottom: 80px;
      left: 80px;
      z-index: 20;
    }
    
    #risk-label {
      font-size: 12px;
      font-weight: 300;
      letter-spacing: 0.3em;
      color: rgba(230, 230, 230, 0.5);
      margin-bottom: 4px;
    }
    
    #risk-value {
      font-size: 72px;
      font-weight: 700;
      line-height: 1;
      font-family: system-ui, 'SF Pro Display', 'Inter', sans-serif;
    }
    
    #risk-value.safe { color: var(--green); }
    #risk-value.warning { color: var(--yellow); }
    #risk-value.danger { color: var(--red); }
    
    /* STATUS DOT */
    #status-dot {
      position: fixed;
      bottom: 100px;
      right: 80px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      z-index: 20;
    }
    
    #status-dot.safe { background: var(--green); box-shadow: 0 0 8px var(--green); }
    #status-dot.warning { background: var(--yellow); box-shadow: 0 0 8px var(--yellow); }
    #status-dot.danger { background: var(--red); box-shadow: 0 0 12px var(--red); }
    
    /* ACTION 버튼 */
    #action-area {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease;
      z-index: 30;
      pointer-events: auto;
    }
    
    #action-area.visible {
      opacity: 1;
      visibility: visible;
    }
    
    .action-btn {
      padding: 16px 48px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.15em;
      border: 2px solid;
      border-radius: 8px;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .action-btn.confirm {
      color: var(--yellow);
      border-color: var(--yellow);
    }
    
    .action-btn.action {
      color: var(--red);
      border-color: var(--red);
    }
    
    /* ROLE INDICATOR */
    #role-indicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      font-weight: 300;
      letter-spacing: 0.4em;
      color: rgba(230, 230, 230, 0.3);
      z-index: 20;
    }
    
    /* AUDIT 오버레이 */
    #audit-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(5, 6, 8, 0.95);
      display: none;
      z-index: 100;
    }
    
    #audit-overlay.visible {
      display: block;
    }
    
    #audit-complete {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      letter-spacing: 0.3em;
      color: rgba(230, 230, 230, 0.4);
      opacity: 0;
      transition: opacity 0.5s ease 0.3s;
    }
    
    #audit-overlay.complete #audit-complete {
      opacity: 1;
    }
    
    /* FPS 디스플레이 (개발용) */
    #fps-display {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 10px;
      color: rgba(255,255,255,0.3);
      z-index: 50;
    }
    
    /* 모바일 */
    @media (max-width: 480px) {
      #risk-display {
        bottom: auto;
        top: 65%;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
      }
      
      #risk-value { font-size: 56px; }
      
      #status-dot {
        top: 25%;
        bottom: auto;
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 8px;
      }
      
      .action-btn {
        width: 64px;
        height: 64px;
        padding: 0;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <!-- Three.js 캔버스 -->
  <canvas id="three-canvas"></canvas>
  
  <!-- UI 오버레이 -->
  <div id="ui-overlay">
    <div id="risk-display">
      <div id="risk-label">RISK</div>
      <div id="risk-value" class="safe">0%</div>
    </div>
    
    <div id="status-dot" class="safe"></div>
    
    <div id="action-area">
      <button id="action-btn" class="action-btn confirm">확인</button>
    </div>
    
    <div id="role-indicator">STUDENT</div>
    
    <div id="fps-display">FPS: --</div>
  </div>
  
  <!-- AUDIT 오버레이 -->
  <div id="audit-overlay">
    <canvas id="audit-canvas"></canvas>
    <div id="audit-complete">SEALED</div>
  </div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
  
  <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // AUTUS SOLAR — THREE.JS IMPLEMENTATION
    // ═══════════════════════════════════════════════════════════════════════════
    
    const API_BASE = window.location.hostname === 'localhost' 
      ? 'http://localhost:8000' 
      : 'https://autus-production.up.railway.app';
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 상태
    // ═══════════════════════════════════════════════════════════════════════════
    
    const state = {
      risk: 0,
      status: 'safe',
      frozen: false,
      orbitSpeed: 0.3
    };
    
    // ═══════════════════════════════════════════════════════════════════════════
    // THREE.JS 초기화
    // ═══════════════════════════════════════════════════════════════════════════
    
    const canvas = document.getElementById('three-canvas');
    
    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050608);
    
    // Camera (FOV 45)
    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 30;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: false
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    // ═══════════════════════════════════════════════════════════════════════════
    // SUN (중앙)
    // ═══════════════════════════════════════════════════════════════════════════
    
    const sunGeometry = new THREE.SphereGeometry(1.6, 32, 32);
    const sunMaterial = new THREE.MeshStandardMaterial({
      color: 0xf5f5f5,
      roughness: 0.9,
      metalness: 0,
      emissive: 0xffffff,
      emissiveIntensity: 0.1
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);
    
    // Sun pulse 상태
    let sunPulseTime = 0;
    const sunBaseScale = 1.0;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ORBIT OBJECTS (최대 3개)
    // ═══════════════════════════════════════════════════════════════════════════
    
    const orbitObjects = [];
    const orbitData = [
      { radius: 5, speed: 0.02, angle: 0 },      // 학업
      { radius: 7.5, speed: 0.015, angle: 120 }, // 취업
      { radius: 10, speed: 0.01, angle: 240 }    // 비자
    ];
    
    // 색상
    const COLORS = {
      safe: 0x6EDC9A,
      warning: 0xFFD166,
      danger: 0xEF476F
    };
    
    orbitData.forEach((data, i) => {
      const geometry = new THREE.SphereGeometry(0.5, 16, 16);
      const material = new THREE.MeshStandardMaterial({
        color: COLORS.safe,
        roughness: 0.7,
        metalness: 0.1,
        emissive: COLORS.safe,
        emissiveIntensity: 0.3
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData = {
        ...data,
        status: 'safe',
        baseAngle: data.angle * Math.PI / 180,
        vibrationOffset: 0
      };
      
      scene.add(mesh);
      orbitObjects.push(mesh);
    });
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ORBIT TRACKS (가이드 링)
    // ═══════════════════════════════════════════════════════════════════════════
    
    orbitData.forEach((data) => {
      const trackGeometry = new THREE.RingGeometry(data.radius - 0.02, data.radius + 0.02, 64);
      const trackMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.03,
        transparent: true,
        side: THREE.DoubleSide
      });
      const track = new THREE.Mesh(trackGeometry, trackMaterial);
      track.rotation.x = Math.PI / 2;
      scene.add(track);
    });
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 애니메이션 루프
    // ═══════════════════════════════════════════════════════════════════════════
    
    let animationId;
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 60;
    
    function animate(time) {
      animationId = requestAnimationFrame(animate);
      
      // FPS 계산
      frameCount++;
      if (time - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = time;
        document.getElementById('fps-display').textContent = `FPS: ${fps}`;
      }
      
      if (state.frozen) return;
      
      const delta = time * 0.001; // 초 단위
      
      // Sun pulse (3초 주기)
      sunPulseTime += 0.02;
      const pulseScale = sunBaseScale + Math.sin(sunPulseTime) * 0.03;
      sun.scale.setScalar(pulseScale);
      
      // Sun 상태별 색상
      updateSunColor();
      
      // Orbit 회전
      orbitObjects.forEach((mesh, i) => {
        const data = mesh.userData;
        
        // 각도 업데이트
        if (data.status !== 'critical') {
          data.angle += data.speed * state.orbitSpeed;
        }
        
        // 위치 계산
        let x = Math.cos(data.baseAngle + data.angle) * data.radius;
        let z = Math.sin(data.baseAngle + data.angle) * data.radius;
        
        // 진동 (WARNING/DANGER)
        if (data.status === 'warning') {
          x += Math.sin(time * 0.01) * 0.1;
        } else if (data.status === 'danger') {
          x += Math.sin(time * 0.02) * 0.2;
          z += Math.cos(time * 0.02) * 0.2;
        }
        
        mesh.position.set(x, 0, z);
        
        // 색상 업데이트
        const color = COLORS[data.status] || COLORS.safe;
        mesh.material.color.setHex(color);
        mesh.material.emissive.setHex(color);
      });
      
      renderer.render(scene, camera);
    }
    
    // Sun 색상 업데이트
    function updateSunColor() {
      let emissiveColor = 0xffffff;
      let emissiveIntensity = 0.1;
      
      if (state.status === 'warning') {
        emissiveColor = 0xFFD166;
        emissiveIntensity = 0.15;
      } else if (state.status === 'danger') {
        emissiveColor = 0xEF476F;
        emissiveIntensity = 0.2;
      }
      
      sun.material.emissive.setHex(emissiveColor);
      sun.material.emissiveIntensity = emissiveIntensity;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // RISK 업데이트
    // ═══════════════════════════════════════════════════════════════════════════
    
    function updateRisk(risk) {
      state.risk = risk;
      
      // 상태 결정
      let status = 'safe';
      if (risk >= 80) status = 'critical';
      else if (risk >= 70) status = 'danger';
      else if (risk >= 40) status = 'warning';
      
      state.status = status;
      
      // UI 업데이트
      const riskEl = document.getElementById('risk-value');
      riskEl.textContent = `${Math.round(risk)}%`;
      riskEl.className = status === 'critical' ? 'danger' : status;
      
      const dotEl = document.getElementById('status-dot');
      dotEl.className = status === 'critical' ? 'danger' : status;
      
      // Orbit 상태 업데이트
      updateOrbitStatus(risk);
      
      // ACTION 버튼
      updateActionButton(status);
      
      // 속도 조절
      if (status === 'critical') {
        state.orbitSpeed = 0;
      } else if (status === 'danger') {
        state.orbitSpeed = 0.2;
      } else if (status === 'warning') {
        state.orbitSpeed = 0.25;
      } else {
        state.orbitSpeed = 0.3;
      }
    }
    
    function updateOrbitStatus(risk) {
      orbitObjects.forEach((mesh, i) => {
        if (risk >= 80) {
          mesh.userData.status = 'critical';
        } else if (risk >= 70) {
          mesh.userData.status = 'danger';
        } else if (risk >= 40) {
          const warningCount = Math.ceil((risk - 40) / 15);
          mesh.userData.status = i < warningCount ? 'warning' : 'safe';
        } else {
          mesh.userData.status = 'safe';
        }
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ACTION 버튼
    // ═══════════════════════════════════════════════════════════════════════════
    
    let actionTimeout = null;
    let actionClicked = false;
    
    function updateActionButton(status) {
      const area = document.getElementById('action-area');
      const btn = document.getElementById('action-btn');
      
      if (actionTimeout) {
        clearTimeout(actionTimeout);
        actionTimeout = null;
      }
      
      if (status === 'safe') {
        area.classList.remove('visible');
      } else if (status === 'warning') {
        actionTimeout = setTimeout(() => {
          btn.textContent = '확인';
          btn.className = 'action-btn confirm';
          area.classList.add('visible');
        }, 3000);
      } else {
        btn.textContent = '조치';
        btn.className = 'action-btn action';
        area.classList.add('visible');
      }
    }
    
    document.getElementById('action-btn').addEventListener('click', () => {
      if (actionClicked) return;
      actionClicked = true;
      
      // 모든 애니메이션 정지
      freezeAllAnimations();
      
      // AUDIT 전환
      setTimeout(() => showAudit(), 300);
    });
    
    function freezeAllAnimations() {
      state.frozen = true;
      document.getElementById('action-area').classList.remove('visible');
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // AUDIT — 토큰 낙하 (Three.js)
    // ═══════════════════════════════════════════════════════════════════════════
    
    let auditScene, auditCamera, auditRenderer, auditToken;
    let auditAnimationId;
    
    function initAuditScene() {
      const auditCanvas = document.getElementById('audit-canvas');
      
      auditScene = new THREE.Scene();
      auditScene.background = new THREE.Color(0x050608);
      
      auditCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      auditCamera.position.z = 20;
      
      auditRenderer = new THREE.WebGLRenderer({
        canvas: auditCanvas,
        antialias: true
      });
      auditRenderer.setSize(window.innerWidth, window.innerHeight);
      auditRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      
      // 조명
      const light = new THREE.AmbientLight(0xffffff, 0.8);
      auditScene.add(light);
      
      // 토큰 (무광 세라믹)
      const tokenGeometry = new THREE.SphereGeometry(0.8, 24, 24);
      const tokenMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.95,
        metalness: 0
      });
      auditToken = new THREE.Mesh(tokenGeometry, tokenMaterial);
      auditToken.position.y = 5; // 시작 위치
      auditScene.add(auditToken);
      
      // 기준선
      const lineGeometry = new THREE.PlaneGeometry(3, 0.05);
      const lineMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.15,
        transparent: true
      });
      const baseline = new THREE.Mesh(lineGeometry, lineMaterial);
      baseline.position.y = -5;
      auditScene.add(baseline);
    }
    
    function showAudit() {
      const overlay = document.getElementById('audit-overlay');
      overlay.classList.add('visible');
      overlay.classList.remove('complete');
      
      // 토큰 초기화
      auditToken.position.y = 5;
      
      // 낙하 애니메이션 시작
      const startY = 5;
      const endY = -5;
      const duration = 900; // 0.9초
      const startTime = performance.now();
      
      function animateToken(time) {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease-in (가속만)
        const easedProgress = progress * progress;
        
        auditToken.position.y = startY + (endY - startY) * easedProgress;
        
        auditRenderer.render(auditScene, auditCamera);
        
        if (progress < 1) {
          auditAnimationId = requestAnimationFrame(animateToken);
        } else {
          // 충돌!
          triggerImpact();
        }
      }
      
      auditAnimationId = requestAnimationFrame(animateToken);
    }
    
    function triggerImpact() {
      const overlay = document.getElementById('audit-overlay');
      
      // 화면 진동
      document.body.style.animation = 'none';
      document.body.offsetHeight; // reflow
      document.body.style.animation = 'shake 60ms ease-out';
      
      // 저주파 사운드
      if (window.innerWidth > 480) {
        playImpactSound();
      } else {
        navigator.vibrate?.(80);
      }
      
      // 완료
      overlay.classList.add('complete');
      
      // API 호출
      sealDecision();
    }
    
    function playImpactSound() {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        osc.frequency.value = 30;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
        
        osc.start();
        osc.stop(ctx.currentTime + 0.08);
      } catch (e) {}
    }
    
    async function sealDecision() {
      try {
        await fetch(`${API_BASE}/execute`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'recover', risk: state.risk })
        });
      } catch (e) {}
    }
    
    // AUDIT 닫기
    document.getElementById('audit-overlay').addEventListener('click', () => {
      const overlay = document.getElementById('audit-overlay');
      if (!overlay.classList.contains('complete')) return;
      
      overlay.classList.remove('visible', 'complete');
      
      // 상태 초기화
      state.frozen = false;
      actionClicked = false;
      updateRisk(0);
    });
    
    // ═══════════════════════════════════════════════════════════════════════════
    // API 연동
    // ═══════════════════════════════════════════════════════════════════════════
    
    async function fetchState() {
      try {
        const res = await fetch(`${API_BASE}/state`);
        if (!res.ok) return;
        
        const data = await res.json();
        const { entropy = 0, pressure = 0 } = data.engine || {};
        const risk = Math.min(100, Math.max(0, (entropy * 50) + (pressure * 30)));
        
        updateRisk(risk);
      } catch (e) {
        console.warn('[SOLAR] API fetch failed');
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 키보드 데모
    // ═══════════════════════════════════════════════════════════════

    document.addEventListener('keydown', (e) => {
      const scenarios = {
        '1': 15,  // safe
        '2': 52,  // warning
        '3': 78,  // danger
        '4': 92,  // critical
        'a': 'audit'
      };
      
      if (scenarios[e.key] === 'audit') {
        actionClicked = false;
        state.frozen = false;
        freezeAllAnimations();
        setTimeout(() => showAudit(), 300);
      } else if (scenarios[e.key]) {
        updateRisk(scenarios[e.key]);
      }
    });
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 리사이즈 핸들러
    // ═══════════════════════════════════════════════════════════════════════════
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      if (auditCamera) {
        auditCamera.aspect = window.innerWidth / window.innerHeight;
        auditCamera.updateProjectionMatrix();
        auditRenderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
    
    // WebGL Context Loss 대비
    canvas.addEventListener('webglcontextlost', (e) => {
      e.preventDefault();
      cancelAnimationFrame(animationId);
      document.getElementById('action-area').classList.remove('visible');
    });
    
    canvas.addEventListener('webglcontextrestored', () => {
      animate(performance.now());
    });
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 초기화
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Shake 애니메이션 추가
    const style = document.createElement('style');
    style.textContent = `
      @keyframes shake {
        0%, 100% { transform: translate(0, 0); }
        10% { transform: translate(-2px, 0); }
        30% { transform: translate(2px, 0); }
        50% { transform: translate(-1px, 0); }
        70% { transform: translate(1px, 0); }
      }
    `;
    document.head.appendChild(style);
    
    // AUDIT Scene 초기화
    initAuditScene();
    
    // 애니메이션 시작
    animate(performance.now());
    
    // API 폴링
    fetchState();
    setInterval(fetchState, 10000);
    
    console.log('[SOLAR] Three.js initialized');
  </script>
</body>
</html>
