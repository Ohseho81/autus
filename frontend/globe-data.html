<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Globe + Data Binding</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#020408;overflow:hidden;font-family:system-ui,sans-serif}
    #info{position:fixed;top:20px;left:20px;color:#fff;font-size:10px;z-index:100}
    #info h1{font-size:12px;color:#00d4ff;letter-spacing:.2em;margin-bottom:8px}
    .stat{margin:4px 0;opacity:.6}
    .stat span{color:#00d4ff}
    #panels{position:fixed;top:20px;right:20px;width:220px;z-index:100}
    .panel{background:rgba(0,20,40,.8);border:1px solid rgba(0,212,255,.2);border-radius:6px;padding:12px;margin-bottom:8px}
    .panel-title{font-size:9px;color:rgba(0,212,255,.6);letter-spacing:.1em;margin-bottom:8px}
    .metric{display:flex;justify-content:space-between;font-size:10px;padding:4px 0;border-bottom:1px solid rgba(255,255,255,.05)}
    .metric-value{color:#00d4ff}
    .metric-value.warning{color:#ffaa00}
    .metric-value.danger{color:#ff4444}
    #labels{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50}
    .label{position:absolute;color:#fff;text-shadow:0 0 4px rgba(0,0,0,.8);white-space:nowrap}
    .label.L1{font-size:14px;font-weight:600}
    .label.L2{font-size:10px;font-weight:500;opacity:.8}
    .label.L3{font-size:8px;font-weight:400;opacity:.6}
  </style>
</head>
<body>
  <div id="info">
    <h1>GLOBE + DATA</h1>
    <div class="stat">Nodes: <span id="s-nodes">0</span></div>
    <div class="stat">Links: <span id="s-links">0</span></div>
    <div class="stat">FPS: <span id="s-fps">0</span></div>
    <div class="stat">LOD: <span id="s-lod">near</span></div>
  </div>
  <div id="panels"></div>
  <div id="labels"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
// LOD Caps
const CAPS = {
  "1080p": { maxNodes: 2000, maxLinks: 3000, maxLabels: 250 },
  "4K": { maxNodes: 1200, maxLinks: 1800, maxLabels: 180 }
};

function detectResolution() {
  return window.innerWidth * devicePixelRatio > 2560 ? "4K" : "1080p";
}

function getLODLevel(dist) {
  if (dist < 3) return "near";
  if (dist < 8) return "mid";
  return "far";
}

// Data
let globeData = { nodes: [], links: [], panels: [] };

async function loadData() {
  const r = await fetch('/frontend/data/sample-globe-data.json');
  globeData = await r.json();
  renderPanels();
  updateStats();
}

function renderPanels() {
  const container = document.getElementById('panels');
  container.innerHTML = globeData.panels.slice(0, 4).map(p => `
    <div class="panel">
      <div class="panel-title">${p.title}</div>
      ${p.metrics.map(m => `
        <div class="metric">
          <span>${m.key}</span>
          <span class="metric-value ${m.risk > 0.3 ? 'danger' : m.risk > 0.15 ? 'warning' : ''}">${m.value}${m.unit || ''}</span>
        </div>
      `).join('')}
    </div>
  `).join('');
}

function updateStats() {
  document.getElementById('s-nodes').textContent = globeData.nodes.length;
  document.getElementById('s-links').textContent = globeData.links.length;
}

// Three.js
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(1.5, devicePixelRatio));
renderer.setClearColor(0x020408);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
camera.position.z = 5;

// Globe
const globeGeo = new THREE.SphereGeometry(1.5, 64, 64);
const globeMat = new THREE.MeshPhongMaterial({
  color: 0x0a2540,
  emissive: 0x051525,
  shininess: 10
});
const globe = new THREE.Mesh(globeGeo, globeMat);
scene.add(globe);

// Grid
const gridGeo = new THREE.SphereGeometry(1.52, 32, 32);
const gridMat = new THREE.MeshBasicMaterial({ color: 0x00d4ff, wireframe: true, transparent: true, opacity: 0.08 });
scene.add(new THREE.Mesh(gridGeo, gridMat));

// Lights
scene.add(new THREE.AmbientLight(0x404040, 0.5));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 3, 5);
scene.add(light);

// Nodes (Instanced)
const nodeGeo = new THREE.SphereGeometry(0.03, 8, 8);
const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
let nodeMesh = null;
const nodePositions = [];

function latLonToXYZ(lat, lon, r) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lon + 180) * Math.PI / 180;
  return new THREE.Vector3(
    -r * Math.sin(phi) * Math.cos(theta),
    r * Math.cos(phi),
    r * Math.sin(phi) * Math.sin(theta)
  );
}

function createNodes() {
  if (nodeMesh) scene.remove(nodeMesh);
  
  const caps = CAPS[detectResolution()];
  const nodes = globeData.nodes.slice(0, caps.maxNodes);
  
  nodeMesh = new THREE.InstancedMesh(nodeGeo, nodeMat, nodes.length);
  const dummy = new THREE.Object3D();
  const color = new THREE.Color();
  
  nodePositions.length = 0;
  
  nodes.forEach((node, i) => {
    const pos = latLonToXYZ(node.lat, node.lon, 1.55);
    nodePositions.push({ node, pos });
    
    dummy.position.copy(pos);
    dummy.scale.setScalar(0.5 + node.weight);
    dummy.updateMatrix();
    nodeMesh.setMatrixAt(i, dummy.matrix);
    
    // Color by kind
    const colors = { city: 0x00d4ff, org: 0x00ff88, system: 0xaa88ff, asset: 0xffaa00, person: 0xff6644 };
    color.setHex(colors[node.kind] || 0xffffff);
    nodeMesh.setColorAt(i, color);
  });
  
  nodeMesh.instanceMatrix.needsUpdate = true;
  if (nodeMesh.instanceColor) nodeMesh.instanceColor.needsUpdate = true;
  scene.add(nodeMesh);
}

// Links
const linkGroup = new THREE.Group();
scene.add(linkGroup);

function createLinks() {
  while (linkGroup.children.length) linkGroup.remove(linkGroup.children[0]);
  
  const caps = CAPS[detectResolution()];
  const links = globeData.links.slice(0, caps.maxLinks);
  
  const nodeMap = new Map(globeData.nodes.map(n => [n.id, n]));
  
  links.forEach(link => {
    const nodeA = nodeMap.get(link.a);
    const nodeB = nodeMap.get(link.b);
    if (!nodeA || !nodeB) return;
    
    const posA = latLonToXYZ(nodeA.lat, nodeA.lon, 1.55);
    const posB = latLonToXYZ(nodeB.lat, nodeB.lon, 1.55);
    
    // Arc
    const mid = posA.clone().add(posB).multiplyScalar(0.5);
    mid.normalize().multiplyScalar(1.55 + link.strength * 0.3);
    
    const curve = new THREE.QuadraticBezierCurve3(posA, mid, posB);
    const points = curve.getPoints(20);
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    
    const colors = { data: 0x00d4ff, money: 0x00ff88, work: 0xffaa00, policy: 0xaa88ff };
    const mat = new THREE.LineBasicMaterial({
      color: colors[link.kind] || 0xffffff,
      transparent: true,
      opacity: 0.3 + link.strength * 0.4
    });
    
    linkGroup.add(new THREE.Line(geo, mat));
  });
}

// Labels (DOM overlay)
function updateLabels() {
  const labelsDiv = document.getElementById('labels');
  labelsDiv.innerHTML = '';
  
  const caps = CAPS[detectResolution()];
  const lod = getLODLevel(camera.position.length());
  document.getElementById('s-lod').textContent = lod;
  
  let maxLabels = caps.maxLabels;
  if (lod === 'mid') maxLabels = Math.floor(maxLabels * 0.5);
  if (lod === 'far') maxLabels = Math.floor(maxLabels * 0.2);
  
  const visibleNodes = nodePositions
    .filter(np => np.node.label)
    .slice(0, maxLabels);
  
  visibleNodes.forEach(({ node, pos }) => {
    const screenPos = pos.clone().project(camera);
    const x = (screenPos.x * 0.5 + 0.5) * innerWidth;
    const y = (-screenPos.y * 0.5 + 0.5) * innerHeight;
    
    if (screenPos.z > 1 || x < 0 || x > innerWidth || y < 0 || y > innerHeight) return;
    
    const label = document.createElement('div');
    label.className = `label ${node.label.level}`;
    label.textContent = node.label.text;
    label.style.left = x + 'px';
    label.style.top = y + 'px';
    labelsDiv.appendChild(label);
  });
}

// FPS
let frames = 0, lastTime = performance.now(), fps = 60;
function updateFPS() {
  frames++;
  const now = performance.now();
  if (now - lastTime >= 1000) {
    fps = Math.round(frames * 1000 / (now - lastTime));
    frames = 0;
    lastTime = now;
    document.getElementById('s-fps').textContent = fps;
  }
}

// Animation
function animate() {
  requestAnimationFrame(animate);
  
  globe.rotation.y += 0.002;
  if (nodeMesh) nodeMesh.rotation.y = globe.rotation.y;
  linkGroup.rotation.y = globe.rotation.y;
  
  updateLabels();
  updateFPS();
  
  renderer.render(scene, camera);
}

// Init
loadData().then(() => {
  createNodes();
  createLinks();
  animate();
});

window.onresize = () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
  </script>
</body>
</html>
