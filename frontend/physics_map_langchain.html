<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>











<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§  AUTUS Physics Map - LangChain AI í†µí•©</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    
    /* í—¤ë” */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .ai { color: #9966ff; }
    
    /* LangChain AI íŒ¨ë„ */
    .langchain-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      width: 380px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.5);
      border-radius: 16px;
      padding: 20px;
      z-index: 100;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-models {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .model-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .model-badge.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .ai-response {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      min-height: 150px;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-response .highlight {
      color: #00ff88;
      font-weight: bold;
    }
    
    .ai-response .warning {
      color: #ff4466;
    }
    
    .ai-response .prediction {
      color: #ffcc00;
    }
    
    .ai-btn {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      background: rgba(153, 102, 255, 0.2);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .ai-btn:hover {
      background: rgba(153, 102, 255, 0.3);
      border-color: #9966ff;
    }
    
    .ai-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.4);
    }
    
    .ai-btn.primary:hover {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    
    .ai-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* ë…¸ë“œ í´ë¦­ íŒ¨ë„ */
    .node-analysis {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 320px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 16px;
      padding: 16px;
      z-index: 100;
      display: none;
    }
    
    .node-analysis.visible { display: block; }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .node-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .node-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .node-value {
      font-size: 12px;
      color: #00ff88;
    }
    
    .ai-suggestion {
      background: rgba(153, 102, 255, 0.1);
      border: 1px solid rgba(153, 102, 255, 0.3);
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .ai-suggestion-title {
      color: #9966ff;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    .status-dot.ai-ready {
      background: #9966ff;
      box-shadow: 0 0 6px #9966ff;
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* ë³„ë˜¥ë³„ ê°•ì¡° */
    @keyframes shooting-star {
      0% { opacity: 0; transform: translateX(-20px); }
      50% { opacity: 1; }
      100% { opacity: 0; transform: translateX(20px); }
    }
    
    .shooting-star-badge {
      background: linear-gradient(90deg, transparent, #ffcc00, transparent);
      animation: shooting-star 2s infinite;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>ğŸ§  AUTUS Physics Map + LangChain AI</h1>
      <div class="philosophy">Grok + Claude + GPT í†µí•© ë¶„ì„ â€¢ ì‹¤ì‹œê°„ AI ì œì•ˆ â€¢ ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">í˜„ì¬ ê°€ì¹˜</div>
        <div class="kpi-value positive" id="kpi-current">â‚©6,000ë§Œ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">12ê°œì›” ì˜ˆì¸¡</div>
        <div class="kpi-value neutral" id="kpi-predict">â‚©5.58ì–µ</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">ì„±ì¥ë¥ </div>
        <div class="kpi-value ai" id="kpi-growth">9.3x</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">AI ìƒíƒœ</div>
        <div class="kpi-value" style="color: #9966ff;" id="kpi-ai">Ready</div>
      </div>
    </div>
  </div>
  
  <!-- LangChain AI íŒ¨ë„ -->
  <div class="langchain-panel">
    <div class="panel-title">ğŸ§  LangChain AI ë¶„ì„</div>
    
    <div class="ai-models">
      <span class="model-badge active">Grok 3</span>
      <span class="model-badge active">Claude 4</span>
      <span class="model-badge active">GPT-4o</span>
    </div>
    
    <div class="ai-response" id="ai-response">
      <p style="color: #666;">ë…¸ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ AI ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
      <p style="color: #888; margin-top: 12px; font-size: 11px;">
        â€¢ ë…¸ë“œ í´ë¦­ â†’ ê°œì¸ë³„ ìµœì í™” ì œì•ˆ<br>
        â€¢ ì „ì²´ ë¶„ì„ â†’ íŒ€ ì‹œë„ˆì§€ ìµœì í™”<br>
        â€¢ 12ê°œì›” ì˜ˆì¸¡ â†’ ë³µë¦¬ ê°€ì† ì‹œë®¬ë ˆì´ì…˜
      </p>
    </div>
    
    <button class="ai-btn primary" onclick="analyzeAll()">
      ğŸ”® ì „ì²´ ìµœì í™” ë¶„ì„
    </button>
    
    <button class="ai-btn" onclick="predictFuture()">
      ğŸ“ˆ 12ê°œì›” ëˆ ì˜ˆì¸¡
    </button>
    
    <button class="ai-btn" onclick="suggestAutomation()">
      âš¡ ìë™í™” ì œì•ˆ
    </button>
    
    <button class="ai-btn" onclick="findBottleneck()">
      ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€
    </button>
    
    <button class="ai-btn" onclick="optimizeSynergy()">
      ğŸ”— ì‹œë„ˆì§€ ìµœì í™”
    </button>
  </div>
  
  <!-- ë…¸ë“œ ë¶„ì„ íŒ¨ë„ -->
  <div class="node-analysis" id="node-analysis">
    <div class="node-header">
      <div class="node-avatar" id="node-avatar">ğŸ‘¤</div>
      <div>
        <div class="node-name" id="node-name">ì´ë¦„</div>
        <div class="node-value" id="node-value">â‚©0</div>
      </div>
    </div>
    <div class="ai-suggestion">
      <div class="ai-suggestion-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</div>
      <div id="node-suggestion">ë¶„ì„ ì¤‘...</div>
    </div>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot ai-ready" id="ai-dot"></div>
      <span id="ai-status">LangChain AI Ready</span>
    </div>
    <div class="status-item">
      <span>Models: Grok 3 + Claude 4 + GPT-4o</span>
    </div>
    <div class="status-item">
      <span>Nodes: <span id="node-count">5</span> / Links: <span id="link-count">5</span></span>
    </div>
    <div class="status-item">
      <span>AUTUS Physics Map + LangChain v1.0</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      nodes: [],
      links: [],
      particles: [],
      selectedNode: null,
      isDragging: false,
      dragNode: null,
      pan: { x: 0, y: 0 },
      scale: 1
    };
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadData();
      initParticles();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadData() {
      // ì‹¤ì œ í•™ì› ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', role: 'ëŒ€í‘œ', value: 56000000, x: 0, y: 0, icon: 'ğŸ‘‘', type: 'core' },
        { id: 'P02', name: 'ê¹€ê²½í¬', role: 'ë§¤ë‹ˆì €', value: 25000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', role: 'í—¤ë“œ ê°•ì‚¬', value: 23000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', role: 'ê°•ì‚¬', value: 11000000, x: 0, y: 0, icon: 'ğŸ‘¤', type: 'team' },
        { id: 'P05', name: 'ì˜¤ì€ìš°', role: 'ê°•ì‚¬', value: 7000000, x: 0, y: 0, icon: 'âš ï¸', type: 'bottleneck' }
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 15000000, type: 'synergy', synergy: 0.25 },
        { source: 'P02', target: 'P03', value: 12000000, type: 'synergy', synergy: 0.20 },
        { source: 'P03', target: 'P04', value: 8000000, type: 'flow', synergy: 0.15 },
        { source: 'P03', target: 'P05', value: 6000000, type: 'flow', synergy: 0.10 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', synergy: 0.30 }
      ];
      
      positionNodes();
      document.getElementById('node-count').textContent = state.nodes.length;
      document.getElementById('link-count').textContent = state.links.length;
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 3000000), 15);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.004,
            trail: [],
            glow: link.type === 'prediction',
            size: link.type === 'prediction' ? 5 : 3
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      drawGrid();
      drawLinks();
      updateParticles();
      renderParticles();
      drawNodes();
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50 * state.scale;
      
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function drawLinks() {
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(midX, midY, target.x, target.y);
        
        if (link.type === 'prediction') {
          ctx.setLineDash([15, 10]);
          ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
          ctx.lineWidth = 3;
        } else if (link.type === 'synergy') {
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.synergy})`;
          ctx.lineWidth = 2 + link.synergy * 4;
        } else {
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
          ctx.lineWidth = 2;
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // ì‹œë„ˆì§€ìœ¨ í‘œì‹œ
        if (link.synergy > 0) {
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#888';
          ctx.textAlign = 'center';
          ctx.fillText(`${(link.synergy * 100).toFixed(0)}%`, midX, midY - 10);
        }
      });
    }
    
    function drawNodes() {
      state.nodes.forEach(node => {
        const size = 30 + Math.sqrt(node.value) / 500;
        const isSelected = state.selectedNode === node;
        
        // ê¸€ë¡œìš°
        if (isSelected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, size * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(153, 102, 255, 0.2)';
          ctx.fill();
        }
        
        // íƒ€ì…ë³„ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 1.8, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = 'rgba(0, 255, 136, 0.15)';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = 'rgba(255, 68, 102, 0.15)';
        } else {
          ctx.fillStyle = 'rgba(0, 204, 255, 0.1)';
        }
        ctx.fill();
        
        // ë©”ì¸ ì›
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        if (node.type === 'core') {
          ctx.fillStyle = '#00ff88';
        } else if (node.type === 'bottleneck') {
          ctx.fillStyle = '#ff4466';
        } else {
          ctx.fillStyle = '#00ccff';
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // í…Œë‘ë¦¬
        ctx.strokeStyle = isSelected ? '#9966ff' : '#fff';
        ctx.lineWidth = isSelected ? 4 : 2;
        ctx.stroke();
        
        // ì•„ì´ì½˜
        ctx.font = `${size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        ctx.fillText(node.icon, node.x, node.y);
        
        // ì´ë¦„
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(node.name, node.x, node.y + size + 16);
        
        // ì—­í• 
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(node.role, node.x, node.y + size + 30);
        
        // ê°€ì¹˜
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#00ff88';
        ctx.fillText(formatMoney(node.value), node.x, node.y - size - 10);
      });
    }
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 40;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 20) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 4 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = p.glow ? 20 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LangChain AI ë¶„ì„ (ì‹¤ì œ API ì—°ë™)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const API_BASE = 'http://localhost:3001';
    
    async function callLangChainAPI(endpoint, data) {
      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return await res.json();
      } catch (e) {
        console.log('API í˜¸ì¶œ ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ:', e);
        return null;
      }
    }
    
    function formatAIResponse(content, model) {
      // Markdownì„ HTMLë¡œ ê°„ë‹¨ ë³€í™˜
      let html = content
        .replace(/## (.*)/g, '<p><strong>$1</strong></p><br>')
        .replace(/### (.*)/g, '<p style="color: #9966ff;"><strong>$1</strong></p>')
        .replace(/\*\*(.*?)\*\*/g, '<span class="highlight">$1</span>')
        .replace(/â€¢ (.*)/g, '<p>â€¢ $1</p>')
        .replace(/\n\n/g, '<br>')
        .replace(/\n/g, '<br>');
      
      html += `<br><p style="font-size: 10px; color: #666;">Model: ${model}</p>`;
      return html;
    }
    
    async function analyzeAll() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ§  LangChain AI ë¶„ì„ ì¤‘...</p>';
      document.getElementById('ai-status').textContent = 'Analyzing...';
      
      const result = await callLangChainAPI('/api/analyze', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        // ì‹œë®¬ë ˆì´ì…˜ í´ë°±
        await simulateDelay(1500);
        response.innerHTML = `
          <p><strong>ğŸ§  LangChain ì•„ìš°íˆ¬ìŠ¤ ë¶„ì„ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ê°€ì¹˜ 700ë§Œ (ë‚®ìŒ) â†’ <strong>ìë™í™” ë˜ëŠ” ì¬ë°°ì¹˜</strong> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œê°„ ë¹„ìš© ì ˆê° ì˜ˆìƒ: +500ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš°</span> ì˜ˆì¸¡ ì—°ê²° ì‹œë„ˆì§€ ê°•í™”</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 0.30 ì ìš© ì‹œ ì›” +1,000ë§Œ ì¶”ê°€</p>
          <br>
          <p>â€¢ <span class="prediction">ì™¸ë¶€ ìŠ¤í°ì„œ ë„ì…</span> ê¶Œì¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ê°€ì†: +3,000ë§Œ/ì›”</p>
          <br>
          <p>â€¢ <strong>12ê°œì›” ì˜ˆì¸¡</strong>: í˜„ì¬ 6,000ë§Œ â†’ <span class="highlight">5ì–µ 5,800ë§Œ</span> (9.3ë°°)</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation (ì„œë²„ ë¯¸ì—°ê²°)</p>
        `;
      }
      
      document.getElementById('ai-status').textContent = 'LangChain AI Ready';
    }
    
    async function predictFuture() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ“ˆ 12ê°œì›” ë³µë¦¬ ì˜ˆì¸¡ ê³„ì‚° ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/predict', {
        nodes: state.nodes,
        links: state.links,
        months: 12,
        synergyRate: 0.3
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        const current = 60000000;
        const synergy = 0.30;
        response.innerHTML = `
          <p><strong>ğŸ“ˆ 12ê°œì›” ëˆ ìµœê³ ì¹˜ ì˜ˆì¸¡</strong></p>
          <br>
          <p>â€¢ í˜„ì¬ ì›” ê°€ì¹˜: <span class="highlight">${formatMoney(current)}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ ${(synergy * 100).toFixed(0)}% ë³µë¦¬ ì ìš©:</p>
          <p style="margin-left: 16px;">- 6ê°œì›” í›„: <span class="prediction">${formatMoney(current * Math.pow(1 + synergy, 6))}</span></p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1 + synergy, 12))}</span></p>
          <br>
          <p>â€¢ ì‹œë„ˆì§€ìœ¨ 40% ê°•í™” ì‹œ:</p>
          <p style="margin-left: 16px;">- 12ê°œì›” í›„: <span class="highlight">${formatMoney(current * Math.pow(1.4, 12))}</span> (21.7ë°°)</p>
          <br>
          <p style="color: #ffcc00;">â­ ë³„ë˜¥ë³„ ê²½ë¡œ(ì˜ˆì¸¡ ì—°ê²°) ê°•í™” ì¶”ì²œ</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function suggestAutomation() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">âš¡ ìë™í™” ê°€ëŠ¥ ì˜ì—­ ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/automate', {
        nodes: state.nodes
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>âš¡ ìë™í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> ì—…ë¬´ ìë™í™” ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ë°˜ë³µ ì—…ë¬´ 70% AI ëŒ€ì²´ ê°€ëŠ¥</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì ˆê°: ì›” 500ë§Œì›</p>
          <br>
          <p>â€¢ <span class="prediction">ê³ ê° ì‘ëŒ€ ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ì±—ë´‡ ë„ì…ìœ¼ë¡œ 30% íš¨ìœ¨í™”</p>
          <br>
          <p>â€¢ <span class="highlight">ì •ì‚° ìë™í™”</span></p>
          <p style="margin-left: 16px; color: #888;">- ìˆ˜ì‘ì—… ì‹œê°„ 80% ì ˆê°</p>
          <br>
          <p style="color: #00ff88;">ì´ ì˜ˆìƒ ì ˆê°: ì›” 1,200ë§Œì›</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function findBottleneck() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/bottleneck', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸš¨ ë³‘ëª© ì§€ì  íƒì§€ ê²°ê³¼</strong></p>
          <br>
          <p>â€¢ <span class="warning">ì˜¤ì€ìš°</span> - ì‹¬ê°ë„: ë†’ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- íˆ¬ì… ì‹œê°„ ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ ì—°ê²° ë¶€ì¡±</p>
          <br>
          <p>â€¢ <span class="prediction">ì˜¤ì—°ìš° â†’ ì˜¤ì€ìš°</span> ì—°ê²° ì•½í•¨</p>
          <p style="margin-left: 16px; color: #888;">- ì‹œë„ˆì§€ìœ¨ 10%ë¡œ ì„±ì¥ ì œí•œ</p>
          <br>
          <p><strong>ê¶Œì¥ ì¡°ì¹˜:</strong></p>
          <p style="margin-left: 16px;">1. ì˜¤ì„¸í˜¸ â†’ ì˜¤ì€ìš° ì§ì ‘ ì—°ê²° í™œì„±í™”</p>
          <p style="margin-left: 16px;">2. ì˜¤ì€ìš° ì—­í•  ì¬ì •ì˜ ë˜ëŠ” ìë™í™”</p>
          <p style="margin-left: 16px;">3. ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ ë¶„ì‚°</p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    async function optimizeSynergy() {
      const response = document.getElementById('ai-response');
      response.innerHTML = '<p class="loading" style="color: #9966ff;">ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ë¶„ì„ ì¤‘...</p>';
      
      const result = await callLangChainAPI('/api/synergy', {
        nodes: state.nodes,
        links: state.links
      });
      
      if (result && result.content) {
        response.innerHTML = formatAIResponse(result.content, result.model);
      } else {
        await simulateDelay(1000);
        response.innerHTML = `
          <p><strong>ğŸ”— ì‹œë„ˆì§€ ìµœì í™” ì œì•ˆ</strong></p>
          <br>
          <p>â€¢ <span class="highlight">ì˜¤ì„¸í˜¸ â†” ê¹€ê²½í¬</span> ì‹œë„ˆì§€ìœ¨: 25%</p>
          <p style="margin-left: 16px; color: #888;">- í˜‘ì—… ì‹œê°„ ì¦ê°€ ì‹œ 35%ê¹Œì§€ í–¥ìƒ ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="highlight">ê¹€ê²½í¬ â†” ì˜¤ì„ ìš°</span> ì‹œë„ˆì§€ìœ¨: 20%</p>
          <p style="margin-left: 16px; color: #888;">- ê³µë™ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ 30% ë‹¬ì„± ê°€ëŠ¥</p>
          <br>
          <p>â€¢ <span class="prediction">ì‹ ê·œ ì—°ê²° ì œì•ˆ:</span></p>
          <p style="margin-left: 16px;">- ì˜¤ì„¸í˜¸ â†’ ì˜¤ì—°ìš° ì§ì ‘ ì—°ê²° (í˜„ì¬ ì—†ìŒ)</p>
          <p style="margin-left: 16px; color: #888;">- ì˜ˆìƒ ì‹œë„ˆì§€: 20%, ì›” +800ë§Œ</p>
          <br>
          <p style="color: #00ff88;"><strong>ìµœì í™” í›„ ì˜ˆìƒ ì´ ê°€ì¹˜: 8,500ë§Œ/ì›”</strong></p>
          <br>
          <p style="font-size: 10px; color: #666;">Model: simulation</p>
        `;
      }
    }
    
    function analyzeNode(node) {
      const panel = document.getElementById('node-analysis');
      const suggestion = document.getElementById('node-suggestion');
      
      document.getElementById('node-avatar').textContent = node.icon;
      document.getElementById('node-name').textContent = `${node.name} (${node.role})`;
      document.getElementById('node-value').textContent = formatMoney(node.value) + '/ì›”';
      
      panel.classList.add('visible');
      suggestion.innerHTML = '<span class="loading" style="color: #9966ff;">AI ë¶„ì„ ì¤‘...</span>';
      
      setTimeout(() => {
        if (node.type === 'core') {
          suggestion.innerHTML = `
            <span style="color: #00ff88;">âœ“ í•µì‹¬ ê°€ì¹˜ ìƒì‚°ì</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ìµœìƒìœ„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: 3ê°œ (ì–‘í˜¸)<br>
            â€¢ ì œì•ˆ: ì™¸ë¶€ íŒŒíŠ¸ë„ˆ ì—°ê²°ë¡œ ê°€ì¹˜ í™•ì¥<br>
            â€¢ ì˜ˆì¸¡: ì—°ê²° 1ê°œ ì¶”ê°€ ì‹œ +1,500ë§Œ/ì›”
          `;
        } else if (node.type === 'bottleneck') {
          suggestion.innerHTML = `
            <span style="color: #ff4466;">âš ï¸ ë³‘ëª© ì§€ì  ê°ì§€</span><br><br>
            â€¢ íˆ¬ì… ëŒ€ë¹„ ê°€ì¹˜ ìƒì‚° ë‚®ìŒ<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ì•½í•¨<br>
            â€¢ ì œì•ˆ: ìë™í™” ë˜ëŠ” ì—­í•  ì¬ì •ì˜<br>
            â€¢ ëŒ€ì•ˆ: ì§ì ‘ ì—°ê²° ê°•í™”ë¡œ +500ë§Œ/ì›” ê°€ëŠ¥
          `;
        } else {
          suggestion.innerHTML = `
            <span style="color: #00ccff;">â†’ ì„±ì¥ ê°€ëŠ¥ì„± ìˆìŒ</span><br><br>
            â€¢ í˜„ì¬ ê¸°ì—¬ë„: ì¤‘ê°„<br>
            â€¢ ì‹œë„ˆì§€ ì—°ê²°: ê°œì„  ì—¬ì§€ ìˆìŒ<br>
            â€¢ ì œì•ˆ: í•µì‹¬ ë…¸ë“œì™€ ì§ì ‘ ì—°ê²° ê°•í™”<br>
            â€¢ ì˜ˆì¸¡: ì‹œë„ˆì§€ 5% í–¥ìƒ ì‹œ +300ë§Œ/ì›”
          `;
        }
      }, 1000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 30 + Math.sqrt(node.value) / 500;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.selectedNode = node;
        analyzeNode(node);
      } else {
        state.selectedNode = null;
        document.getElementById('node-analysis').classList.remove('visible');
      }
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      if (node) {
        state.isDragging = true;
        state.dragNode = node;
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      }
    }
    
    function onMouseUp() {
      state.isDragging = false;
      state.dragNode = null;
      canvas.classList.remove('dragging');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (value >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (value >= 10000000) return 'â‚©' + (value / 10000000).toFixed(0) + ',000ë§Œ';
      if (value >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function simulateDelay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    console.log('ğŸ§  AUTUS Physics Map + LangChain AI initialized');
  </script>
</body>
</html>

















