<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Globe HQ</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#000;overflow:hidden;font-family:system-ui,sans-serif}
    #info{position:fixed;top:20px;left:20px;color:#fff;z-index:100;font-size:10px;opacity:.7}
    #info h1{font-size:11px;font-weight:700;letter-spacing:.2em;margin-bottom:8px;color:#00d4ff}
    #info .row{margin:3px 0;display:flex;justify-content:space-between;width:140px}
    #info .val{color:#00d4ff}
    #controls{position:fixed;bottom:20px;left:20px;z-index:100}
    #controls button{padding:6px 12px;margin-right:6px;background:rgba(0,212,255,.1);border:1px solid rgba(0,212,255,.3);color:#00d4ff;border-radius:4px;font-size:10px;cursor:pointer}
    #controls button:hover{background:rgba(0,212,255,.2)}
    #back{position:fixed;top:20px;right:20px;padding:8px 16px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);color:#fff;text-decoration:none;border-radius:6px;font-size:11px;z-index:100}
  </style>
</head>
<body>
  <div id="info">
    <h1>GLOBE HQ · HYBRID</h1>
    <div class="row"><span>Entropy</span><span class="val" id="v-ent">0.000</span></div>
    <div class="row"><span>Pressure</span><span class="val" id="v-prs">0.00</span></div>
    <div class="row"><span>Energy</span><span class="val" id="v-eng">0.50</span></div>
    <div class="row"><span>Flow</span><span class="val" id="v-flow">0.00</span></div>
    <div class="row"><span>Risk</span><span class="val" id="v-risk">0.00</span></div>
    <div class="row"><span>Nodes</span><span class="val" id="v-nodes">100</span></div>
  </div>
  <div id="controls">
    <button onclick="addPressure()">+Pressure</button>
    <button onclick="addEntropy()">+Entropy</button>
    <button onclick="resetState()">Reset</button>
  </div>
  <a id="back" href="/frontend/hud-system.html">← HUD</a>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
// === TwinState ===
let state = { entropy: 0.1, pressure: 0.0, energy: 0.5, flow: 0.3, risk: 0.1 };

function addPressure() { state.pressure = Math.min(1, state.pressure + 0.1); state.risk = Math.min(1, state.risk + 0.05); }
function addEntropy() { state.entropy = Math.min(1, state.entropy + 0.1); state.risk = Math.min(1, state.risk + 0.08); }
function resetState() { state = { entropy: 0.1, pressure: 0.0, energy: 0.5, flow: 0.3, risk: 0.1 }; }

// === Three.js Setup ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

camera.position.set(0, 0.5, 3.5);
camera.lookAt(0, 0, 0);

// === Lighting ===
const ambient = new THREE.AmbientLight(0x404060, 0.4);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(5, 2, 3);
scene.add(sun);

// === Earth Sphere (Hybrid) ===
const earthGeo = new THREE.SphereGeometry(1, 128, 128);

// Custom Shader Material
const earthMat = new THREE.ShaderMaterial({
  uniforms: {
    u_time: { value: 0 },
    u_terminator: { value: 0 },
    u_dayColor: { value: new THREE.Color(0x1a4a7a) },
    u_nightColor: { value: new THREE.Color(0x0a1525) },
    u_rimColor: { value: new THREE.Color(0x00d4ff) },
    u_rimPower: { value: 3.0 },
    u_energy: { value: 0.5 },
    u_entropy: { value: 0.1 }
  },
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float u_time;
    uniform float u_terminator;
    uniform vec3 u_dayColor;
    uniform vec3 u_nightColor;
    uniform vec3 u_rimColor;
    uniform float u_rimPower;
    uniform float u_energy;
    uniform float u_entropy;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;
    
    void main() {
      // Terminator (day/night)
      float terminator = sin(vUv.x * 6.28318 + u_terminator);
      float dayMask = smoothstep(-0.1, 0.1, terminator);
      
      vec3 baseColor = mix(u_nightColor, u_dayColor, dayMask);
      baseColor *= (0.7 + 0.3 * u_energy);
      
      // Rim glow (Fresnel)
      vec3 viewDir = normalize(-vPosition);
      float rim = 1.0 - max(dot(viewDir, vNormal), 0.0);
      rim = pow(rim, u_rimPower);
      
      vec3 rimGlow = u_rimColor * rim * (0.5 + 0.5 * u_energy);
      
      // Noise/entropy effect
      float noise = fract(sin(dot(vUv, vec2(12.9898, 78.233)) + u_time) * 43758.5453);
      baseColor += vec3(noise * u_entropy * 0.1);
      
      gl_FragColor = vec4(baseColor + rimGlow, 1.0);
    }
  `
});

const earth = new THREE.Mesh(earthGeo, earthMat);
scene.add(earth);

// === Atmosphere Glow ===
const atmoGeo = new THREE.SphereGeometry(1.08, 64, 64);
const atmoMat = new THREE.ShaderMaterial({
  uniforms: {
    u_glowColor: { value: new THREE.Color(0x00d4ff) },
    u_intensity: { value: 0.6 }
  },
  vertexShader: `
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 u_glowColor;
    uniform float u_intensity;
    varying vec3 vNormal;
    void main() {
      float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
      gl_FragColor = vec4(u_glowColor, intensity * u_intensity);
    }
  `,
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
scene.add(atmosphere);

// === Digital Grid Overlay ===
const gridGeo = new THREE.SphereGeometry(1.02, 36, 36);
const gridMat = new THREE.MeshBasicMaterial({
  color: 0x00d4ff,
  wireframe: true,
  transparent: true,
  opacity: 0.12
});
const grid = new THREE.Mesh(gridGeo, gridMat);
scene.add(grid);

// === Orbit Rings ===
function createOrbitRing(radius, color, opacity) {
  const geo = new THREE.RingGeometry(radius, radius + 0.015, 128);
  const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = Math.PI / 2;
  return ring;
}
const ring1 = createOrbitRing(1.4, 0x00d4ff, 0.25);
const ring2 = createOrbitRing(1.7, 0x00ff88, 0.15);
const ring3 = createOrbitRing(2.0, 0x8855ff, 0.1);
ring2.rotation.x = Math.PI / 2.3;
ring3.rotation.x = Math.PI / 1.8;
ring3.rotation.z = 0.3;
scene.add(ring1, ring2, ring3);

// === Node Cloud (Instanced) ===
const nodeCount = 200;
const nodeGeo = new THREE.BufferGeometry();
const nodePositions = new Float32Array(nodeCount * 3);
const nodeColors = new Float32Array(nodeCount * 3);

for (let i = 0; i < nodeCount; i++) {
  const phi = Math.acos(2 * Math.random() - 1);
  const theta = Math.random() * Math.PI * 2;
  const r = 1.03 + Math.random() * 0.02;
  
  nodePositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
  nodePositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
  nodePositions[i*3+2] = r * Math.cos(phi);
  
  const isActive = Math.random() > 0.7;
  nodeColors[i*3] = isActive ? 0 : 0;
  nodeColors[i*3+1] = isActive ? 1 : 0.8;
  nodeColors[i*3+2] = isActive ? 0.5 : 1;
}

nodeGeo.setAttribute('position', new THREE.BufferAttribute(nodePositions, 3));
nodeGeo.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));

const nodeMat = new THREE.PointsMaterial({
  size: 0.025,
  vertexColors: true,
  transparent: true,
  opacity: 0.9,
  sizeAttenuation: true
});
const nodes = new THREE.Points(nodeGeo, nodeMat);
scene.add(nodes);

// === Radar Sweep ===
const sweepGeo = new THREE.RingGeometry(0, 1.5, 64, 1, 0, 0.15);
const sweepMat = new THREE.MeshBasicMaterial({
  color: 0x00ff88,
  transparent: true,
  opacity: 0.2,
  side: THREE.DoubleSide
});
const sweep = new THREE.Mesh(sweepGeo, sweepMat);
sweep.rotation.x = Math.PI / 2;
scene.add(sweep);

// === Stars ===
const starGeo = new THREE.BufferGeometry();
const starPos = [];
for (let i = 0; i < 2000; i++) {
  starPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15 }));
scene.add(stars);

// === Animation ===
let startTime = Date.now();
let mouseX = 0, mouseY = 0;

document.addEventListener('mousemove', e => {
  mouseX = (e.clientX / innerWidth - 0.5) * 0.3;
  mouseY = (e.clientY / innerHeight - 0.5) * 0.3;
});

function lerp(a, b, t) { return a + (b - a) * t; }

function animate() {
  requestAnimationFrame(animate);
  
  const t = (Date.now() - startTime) / 1000;
  
  // Update uniforms from state
  earthMat.uniforms.u_time.value = t;
  earthMat.uniforms.u_terminator.value = t * 0.3;
  earthMat.uniforms.u_energy.value = state.energy;
  earthMat.uniforms.u_entropy.value = state.entropy;
  earthMat.uniforms.u_rimPower.value = lerp(2.5, 5.0, state.pressure);
  
  atmoMat.uniforms.u_intensity.value = lerp(0.4, 1.0, state.energy);
  
  gridMat.opacity = lerp(0.08, 0.25, state.flow);
  
  // Rotation
  const spinRate = lerp(0.05, 0.2, state.flow);
  earth.rotation.y += spinRate * 0.016;
  grid.rotation.y = earth.rotation.y;
  nodes.rotation.y = earth.rotation.y;
  
  // Rings wobble
  ring1.rotation.z = Math.sin(t * 0.5) * 0.1;
  ring2.rotation.z = Math.sin(t * 0.7) * 0.15 + 0.2;
  ring3.rotation.y += 0.002;
  
  // Sweep
  const sweepRate = lerp(0.5, 2.5, state.risk);
  sweep.rotation.z = t * sweepRate;
  sweepMat.opacity = lerp(0.15, 0.4, state.risk);
  
  // Camera parallax
  camera.position.x = mouseX;
  camera.position.y = 0.5 + mouseY;
  camera.lookAt(0, 0, 0);
  
  // Node visibility based on flow
  const visibleNodes = Math.round(lerp(50, nodeCount, state.flow));
  document.getElementById('v-nodes').textContent = visibleNodes;
  
  // Update UI
  document.getElementById('v-ent').textContent = state.entropy.toFixed(3);
  document.getElementById('v-prs').textContent = state.pressure.toFixed(2);
  document.getElementById('v-eng').textContent = state.energy.toFixed(2);
  document.getElementById('v-flow').textContent = state.flow.toFixed(2);
  document.getElementById('v-risk').textContent = state.risk.toFixed(2);
  
  // Stars
  stars.rotation.y += 0.0001;
  
  renderer.render(scene, camera);
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Fetch real state
async function fetchState() {
  try {
    const r = await fetch('/status');
    const s = await r.json();
    state.entropy = s.signals.entropy;
    state.pressure = s.signals.pressure;
    state.energy = s.signals.gravity;
    state.flow = s.signals.release;
    state.risk = s.signals.entropy + s.signals.pressure * 0.5;
  } catch(e) {}
}

fetchState();
setInterval(fetchState, 3000);
animate();
  </script>
</body>
</html>
