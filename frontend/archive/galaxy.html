<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Galaxy</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#000;overflow:hidden;font-family:system-ui,-apple-system,sans-serif}
    #info{position:fixed;top:20px;left:20px;color:#fff;z-index:100;font-size:12px}
    #info h1{font-size:14px;font-weight:900;letter-spacing:.2em;margin-bottom:12px;opacity:.6}
    #info .stat{margin:6px 0;opacity:.7}
    #info .stat span{color:#00d4ff}
    #back{position:fixed;top:20px;right:20px;padding:10px 20px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);color:#fff;text-decoration:none;border-radius:8px;font-size:12px;z-index:100}
    #back:hover{background:rgba(255,255,255,.2)}
    #tooltip{position:fixed;padding:12px 16px;background:rgba(0,0,0,.9);border:1px solid rgba(255,255,255,.2);border-radius:8px;color:#fff;font-size:11px;pointer-events:none;display:none;z-index:200}
    #tooltip .name{font-weight:700;margin-bottom:8px;color:#00d4ff}
    #tooltip .row{display:flex;justify-content:space-between;gap:20px;margin:4px 0}
    #tooltip .label{opacity:.5}
    #tooltip .value{font-weight:600}
    #tooltip .status-GREEN{color:#00ff88}
    #tooltip .status-YELLOW{color:#ffaa00}
    #tooltip .status-RED{color:#ff4444}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="info">
    <h1>AUTUS GALAXY</h1>
    <div class="stat">Systems: <span id="solarCount">0</span></div>
    <div class="stat">Total Pressure: <span id="totalPressure">0</span></div>
    <div class="stat">Avg Entropy: <span id="avgEntropy">0</span></div>
  </div>
  <a id="back" href="/frontend/index.html">BACK TO SOLAR</a>
  <div id="tooltip"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 30, 50);
    camera.lookAt(0, 0, 0);

    const ambient = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambient);
    const point = new THREE.PointLight(0xffffff, 1, 100);
    point.position.set(0, 20, 0);
    scene.add(point);

    const starsGeo = new THREE.BufferGeometry();
    const starPos = [];
    for(let i=0;i<2000;i++){
      starPos.push((Math.random()-0.5)*500,(Math.random()-0.5)*500,(Math.random()-0.5)*500);
    }
    starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xffffff,size:0.5,transparent:true,opacity:0.8}));
    scene.add(stars);

    const center = new THREE.Mesh(new THREE.SphereGeometry(2,32,32), new THREE.MeshBasicMaterial({color:0x000000}));
    scene.add(center);

    const ring = new THREE.Mesh(new THREE.RingGeometry(2.5,4,64), new THREE.MeshBasicMaterial({color:0x00d4ff,side:THREE.DoubleSide,transparent:true,opacity:0.3}));
    ring.rotation.x = Math.PI/2;
    scene.add(ring);

    let solarData = [];
    let meshes = [];

    function getColor(s){return s==='GREEN'?0x00ff88:s==='YELLOW'?0xffaa00:0xff4444;}

    function createSolar(d, i){
      const angle = (i/12)*Math.PI*2;
      const radius = 15 + (i%3)*8;
      const size = 1 + d.signals.pressure*0.5;
      const geo = new THREE.SphereGeometry(size, 16, 16);
      const mat = new THREE.MeshPhongMaterial({color:getColor(d.output.status),emissive:getColor(d.output.status),emissiveIntensity:0.3,transparent:true,opacity:0.9});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(Math.cos(angle)*radius, (Math.random()-0.5)*5, Math.sin(angle)*radius);
      mesh.userData = {...d, baseY:mesh.position.y, angle, radius};
      scene.add(mesh);
      const orbit = new THREE.Mesh(new THREE.RingGeometry(radius-0.1,radius+0.1,64), new THREE.MeshBasicMaterial({color:0xffffff,side:THREE.DoubleSide,transparent:true,opacity:0.05}));
      orbit.rotation.x = Math.PI/2;
      scene.add(orbit);
      return mesh;
    }

    async function fetchData(){
      try{
        const res = await fetch('/status');
        const d = await res.json();
        solarData = [
          {...d, id:'SUN_001', name:'AUTUS Primary'},
          {...d, id:'SUN_002', name:'Philippines Export', output:{...d.output,status:Math.random()>0.7?'YELLOW':'GREEN'}},
          {...d, id:'SUN_003', name:'Education', signals:{...d.signals,pressure:d.signals.pressure*0.5}, output:{...d.output,status:'GREEN'}},
          {...d, id:'SUN_004', name:'Facility', signals:{...d.signals,entropy:d.signals.entropy*1.2}, output:{...d.output,status:d.signals.entropy>0.3?'YELLOW':'GREEN'}}
        ];
        document.getElementById('solarCount').textContent = solarData.length;
        document.getElementById('totalPressure').textContent = solarData.reduce((a,s)=>a+s.signals.pressure,0).toFixed(2);
        document.getElementById('avgEntropy').textContent = (solarData.reduce((a,s)=>a+s.signals.entropy,0)/solarData.length).toFixed(3);
        if(meshes.length===0){
          solarData.forEach((s,i)=>meshes.push(createSolar(s,i)));
        }else{
          meshes.forEach((m,i)=>{if(solarData[i]){m.material.color.setHex(getColor(solarData[i].output.status));m.material.emissive.setHex(getColor(solarData[i].output.status));m.userData={...solarData[i],baseY:m.userData.baseY,angle:m.userData.angle,radius:m.userData.radius};}});
        }
      }catch(e){console.error(e);}
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const tooltip = document.getElementById('tooltip');

    window.addEventListener('mousemove', e=>{
      mouse.x = (e.clientX/window.innerWidth)*2-1;
      mouse.y = -(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(meshes);
      if(hit.length>0){
        const d = hit[0].object.userData;
        tooltip.style.display='block';
        tooltip.style.left=e.clientX+15+'px';
        tooltip.style.top=e.clientY+15+'px';
        tooltip.innerHTML=`<div class="name">${d.name||d.id}</div><div class="row"><span class="label">Status</span><span class="value status-${d.output.status}">${d.output.status}</span></div><div class="row"><span class="label">Pressure</span><span class="value">${d.signals.pressure.toFixed(2)}</span></div><div class="row"><span class="label">Entropy</span><span class="value">${d.signals.entropy.toFixed(3)}</span></div>`;
        document.body.style.cursor='pointer';
      }else{
        tooltip.style.display='none';
        document.body.style.cursor='default';
      }
    });

    let camAngle=0, camRadius=50, dragging=false, lastX=0;
    renderer.domElement.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX;});
    renderer.domElement.addEventListener('mouseup',()=>{dragging=false;});
    renderer.domElement.addEventListener('mousemove',e=>{if(dragging){camAngle+=(e.clientX-lastX)*0.005;lastX=e.clientX;}});
    renderer.domElement.addEventListener('wheel',e=>{camRadius+=e.deltaY*0.05;camRadius=Math.max(20,Math.min(100,camRadius));});

    let t=0;
    function animate(){
      requestAnimationFrame(animate);
      t+=0.01;
      camera.position.x=Math.cos(camAngle)*camRadius;
      camera.position.z=Math.sin(camAngle)*camRadius;
      camera.position.y=30;
      camera.lookAt(0,0,0);
      ring.rotation.z+=0.002;
      meshes.forEach((m,i)=>{
        m.userData.angle+=0.001*(1+i*0.1);
        m.position.x=Math.cos(m.userData.angle)*m.userData.radius;
        m.position.z=Math.sin(m.userData.angle)*m.userData.radius;
        m.position.y=m.userData.baseY+Math.sin(t+i)*0.5;
        if(m.userData.output&&m.userData.output.status!=='GREEN'){m.material.emissiveIntensity=0.3+Math.sin(t*3)*0.2;}
      });
      stars.rotation.y+=0.0001;
      renderer.render(scene,camera);
    }

    window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});

    fetchData();
    setInterval(fetchData,3000);
    animate();
  </script>
</body>
</html>
