<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Radar HQ</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#030508;overflow:hidden;font-family:system-ui,sans-serif}
    #info{position:fixed;top:20px;left:20px;color:#fff;z-index:100;font-size:10px;opacity:.8}
    #info h1{font-size:11px;font-weight:700;letter-spacing:.2em;color:#00ff88;margin-bottom:10px}
    #info .row{margin:3px 0;display:flex;justify-content:space-between;width:120px}
    #info .val{color:#00ff88}
    #controls{position:fixed;bottom:20px;left:20px;z-index:100}
    #controls button{padding:6px 12px;margin-right:6px;background:rgba(0,255,136,.1);border:1px solid rgba(0,255,136,.3);color:#00ff88;border-radius:4px;font-size:10px;cursor:pointer}
    #controls button:hover{background:rgba(0,255,136,.2)}
    #back{position:fixed;top:20px;right:20px;padding:8px 16px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);color:#fff;text-decoration:none;border-radius:6px;font-size:11px;z-index:100}
    .alert-active{animation:alert-flash 0.5s infinite}
    @keyframes alert-flash{50%{background:rgba(255,68,68,.1)}}
  </style>
</head>
<body>
  <div id="info">
    <h1>RADAR HQ · SCAN</h1>
    <div class="row"><span>Risk</span><span class="val" id="v-risk">0.00</span></div>
    <div class="row"><span>Entropy</span><span class="val" id="v-ent">0.00</span></div>
    <div class="row"><span>Pressure</span><span class="val" id="v-prs">0.00</span></div>
    <div class="row"><span>Targets</span><span class="val" id="v-targets">0</span></div>
    <div class="row"><span>Sweep</span><span class="val" id="v-sweep">0°</span></div>
  </div>
  <div id="controls">
    <button onclick="addRisk()">+Risk</button>
    <button onclick="addPressure()">+Pressure</button>
    <button onclick="spawnTargets()">+Targets</button>
    <button onclick="resetState()">Reset</button>
  </div>
  <a id="back" href="/frontend/hud-system.html">← HUD</a>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
// === State ===
let state = { risk: 0.2, entropy: 0.1, pressure: 0.1, flow: 0.3, energy: 0.5 };
let targets = [];
const MAX_TARGETS = 100;

function addRisk() { state.risk = Math.min(1, state.risk + 0.15); state.entropy = Math.min(1, state.entropy + 0.05); }
function addPressure() { state.pressure = Math.min(1, state.pressure + 0.1); }
function spawnTargets() { for(let i=0; i<5; i++) spawnTarget(); }
function resetState() { state = { risk: 0.2, entropy: 0.1, pressure: 0.1, flow: 0.3, energy: 0.5 }; targets = []; }

function spawnTarget() {
  if (targets.length >= MAX_TARGETS) targets.shift();
  const angle = Math.random() * Math.PI * 2;
  const dist = 0.2 + Math.random() * 0.7;
  targets.push({
    x: Math.cos(angle) * dist,
    y: Math.sin(angle) * dist,
    life: 1.0,
    decay: 0.005 + Math.random() * 0.01,
    blink: Math.random() * Math.PI * 2
  });
}

function lerp(a, b, t) { return a + (b - a) * Math.max(0, Math.min(1, t)); }

// === Three.js ===
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1.2, 1.2, 1.2, -1.2, 0.1, 10);
camera.position.z = 1;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setClearColor(0x030508);
document.body.appendChild(renderer.domElement);

// === Radar Grid (SDF-style with lines) ===
const gridGroup = new THREE.Group();

// Concentric rings
for (let i = 1; i <= 8; i++) {
  const r = i * 0.12;
  const geo = new THREE.RingGeometry(r - 0.003, r + 0.003, 128);
  const mat = new THREE.MeshBasicMaterial({ 
    color: 0x00ff88, 
    transparent: true, 
    opacity: 0.2 
  });
  gridGroup.add(new THREE.Mesh(geo, mat));
}

// Radial spokes
for (let i = 0; i < 24; i++) {
  const angle = (i / 24) * Math.PI * 2;
  const geo = new THREE.BufferGeometry();
  const verts = new Float32Array([0, 0, 0, Math.cos(angle), Math.sin(angle), 0]);
  geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  const mat = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15 });
  gridGroup.add(new THREE.Line(geo, mat));
}
scene.add(gridGroup);

// === Sweep Arc ===
const sweepGeo = new THREE.CircleGeometry(1, 64, 0, 0.15);
const sweepMat = new THREE.ShaderMaterial({
  uniforms: {
    u_color: { value: new THREE.Color(0x00ff88) },
    u_opacity: { value: 0.6 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 u_color;
    uniform float u_opacity;
    varying vec2 vUv;
    void main() {
      float fade = 1.0 - vUv.x;
      gl_FragColor = vec4(u_color, u_opacity * fade * fade);
    }
  `,
  transparent: true,
  side: THREE.DoubleSide
});
const sweep = new THREE.Mesh(sweepGeo, sweepMat);
scene.add(sweep);

// === Threshold Bands ===
const thresholds = [];
const thresholdColors = [0x00ff88, 0xffaa00, 0xff4444];
for (let i = 0; i < 3; i++) {
  const r = 0.5 + i * 0.2;
  const geo = new THREE.RingGeometry(r - 0.008, r + 0.008, 128);
  const mat = new THREE.MeshBasicMaterial({
    color: thresholdColors[i],
    transparent: true,
    opacity: 0.4
  });
  const mesh = new THREE.Mesh(geo, mat);
  thresholds.push({ mesh, baseRadius: r, mat });
  scene.add(mesh);
}

// === Target Blips ===
const targetGeo = new THREE.CircleGeometry(0.015, 16);
const targetMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
const targetMeshes = [];

function updateTargets() {
  // Remove old meshes
  targetMeshes.forEach(m => scene.remove(m));
  targetMeshes.length = 0;
  
  // Create new
  targets.forEach(t => {
    if (t.life <= 0) return;
    const mesh = new THREE.Mesh(targetGeo, targetMat.clone());
    mesh.position.set(t.x, t.y, 0.01);
    mesh.material.opacity = t.life * (0.5 + 0.5 * Math.sin(t.blink));
    mesh.material.transparent = true;
    mesh.scale.setScalar(0.5 + t.life * 0.5);
    scene.add(mesh);
    targetMeshes.push(mesh);
  });
}

// === Animation ===
let startTime = Date.now();

function animate() {
  requestAnimationFrame(animate);
  
  const t = (Date.now() - startTime) / 1000;
  const dt = 0.016;
  
  // Sweep rotation (risk-based speed)
  const sweepRate = lerp(0.3, 2.0, state.risk);
  sweep.rotation.z = -t * sweepRate;
  
  // Sweep width (pressure-based)
  const sweepWidth = lerp(0.1, 0.3, state.pressure);
  sweep.geometry.dispose();
  sweep.geometry = new THREE.CircleGeometry(1, 64, 0, sweepWidth);
  
  // Grid opacity (energy-based)
  gridGroup.children.forEach(c => {
    if (c.material) c.material.opacity = lerp(0.15, 0.4, state.energy);
  });
  
  // Threshold jitter (entropy-based)
  thresholds.forEach((th, i) => {
    const jitter = lerp(0, 0.02, state.entropy) * Math.sin(t * (3 + i));
    th.mesh.scale.setScalar(1 + jitter);
    th.mat.opacity = lerp(0.3, 0.7, state.pressure);
  });
  
  // Spawn targets based on risk
  if (Math.random() < state.risk * 0.05) spawnTarget();
  
  // Update target lifecycle
  targets.forEach(t => {
    t.life -= t.decay;
    t.blink += 0.2 + state.entropy * 0.3;
  });
  targets = targets.filter(t => t.life > 0);
  
  updateTargets();
  
  // Alert effect
  if (state.risk > 0.7) {
    document.body.classList.add('alert-active');
    sweepMat.uniforms.u_color.value.setHex(0xff4444);
  } else {
    document.body.classList.remove('alert-active');
    sweepMat.uniforms.u_color.value.setHex(0x00ff88);
  }
  
  // UI
  document.getElementById('v-risk').textContent = state.risk.toFixed(2);
  document.getElementById('v-ent').textContent = state.entropy.toFixed(2);
  document.getElementById('v-prs').textContent = state.pressure.toFixed(2);
  document.getElementById('v-targets').textContent = targets.length;
  document.getElementById('v-sweep').textContent = Math.round((-sweep.rotation.z * 180 / Math.PI) % 360) + '°';
  
  renderer.render(scene, camera);
}

// Resize
window.addEventListener('resize', () => {
  const size = Math.min(window.innerWidth, window.innerHeight);
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Fetch real state
async function fetchState() {
  try {
    const r = await fetch('/status');
    const s = await r.json();
    state.entropy = s.signals.entropy;
    state.pressure = s.signals.pressure;
    state.energy = s.signals.gravity;
    state.flow = s.signals.release;
    state.risk = Math.min(1, s.signals.entropy * 1.5 + s.signals.pressure * 0.5);
  } catch(e) {}
}

fetchState();
setInterval(fetchState, 3000);
animate();
  </script>
</body>
</html>
