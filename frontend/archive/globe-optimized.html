<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Globe Optimized</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#000;overflow:hidden}
    #fps{position:fixed;top:10px;left:10px;color:#0f0;font:12px monospace;z-index:100}
    #info{position:fixed;top:30px;left:10px;color:#fff;font:10px system-ui;z-index:100;opacity:.6}
  </style>
</head>
<body>
  <div id="fps">FPS: --</div>
  <div id="info">Memory: -- MB</div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="/frontend/assets/autus-core.js"></script>
  <script>
// 성능 모니터
const fpsMonitor = AutusPerf.createFPSMonitor();

// Three.js 최적화 설정
const renderer = new THREE.WebGLRenderer({
  antialias: window.devicePixelRatio < 2,
  powerPreference: 'high-performance',
  stencil: false,
  depth: true
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(1.5, devicePixelRatio));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
camera.position.z = 4;

// 조명 (최소화)
scene.add(new THREE.AmbientLight(0x404040, 0.5));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(3, 2, 3);
scene.add(light);

// Globe (LOD)
const globeGeos = [
  new THREE.SphereGeometry(1, 64, 64),  // High
  new THREE.SphereGeometry(1, 32, 32),  // Medium
  new THREE.SphereGeometry(1, 16, 16)   // Low
];
const globeMat = new THREE.MeshPhongMaterial({
  color: 0x1a4a7a,
  emissive: 0x0a1525,
  emissiveIntensity: 0.3
});

const lod = new THREE.LOD();
lod.addLevel(new THREE.Mesh(globeGeos[0], globeMat), 0);
lod.addLevel(new THREE.Mesh(globeGeos[1], globeMat), 10);
lod.addLevel(new THREE.Mesh(globeGeos[2], globeMat), 30);
scene.add(lod);

// Grid (와이어프레임)
const grid = new THREE.Mesh(
  new THREE.SphereGeometry(1.02, 24, 24),
  new THREE.MeshBasicMaterial({color: 0x00d4ff, wireframe: true, transparent: true, opacity: 0.1})
);
scene.add(grid);

// Nodes (인스턴싱)
const nodeCount = 200;
const nodeGeo = new THREE.SphereGeometry(0.015, 8, 8);
const nodeMat = new THREE.MeshBasicMaterial({color: 0x00ff88});
const nodesMesh = new THREE.InstancedMesh(nodeGeo, nodeMat, nodeCount);

const dummy = new THREE.Object3D();
for (let i = 0; i < nodeCount; i++) {
  const phi = Math.acos(2 * Math.random() - 1);
  const theta = Math.random() * Math.PI * 2;
  const r = 1.03;
  dummy.position.set(
    r * Math.sin(phi) * Math.cos(theta),
    r * Math.sin(phi) * Math.sin(theta),
    r * Math.cos(phi)
  );
  dummy.updateMatrix();
  nodesMesh.setMatrixAt(i, dummy.matrix);
}
scene.add(nodesMesh);

// 상태 바인딩
let uniforms = { u_time: 0, u_energy: 0.5, u_entropy: 0.1 };

AutusCore.subscribe(data => {
  if (data.uniforms) uniforms = data.uniforms;
});
AutusCore.init();

// 애니메이션 (RAF 최적화)
let lastTime = 0;
function animate(time) {
  requestAnimationFrame(animate);
  
  const dt = (time - lastTime) / 1000;
  lastTime = time;
  
  // 회전 (uniforms 기반)
  const spinRate = 0.3 + uniforms.u_energy * 0.1;
  lod.rotation.y += spinRate * dt;
  grid.rotation.y = lod.rotation.y;
  nodesMesh.rotation.y = lod.rotation.y;
  
  // Emissive 업데이트
  globeMat.emissiveIntensity = 0.2 + uniforms.u_energy * 0.3;
  
  // FPS
  const fps = fpsMonitor.tick();
  document.getElementById('fps').textContent = `FPS: ${fps}`;
  
  // Memory
  const mem = AutusPerf.checkMemory();
  if (mem) {
    document.getElementById('info').textContent = `Memory: ${mem.used} / ${mem.total} MB`;
  }
  
  renderer.render(scene, camera);
}

// 리사이즈 (디바운스)
window.onresize = AutusPerf.debounce(() => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}, 100);

animate(0);
  </script>
</body>
</html>
