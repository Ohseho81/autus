<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUTUS Goal Anchor - 3-Axis Coordinate UI</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #070910;
      color: #b4b4aa;
      font-family: 'JetBrains Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
    }

    .container {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Goal Sliders */
    .goalSliders {
      padding: 16px;
      background: rgba(180, 180, 170, 0.03);
      border: 1px solid rgba(180, 180, 170, 0.08);
      border-radius: 8px;
    }

    .goalHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .goalTitle {
      font-size: 12px;
      font-weight: 500;
      color: rgba(180, 180, 170, 0.5);
      letter-spacing: 0.2em;
    }

    .horizonSelect {
      background: rgba(180, 180, 170, 0.08);
      border: 1px solid rgba(180, 180, 170, 0.15);
      color: rgba(180, 180, 170, 0.8);
      padding: 6px 10px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 10px;
      letter-spacing: 0.1em;
      cursor: pointer;
    }

    .sliders {
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 16px;
    }

    .sliderRow {
      display: grid;
      grid-template-columns: 28px 1fr 40px;
      gap: 12px;
      align-items: center;
    }

    .sliderAxis {
      font-size: 12px;
      font-weight: 500;
      color: rgba(180, 180, 170, 0.5);
      text-align: center;
    }

    .sliderInput {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: rgba(180, 180, 170, 0.12);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    .sliderInput::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: rgba(180, 180, 170, 0.7);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .sliderInput::-webkit-slider-thumb:hover {
      background: rgba(180, 180, 170, 0.9);
      transform: scale(1.1);
    }

    .sliderValue {
      font-size: 12px;
      color: rgba(180, 180, 170, 0.7);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .setButton {
      width: 100%;
      padding: 12px;
      background: rgba(180, 180, 170, 0.1);
      border: 1px solid rgba(180, 180, 170, 0.2);
      color: rgba(180, 180, 170, 0.8);
      font-family: inherit;
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.2em;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .setButton:hover {
      background: rgba(180, 180, 170, 0.15);
      border-color: rgba(180, 180, 170, 0.3);
    }

    .setButton:active {
      background: rgba(180, 180, 170, 0.2);
    }

    /* Delta Display */
    .deltaDisplay {
      margin-top: 14px;
      padding: 10px;
      background: rgba(180, 180, 170, 0.04);
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .deltaLabel {
      font-size: 12px;
      font-weight: 500;
      color: rgba(180, 180, 170, 0.4);
    }

    .deltaValues {
      font-size: 11px;
      color: rgba(180, 180, 170, 0.6);
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.05em;
    }

    /* Canvas Map */
    .mapWrap {
      border-radius: 12px;
      background: rgba(180, 180, 170, 0.02);
      padding: 10px;
    }

    canvas {
      border-radius: 8px;
      display: block;
      width: 100%;
    }

    /* Coordinate Display */
    .coordDisplay {
      padding: 12px;
      background: rgba(180, 180, 170, 0.03);
      border: 1px solid rgba(180, 180, 170, 0.08);
      border-radius: 6px;
      font-size: 11px;
      color: rgba(180, 180, 170, 0.6);
      text-align: center;
      letter-spacing: 0.1em;
      font-variant-numeric: tabular-nums;
    }

    .version {
      margin-top: 16px;
      font-size: 8px;
      letter-spacing: 0.15em;
      color: rgba(180, 180, 170, 0.2);
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Goal Sliders -->
    <div class="goalSliders">
      <div class="goalHeader">
        <div class="goalTitle">GOAL S*</div>
        <select class="horizonSelect" id="horizon">
          <option value="1day">1D</option>
          <option value="1week" selected>1W</option>
          <option value="1month">1M</option>
          <option value="1year">1Y</option>
        </select>
      </div>

      <div class="sliders">
        <div class="sliderRow">
          <div class="sliderAxis">E</div>
          <input type="range" min="0" max="100" value="50" class="sliderInput" id="energy">
          <div class="sliderValue" id="energyVal">50</div>
        </div>
        <div class="sliderRow">
          <div class="sliderAxis">F</div>
          <input type="range" min="0" max="100" value="50" class="sliderInput" id="flow">
          <div class="sliderValue" id="flowVal">50</div>
        </div>
        <div class="sliderRow">
          <div class="sliderAxis">R</div>
          <input type="range" min="0" max="100" value="50" class="sliderInput" id="risk">
          <div class="sliderValue" id="riskVal">50</div>
        </div>
      </div>

      <button class="setButton" id="setBtn">SET</button>

      <div class="deltaDisplay">
        <span class="deltaLabel">Δ</span>
        <span class="deltaValues" id="delta">E +0.0  F +0.0  R +0.0</span>
      </div>
    </div>

    <!-- Physics Map with Anchor -->
    <div class="mapWrap">
      <canvas id="map" width="380" height="380"></canvas>
    </div>

    <!-- Coordinate Display -->
    <div class="coordDisplay" id="coord">
      S* = [E: 50.0, F: 50.0, R: 50.0]
    </div>

    <div class="version">GOAL ANCHOR v1.0 / SN</div>
  </div>

  <script>
    /**
     * AUTUS Goal Anchor Engine
     * Semantic Neutrality Compliant
     * 
     * Goal = coordinate S* = [E*, F*, R*]
     * No "good" or "bad" judgments
     * Numbers only
     */

    class GoalAnchorEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.origin = { x: this.width / 2, y: this.height / 2 };

        // Goal coordinate S*
        this.goal = { energy: 50, flow: 50, risk: 50 };
        this.horizon = '1week';

        // Current state S (simulated)
        this.current = { energy: 67, flow: 55, risk: 28 };

        // Nodes for visualization
        this.nodes = this.generateNodes();

        // Animation
        this.t = 0;
        this.anchorPulse = 0;
      }

      generateNodes() {
        const nodes = [];
        for (let i = 0; i < 12; i++) {
          nodes.push({
            angle: (i * Math.PI * 2) / 12 + Math.random() * 0.2,
            r: 80 + Math.random() * 60,
            mass: 0.5 + Math.random() * 1.5,
            velocity: 0.002 + Math.random() * 0.003,
          });
        }
        return nodes;
      }

      setGoal(energy, flow, risk, horizon) {
        this.goal = { energy, flow, risk };
        this.horizon = horizon;
        this.anchorPulse = 1; // Trigger pulse animation
      }

      getDelta() {
        return {
          d_energy: this.goal.energy - this.current.energy,
          d_flow: this.goal.flow - this.current.flow,
          d_risk: this.goal.risk - this.current.risk,
        };
      }

      update() {
        this.t += 0.02;

        // Decay anchor pulse
        this.anchorPulse *= 0.95;

        // Update nodes - attracted toward Goal
        const goalStrength = (this.goal.energy + this.goal.flow) / 200;
        
        this.nodes.forEach(node => {
          node.angle += node.velocity;
          
          // Slight attraction toward center based on goal
          const targetR = 80 + (100 - this.goal.risk) * 0.4;
          node.r += (targetR - node.r) * 0.01 * goalStrength;
        });
      }

      draw() {
        const { ctx, origin, width, height } = this;
        
        ctx.clearRect(0, 0, width, height);

        // Background
        ctx.fillStyle = '#0a0c10';
        ctx.fillRect(0, 0, width, height);

        // Grid
        this.drawGrid();

        // Orbital rings
        [60, 100, 140].forEach(r => {
          ctx.beginPath();
          ctx.arc(origin.x, origin.y, r, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(180, 180, 170, 0.05)';
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        // Nodes (attracted to Goal Anchor)
        this.nodes.forEach(node => {
          const x = origin.x + Math.cos(node.angle) * node.r;
          const y = origin.y + Math.sin(node.angle) * node.r;
          const size = 2 + node.mass * 3;

          // Line to center (attraction visualization)
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(origin.x, origin.y);
          ctx.strokeStyle = 'rgba(180, 180, 170, 0.06)';
          ctx.lineWidth = 0.5;
          ctx.stroke();

          // Node
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(180, 180, 170, 0.5)';
          ctx.fill();
        });

        // Goal Anchor (◎) - center
        this.drawAnchor();

        // Coordinate label (numbers only)
        this.drawCoordLabel();
      }

      drawGrid() {
        const { ctx, width, height } = this;
        const gridSize = 40;

        ctx.strokeStyle = 'rgba(180, 180, 170, 0.03)';
        ctx.lineWidth = 0.5;

        for (let x = 0; x <= width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y <= height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      drawAnchor() {
        const { ctx, origin, goal, anchorPulse } = this;

        // Pulse glow on set
        if (anchorPulse > 0.01) {
          const glowSize = 50 + anchorPulse * 30;
          const gradient = ctx.createRadialGradient(
            origin.x, origin.y, 0,
            origin.x, origin.y, glowSize
          );
          gradient.addColorStop(0, `rgba(180, 180, 170, ${anchorPulse * 0.3})`);
          gradient.addColorStop(1, 'rgba(180, 180, 170, 0)');
          
          ctx.beginPath();
          ctx.arc(origin.x, origin.y, glowSize, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        }

        // Outer ring (◎)
        const anchorSize = 20 + (goal.energy / 100) * 10;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, anchorSize, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Inner ring
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, anchorSize * 0.5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.4)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Core dot
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180, 180, 170, 0.8)';
        ctx.fill();

        // Crosshair
        const ch = anchorSize + 8;
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.3)';
        ctx.lineWidth = 1;

        [-1, 1].forEach(dir => {
          ctx.beginPath();
          ctx.moveTo(origin.x + dir * (anchorSize + 4), origin.y);
          ctx.lineTo(origin.x + dir * ch, origin.y);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y + dir * (anchorSize + 4));
          ctx.lineTo(origin.x, origin.y + dir * ch);
          ctx.stroke();
        });
      }

      drawCoordLabel() {
        const { ctx, origin, goal } = this;

        // Label below anchor (numbers only, no meaning)
        ctx.font = '9px monospace';
        ctx.fillStyle = 'rgba(180, 180, 170, 0.4)';
        ctx.textAlign = 'center';
        ctx.fillText('S*', origin.x, origin.y + 45);
      }

      render() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.render());
      }
    }

    // Initialize
    const engine = new GoalAnchorEngine(document.getElementById('map'));
    engine.render();

    // Slider handlers
    const energySlider = document.getElementById('energy');
    const flowSlider = document.getElementById('flow');
    const riskSlider = document.getElementById('risk');
    const horizonSelect = document.getElementById('horizon');

    const energyVal = document.getElementById('energyVal');
    const flowVal = document.getElementById('flowVal');
    const riskVal = document.getElementById('riskVal');
    const deltaEl = document.getElementById('delta');
    const coordEl = document.getElementById('coord');

    function updateDisplays() {
      const e = parseFloat(energySlider.value);
      const f = parseFloat(flowSlider.value);
      const r = parseFloat(riskSlider.value);

      energyVal.textContent = e.toFixed(0);
      flowVal.textContent = f.toFixed(0);
      riskVal.textContent = r.toFixed(0);

      coordEl.textContent = `S* = [E: ${e.toFixed(1)}, F: ${f.toFixed(1)}, R: ${r.toFixed(1)}]`;
    }

    function updateDelta() {
      const delta = engine.getDelta();
      const fmt = (v) => (v >= 0 ? '+' : '') + v.toFixed(1);
      deltaEl.textContent = `E ${fmt(delta.d_energy)}  F ${fmt(delta.d_flow)}  R ${fmt(delta.d_risk)}`;
    }

    energySlider.addEventListener('input', updateDisplays);
    flowSlider.addEventListener('input', updateDisplays);
    riskSlider.addEventListener('input', updateDisplays);

    document.getElementById('setBtn').addEventListener('click', () => {
      const e = parseFloat(energySlider.value);
      const f = parseFloat(flowSlider.value);
      const r = parseFloat(riskSlider.value);
      const h = horizonSelect.value;

      engine.setGoal(e, f, r, h);
      updateDelta();
    });

    // Initial
    updateDisplays();
    updateDelta();

    window.goalEngine = engine;
  </script>
</body>
</html>
