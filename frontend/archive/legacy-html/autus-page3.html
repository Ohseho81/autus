<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUTUS / PAGE 3 — MANDALA INVESTMENT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #00f0ff;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        /* Mandala Title */
        .mandala-title {
            position: fixed;
            top: 6%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            letter-spacing: 4px;
            opacity: 0.6;
            z-index: 10;
        }
        
        /* Slot Labels */
        .slot-label {
            position: fixed;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        
        .slot-label:hover { opacity: 1 !important; }
        
        .slot-direction {
            font-size: 9px;
            opacity: 0.35;
            letter-spacing: 1px;
        }
        
        .slot-icon {
            width: 32px; height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.65;
        }
        
        .slot-icon svg { width: 24px; height: 24px; }
        
        .slot-name {
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        
        /* Slot Positions - 원본과 동일하게 */
        #slot-n { top: 12%; left: 50%; transform: translateX(-50%); }
        #slot-ne { top: 20%; right: 18%; }
        #slot-e { top: 50%; right: 8%; transform: translateY(-50%); }
        #slot-se { bottom: 20%; right: 18%; }
        #slot-s { bottom: 12%; left: 50%; transform: translateX(-50%); }
        #slot-sw { bottom: 20%; left: 18%; }
        #slot-w { top: 50%; left: 8%; transform: translateY(-50%); }
        #slot-nw { top: 20%; left: 18%; }
        
        /* Center Labels */
        .center-label {
            position: fixed;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.4;
            z-index: 5;
            color: #00f0ff;
        }
        
        #label-self-core-1 { top: 40%; left: 47%; }
        #label-self-core-2 { bottom: 38%; left: 47%; }
        
        /* Stats Panel */
        .stats-panel {
            position: fixed;
            bottom: 85px;
            left: 30px;
            z-index: 10;
            background: rgba(0, 10, 20, 0.85);
            border: 1px solid rgba(0, 240, 255, 0.3);
            padding: 12px 18px;
            font-family: 'SF Mono', monospace;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 4px;
            font-size: 11px;
        }
        
        .stat-label { opacity: 0.6; letter-spacing: 1px; }
        .stat-value { font-weight: 600; }
        
        /* Bottom Icons - $, 시계, 뇌 */
        .bottom-icons {
            position: fixed;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .bottom-icon {
            width: 32px; height: 32px;
            border: 1px solid rgba(0, 240, 255, 0.35);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            cursor: pointer;
            font-size: 14px;
        }
        
        .bottom-icon:hover {
            opacity: 0.8;
            background: rgba(0, 240, 255, 0.1);
        }
        
        /* Mode Toggle */
        .mode-toggle {
            position: fixed;
            bottom: 35px;
            right: 35px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .mode-label {
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.5;
        }
        
        .mode-button {
            width: 70px; height: 36px;
            border: 2px solid #00f0ff;
            border-radius: 18px;
            background: rgba(0, 240, 255, 0.1);
            color: #00f0ff;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
        }
        
        .mode-button::after {
            content: '';
            position: absolute;
            top: 50%; right: 8px;
            width: 8px; height: 8px;
            background: #f0a000;
            border-radius: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 8px #f0a000;
        }
        
        /* Page Title */
        .page-title {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 3px;
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Mandala Title -->
    <div class="mandala-title">Mandala Ring</div>
    
    <!-- Slot Labels - 원본 아이콘과 동일 -->
    <div class="slot-label" id="slot-n" data-slot="N">
        <span class="slot-direction">N</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <polygon points="12,2 22,22 12,17 2,22"/>
            </svg>
        </div>
        <span class="slot-name">Risk</span>
    </div>
    
    <div class="slot-label" id="slot-ne" data-slot="NE">
        <span class="slot-direction">NE</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="8" r="5"/>
                <path d="M12 13v5"/>
                <path d="M9 21h6"/>
            </svg>
        </div>
        <span class="slot-name">Risk</span>
    </div>
    
    <div class="slot-label" id="slot-e" data-slot="E">
        <span class="slot-direction">E</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v4m0 12v4m8-10h-4M8 12H4"/>
                <path d="M18 6l-3 3m-6 6l-3 3m12 0l-3-3M9 9L6 6"/>
            </svg>
        </div>
        <span class="slot-name">Energy</span>
    </div>
    
    <div class="slot-label" id="slot-se" data-slot="SE">
        <span class="slot-direction">SE</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M12 5v14"/>
                <path d="M5 12l7 7 7-7"/>
            </svg>
        </div>
        <span class="slot-name">Leak</span>
    </div>
    
    <div class="slot-label" id="slot-s" data-slot="S">
        <span class="slot-direction">S</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="3"/>
                <circle cx="12" cy="12" r="6"/>
                <circle cx="12" cy="12" r="9"/>
            </svg>
        </div>
        <span class="slot-name">Pattern</span>
    </div>
    
    <div class="slot-label" id="slot-sw" data-slot="SW">
        <span class="slot-direction">SW</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="7" cy="12" r="3"/>
                <circle cx="17" cy="12" r="3"/>
                <path d="M10 12h4"/>
            </svg>
        </div>
        <span class="slot-name">Drag</span>
    </div>
    
    <div class="slot-label" id="slot-w" data-slot="W">
        <span class="slot-direction">W</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="6" cy="12" r="3"/>
                <circle cx="18" cy="12" r="3"/>
                <path d="M9 12h6"/>
                <path d="M9 10l-2 2 2 2"/>
                <path d="M15 10l2 2-2 2"/>
            </svg>
        </div>
        <span class="slot-name">Connection</span>
    </div>
    
    <div class="slot-label" id="slot-nw" data-slot="NW">
        <span class="slot-direction">NW</span>
        <div class="slot-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="5" y="11" width="14" height="10" rx="2"/>
                <path d="M12 11V6a3 3 0 00-6 0v5"/>
            </svg>
        </div>
        <span class="slot-name">Constraint</span>
    </div>
    
    <!-- Center Labels -->
    <div class="center-label" id="label-self-core-1">Self Core</div>
    <div class="center-label" id="label-self-core-2">Self Core</div>
    
    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="stat-row">
            <span class="stat-label">ENERGY:</span>
            <span class="stat-value" id="energy-value">0.50</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">PRESSURE:</span>
            <span class="stat-value" id="pressure-value">0.50</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">LEAK: VOLUME:</span>
            <span class="stat-value" id="leak-value">0.10</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">SIGMA:</span>
            <span class="stat-value" id="sigma-value">0.30</span>
        </div>
    </div>
    
    <!-- Bottom Icons - $, 시계, 뇌 -->
    <div class="bottom-icons">
        <div class="bottom-icon">$</div>
        <div class="bottom-icon">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="9"/>
                <path d="M12 6v6l4 2"/>
            </svg>
        </div>
        <div class="bottom-icon">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M12 2a7 7 0 017 7c0 3-2 5-3 7h-8c-1-2-3-4-3-7a7 7 0 017-7z"/>
                <path d="M9 22h6"/>
                <path d="M10 19h4"/>
            </svg>
        </div>
    </div>
    
    <!-- Mode Toggle -->
    <div class="mode-toggle">
        <span class="mode-label">SimLive</span>
        <button class="mode-button">LIVE</button>
    </div>
    
    <!-- Page Title -->
    <div class="page-title">Mones / PAGE 4 — Time / Focus</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        const CYAN = 0x00f0ff;
        const RED_TINT = 0x401030;  // 보라/마젠타 틴트
        const DARK_TEAL = 0x002025;
        
        const segments = 8;
        const innerRadius = 0.75;
        const outerRadius = 2.1;
        
        // 붉은 틴트가 들어갈 슬롯 인덱스 (원본 참조)
        const redTintSlots = [0, 1, 3, 5, 7]; // N, NE, SE, SW, NW
        
        // Create segment
        function createSegment(index, total) {
            const angleStart = (index / total) * Math.PI * 2 - Math.PI / 2 - Math.PI / total;
            const angleEnd = ((index + 1) / total) * Math.PI * 2 - Math.PI / 2 - Math.PI / total;
            
            const shape = new THREE.Shape();
            
            const outerPoints = [];
            for (let i = 0; i <= 16; i++) {
                const angle = angleStart + (angleEnd - angleStart) * (i / 16);
                outerPoints.push(new THREE.Vector2(
                    Math.cos(angle) * outerRadius,
                    Math.sin(angle) * outerRadius
                ));
            }
            
            const innerPoints = [];
            for (let i = 16; i >= 0; i--) {
                const angle = angleStart + (angleEnd - angleStart) * (i / 16);
                innerPoints.push(new THREE.Vector2(
                    Math.cos(angle) * innerRadius,
                    Math.sin(angle) * innerRadius
                ));
            }
            
            shape.moveTo(outerPoints[0].x, outerPoints[0].y);
            outerPoints.forEach(p => shape.lineTo(p.x, p.y));
            innerPoints.forEach(p => shape.lineTo(p.x, p.y));
            shape.closePath();
            
            const geometry = new THREE.ShapeGeometry(shape);
            
            const hasRedTint = redTintSlots.includes(index);
            
            const material = new THREE.MeshBasicMaterial({
                color: hasRedTint ? RED_TINT : DARK_TEAL,
                transparent: true,
                opacity: 0.65,
                side: THREE.DoubleSide
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        // Create segment outline
        function createSegmentOutline(index, total) {
            const angleStart = (index / total) * Math.PI * 2 - Math.PI / 2 - Math.PI / total;
            const angleEnd = ((index + 1) / total) * Math.PI * 2 - Math.PI / 2 - Math.PI / total;
            
            const points = [];
            
            for (let i = 0; i <= 16; i++) {
                const angle = angleStart + (angleEnd - angleStart) * (i / 16);
                points.push(new THREE.Vector3(
                    Math.cos(angle) * outerRadius,
                    Math.sin(angle) * outerRadius,
                    0
                ));
            }
            
            points.push(new THREE.Vector3(
                Math.cos(angleEnd) * innerRadius,
                Math.sin(angleEnd) * innerRadius,
                0
            ));
            
            for (let i = 16; i >= 0; i--) {
                const angle = angleStart + (angleEnd - angleStart) * (i / 16);
                points.push(new THREE.Vector3(
                    Math.cos(angle) * innerRadius,
                    Math.sin(angle) * innerRadius,
                    0
                ));
            }
            
            points.push(points[0].clone());
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.45
            });
            
            return new THREE.Line(geometry, material);
        }
        
        // Add all segments
        for (let i = 0; i < segments; i++) {
            scene.add(createSegment(i, segments));
            scene.add(createSegmentOutline(i, segments));
        }
        
        // Center Core
        const coreGeometry = new THREE.SphereGeometry(0.55, 32, 32);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.2
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);
        
        // Core rim
        const coreRimGeometry = new THREE.RingGeometry(0.53, 0.57, 64);
        const coreRimMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        scene.add(new THREE.Mesh(coreRimGeometry, coreRimMaterial));
        
        // Inner ring
        const innerRingGeometry = new THREE.RingGeometry(innerRadius - 0.015, innerRadius + 0.015, 64);
        const innerRingMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        scene.add(new THREE.Mesh(innerRingGeometry, innerRingMaterial));
        
        // Outer ring
        const outerRingGeometry = new THREE.RingGeometry(outerRadius - 0.015, outerRadius + 0.015, 64);
        const outerRingMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        scene.add(new THREE.Mesh(outerRingGeometry, outerRingMaterial));
        
        // Radial dividers
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2 - Math.PI / 2 - Math.PI / segments;
            const points = [
                new THREE.Vector3(Math.cos(angle) * innerRadius, Math.sin(angle) * innerRadius, 0),
                new THREE.Vector3(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius, 0)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.35
            });
            scene.add(new THREE.Line(geometry, material));
        }
        
        // Star particles
        const particlesCount = 800;
        const positions = new Float32Array(particlesCount * 3);
        
        for (let i = 0; i < particlesCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 12;
            positions[i + 1] = (Math.random() - 0.5) * 10;
            positions[i + 2] = (Math.random() - 0.5) * 6;
        }
        
        const particlesGeometry = new THREE.BufferGeometry();
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            color: CYAN,
            size: 0.015,
            transparent: true,
            opacity: 0.35,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);
        
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.003;
            
            core.rotation.y += 0.002;
            
            const pulse = 1 + Math.sin(time * 2) * 0.015;
            core.scale.set(pulse, pulse, pulse);
            
            particles.rotation.y += 0.0001;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Slot interaction
        const slots = document.querySelectorAll('.slot-label');
        let allocations = {
            N: 0.125, NE: 0.125, E: 0.125, SE: 0.125,
            S: 0.125, SW: 0.125, W: 0.125, NW: 0.125
        };
        
        slots.forEach(slot => {
            slot.addEventListener('click', async () => {
                const slotName = slot.dataset.slot;
                allocations[slotName] = Math.min(1, allocations[slotName] + 0.1);
                
                const total = Object.values(allocations).reduce((a, b) => a + b, 0);
                Object.keys(allocations).forEach(k => {
                    allocations[k] = allocations[k] / total;
                });
                
                try {
                    await fetch('http://localhost:8001/draft/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: 'page3_session',
                            t_ms: Date.now(),
                            page: 3,
                            patch: { allocations }
                        })
                    });
                    fetchState();
                } catch (e) {}
            });
        });
        
        async function fetchState() {
            try {
                const res = await fetch('http://localhost:8001/state?session_id=page3_session');
                const data = await res.json();
                document.getElementById('energy-value').textContent = data.measure.E.toFixed(2);
                document.getElementById('pressure-value').textContent = data.measure.pressure.toFixed(2);
                document.getElementById('leak-value').textContent = data.measure.leak.toFixed(2);
                document.getElementById('sigma-value').textContent = data.measure.sigma.toFixed(2);
            } catch (e) {}
        }
        
        fetchState();
    </script>
</body>
</html>

