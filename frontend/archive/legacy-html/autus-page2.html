<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUTUS / PAGE 2 — ROUTE / TOPOLOGY</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #00f0ff;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        /* Labels */
        .label {
            position: fixed;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.5;
            z-index: 5;
            color: #00f0ff;
        }
        
        #label-self-node { top: 42%; left: 46%; }
        #label-self-route { top: 30%; right: 32%; }
        #label-self-node-2 { bottom: 35%; left: 47%; }
        
        /* Controls Panel */
        .controls-panel {
            position: fixed;
            bottom: 50px;
            left: 40px;
            z-index: 10;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 10px;
        }
        
        .control-icon {
            width: 22px; height: 22px;
            opacity: 0.5;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slider-container {
            width: 70px; height: 4px;
            background: rgba(0, 240, 255, 0.2);
            border-radius: 2px;
            position: relative;
        }
        
        .slider-thumb {
            width: 10px; height: 10px;
            background: #00f0ff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px #00f0ff;
        }
        
        .control-labels {
            display: flex;
            gap: 30px;
            margin-top: 8px;
        }
        
        .control-label {
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.5;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
        }
        
        .camera-icon {
            width: 26px; height: 26px;
            border: 1px solid rgba(0, 240, 255, 0.4);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }
        
        /* Mode Toggle */
        .mode-toggle {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .mode-label {
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.5;
        }
        
        .mode-button {
            width: 70px; height: 36px;
            border: 2px solid #00f0ff;
            border-radius: 18px;
            background: rgba(0, 240, 255, 0.1);
            color: #00f0ff;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
        }
        
        .mode-button::after {
            content: '';
            position: absolute;
            top: 50%; right: 8px;
            width: 8px; height: 8px;
            background: #f0a000;
            border-radius: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 8px #f0a000;
        }
        
        /* Page Title */
        .page-title {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 3px;
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Labels -->
    <div class="label" id="label-self-node">Self Node</div>
    <div class="label" id="label-self-route">Self Route</div>
    <div class="label" id="label-self-node-2">Self Node</div>
    
    <!-- Controls Panel -->
    <div class="controls-panel">
        <div class="control-row">
            <div class="control-icon">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 2v4m0 12v4m10-10h-4M6 12H2"/>
                </svg>
            </div>
            <div class="slider-container">
                <div class="slider-thumb" style="left: 15%"></div>
            </div>
            <div class="control-icon">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83"/>
                </svg>
            </div>
        </div>
        <div class="control-labels">
            <span class="control-label">Mass</span>
            <span class="control-label">Flow Filter</span>
            <span class="control-label">Sigma</span>
        </div>
        <div class="settings-row">
            <div class="control-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06"/>
                </svg>
            </div>
            <div class="slider-container" style="width: 60px;">
                <div class="slider-thumb" style="left: 50%"></div>
            </div>
        </div>
        <div class="settings-row">
            <div class="camera-icon">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
            </div>
        </div>
    </div>
    
    <!-- Mode Toggle -->
    <div class="mode-toggle">
        <span class="mode-label">SimLive</span>
        <button class="mode-button">LIVE</button>
    </div>
    
    <!-- Page Title -->
    <div class="page-title">AUTUS / PAGE 2 — ROUTE / TOPOLOGY</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        const CYAN = 0x00f0ff;
        
        // Concentric Rings
        function createRing(radius, opacity = 0.2) {
            const geometry = new THREE.RingGeometry(radius - 0.01, radius + 0.01, 128);
            const material = new THREE.MeshBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide
            });
            return new THREE.Mesh(geometry, material);
        }
        
        // 동심원들
        for (let i = 1; i <= 6; i++) {
            const ring = createRing(i * 0.45, 0.12 + (6 - i) * 0.02);
            scene.add(ring);
        }
        
        // Outer dashed ring
        function createDashedRing(radius) {
            const curve = new THREE.EllipseCurve(0, 0, radius, radius, 0, 2 * Math.PI, false, 0);
            const points = curve.getPoints(128);
            const geometry = new THREE.BufferGeometry().setFromPoints(
                points.map(p => new THREE.Vector3(p.x, p.y, 0))
            );
            const material = new THREE.LineDashedMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.15,
                dashSize: 0.08,
                gapSize: 0.08
            });
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            return line;
        }
        
        scene.add(createDashedRing(3.0));
        scene.add(createDashedRing(3.3));
        
        // Radial grid lines
        for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2;
            const points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.06
            });
            scene.add(new THREE.Line(geometry, material));
        }
        
        // Self Node (Center)
        const selfNodeGeometry = new THREE.SphereGeometry(0.35, 32, 32);
        const selfNodeMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.35
        });
        const selfNode = new THREE.Mesh(selfNodeGeometry, selfNodeMaterial);
        scene.add(selfNode);
        
        const selfRimGeometry = new THREE.RingGeometry(0.33, 0.37, 64);
        const selfRimMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        scene.add(new THREE.Mesh(selfRimGeometry, selfRimMaterial));
        
        // Outer Nodes
        const nodes = [];
        const nodeData = [
            { angle: 0.4, radius: 1.3, size: 0.14 },
            { angle: 0.9, radius: 1.8, size: 0.12 },
            { angle: 1.4, radius: 1.5, size: 0.16 },
            { angle: 2.0, radius: 2.2, size: 0.11 },
            { angle: 2.5, radius: 1.1, size: 0.13 },
            { angle: 3.2, radius: 2.0, size: 0.15 },
            { angle: 3.8, radius: 1.4, size: 0.10 },
            { angle: 4.3, radius: 2.5, size: 0.12 },
            { angle: 4.9, radius: 1.7, size: 0.14 },
            { angle: 5.5, radius: 1.2, size: 0.11 },
            { angle: 5.9, radius: 2.1, size: 0.13 },
            { angle: Math.PI / 2, radius: 2.9, size: 0.18 }, // Top big node
            { angle: -Math.PI / 2, radius: 2.6, size: 0.15 }, // Bottom nodes
            { angle: -Math.PI / 2 + 0.3, radius: 2.4, size: 0.12 },
        ];
        
        nodeData.forEach(data => {
            const x = Math.cos(data.angle) * data.radius;
            const y = Math.sin(data.angle) * data.radius;
            
            // Node sphere
            const nodeGeometry = new THREE.SphereGeometry(data.size, 16, 16);
            const nodeMaterial = new THREE.MeshBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.45
            });
            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
            node.position.set(x, y, 0);
            nodes.push(node);
            scene.add(node);
            
            // Node ring
            const ringGeometry = new THREE.RingGeometry(data.size - 0.015, data.size + 0.015, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(x, y, 0);
            scene.add(ring);
        });
        
        // Edges (노드 간 연결선) - 중요!
        function createEdge(from, to, opacity = 0.25) {
            const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
            const material = new THREE.LineBasicMaterial({
                color: CYAN,
                transparent: true,
                opacity: opacity
            });
            return new THREE.Line(geometry, material);
        }
        
        // 중앙에서 각 노드로 연결
        nodes.forEach((node, i) => {
            if (Math.random() > 0.2) {
                const edge = createEdge(
                    new THREE.Vector3(0, 0, 0),
                    node.position,
                    0.12 + Math.random() * 0.15
                );
                scene.add(edge);
            }
        });
        
        // 노드들 사이 연결
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                if (Math.random() > 0.7) {
                    const edge = createEdge(
                        nodes[i].position,
                        nodes[j].position,
                        0.08 + Math.random() * 0.1
                    );
                    scene.add(edge);
                }
            }
        }
        
        // Tilted orbit ring
        const orbitGeometry = new THREE.RingGeometry(2.35, 2.38, 128);
        const orbitMaterial = new THREE.MeshBasicMaterial({
            color: CYAN,
            transparent: true,
            opacity: 0.35,
            side: THREE.DoubleSide
        });
        const orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
        orbitRing.rotation.x = 0.5;
        scene.add(orbitRing);
        
        // Star particles
        const particlesCount = 1200;
        const positions = new Float32Array(particlesCount * 3);
        
        for (let i = 0; i < particlesCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 14;
            positions[i + 1] = (Math.random() - 0.5) * 12;
            positions[i + 2] = (Math.random() - 0.5) * 8;
        }
        
        const particlesGeometry = new THREE.BufferGeometry();
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            color: CYAN,
            size: 0.02,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);
        
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.003;
            
            selfNode.rotation.y += 0.002;
            
            nodes.forEach((node, i) => {
                const scale = 1 + Math.sin(time * 2 + i * 0.5) * 0.04;
                node.scale.set(scale, scale, scale);
            });
            
            orbitRing.rotation.z += 0.0008;
            particles.rotation.y += 0.0001;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

