<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AUTUS Network HQ</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#030810;overflow:hidden;font-family:system-ui,sans-serif}
    #info{position:fixed;top:20px;left:20px;color:#fff;z-index:100;font-size:10px;opacity:.8}
    #info h1{font-size:11px;font-weight:700;letter-spacing:.2em;color:#00d4ff;margin-bottom:10px}
    #info .row{margin:3px 0;display:flex;justify-content:space-between;width:120px}
    #info .val{color:#00d4ff}
    #controls{position:fixed;bottom:20px;left:20px;z-index:100}
    #controls button{padding:6px 12px;margin-right:6px;background:rgba(0,212,255,.1);border:1px solid rgba(0,212,255,.3);color:#00d4ff;border-radius:4px;font-size:10px;cursor:pointer}
    #controls button:hover{background:rgba(0,212,255,.2)}
    #back{position:fixed;top:20px;right:20px;padding:8px 16px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);color:#fff;text-decoration:none;border-radius:6px;font-size:11px;z-index:100}
    .alert-active{animation:alert-flash 0.5s infinite}
    @keyframes alert-flash{50%{background:rgba(255,68,68,.05)}}
  </style>
</head>
<body>
  <div id="info">
    <h1>NETWORK HQ · FLOW</h1>
    <div class="row"><span>Flow</span><span class="val" id="v-flow">0.00</span></div>
    <div class="row"><span>Energy</span><span class="val" id="v-energy">0.50</span></div>
    <div class="row"><span>Entropy</span><span class="val" id="v-ent">0.00</span></div>
    <div class="row"><span>Nodes</span><span class="val" id="v-nodes">0</span></div>
    <div class="row"><span>Links</span><span class="val" id="v-links">0</span></div>
    <div class="row"><span>Traffic</span><span class="val" id="v-traffic">0</span></div>
  </div>
  <div id="controls">
    <button onclick="addFlow()">+Flow</button>
    <button onclick="addNode()">+Node</button>
    <button onclick="addEntropy()">+Entropy</button>
    <button onclick="resetState()">Reset</button>
  </div>
  <a id="back" href="/frontend/hud-demo.html">← HUD</a>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
// === State ===
let state = { flow: 0.4, energy: 0.5, entropy: 0.1, pressure: 0.2, risk: 0.1 };

function addFlow() { state.flow = Math.min(1, state.flow + 0.1); state.energy = Math.min(1, state.energy + 0.05); }
function addNode() { createNode(); }
function addEntropy() { state.entropy = Math.min(1, state.entropy + 0.1); state.risk = Math.min(1, state.risk + 0.05); }
function resetState() { 
  state = { flow: 0.4, energy: 0.5, entropy: 0.1, pressure: 0.2, risk: 0.1 }; 
  nodes = []; 
  links = [];
  initNetwork();
}

function lerp(a, b, t) { return a + (b - a) * Math.max(0, Math.min(1, t)); }

// === Network Data ===
let nodes = [];
let links = [];
const MAX_NODES = 80;

function createNode(x, y) {
  if (nodes.length >= MAX_NODES) return;
  const node = {
    id: nodes.length,
    x: x !== undefined ? x : (Math.random() - 0.5) * 1.6,
    y: y !== undefined ? y : (Math.random() - 0.5) * 1.2,
    size: 0.02 + Math.random() * 0.02,
    group: Math.floor(Math.random() * 4),
    pulse: Math.random() * Math.PI * 2,
    vx: (Math.random() - 0.5) * 0.001,
    vy: (Math.random() - 0.5) * 0.001
  };
  nodes.push(node);
  
  // Create links to nearby nodes
  nodes.forEach((n, i) => {
    if (n.id === node.id) return;
    const dx = n.x - node.x;
    const dy = n.y - node.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 0.4 && Math.random() > 0.5) {
      links.push({
        a: node.id,
        b: n.id,
        weight: Math.random(),
        traffic: 0
      });
    }
  });
}

function initNetwork() {
  // Create initial nodes
  for (let i = 0; i < 30; i++) {
    createNode();
  }
}

// === Three.js ===
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 0.75, -0.75, 0.1, 10);
camera.position.z = 1;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setClearColor(0x030810);
document.body.appendChild(renderer.domElement);

// === Background Grid ===
const gridGroup = new THREE.Group();
const gridSize = 2;
const gridSpacing = 0.1;

for (let x = -gridSize; x <= gridSize; x += gridSpacing) {
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute([x, -gridSize, 0, x, gridSize, 0], 3));
  gridGroup.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.08 })));
}
for (let y = -gridSize; y <= gridSize; y += gridSpacing) {
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute([-gridSize, y, 0, gridSize, y, 0], 3));
  gridGroup.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.08 })));
}
scene.add(gridGroup);

// === Links ===
const linkMaterial = new THREE.LineBasicMaterial({ 
  color: 0x00d4ff, 
  transparent: true, 
  opacity: 0.4 
});
const linkGroup = new THREE.Group();
scene.add(linkGroup);

function updateLinks() {
  // Clear old
  while (linkGroup.children.length) {
    linkGroup.remove(linkGroup.children[0]);
  }
  
  // Draw new
  links.forEach(link => {
    const nodeA = nodes.find(n => n.id === link.a);
    const nodeB = nodes.find(n => n.id === link.b);
    if (!nodeA || !nodeB) return;
    
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute([
      nodeA.x, nodeA.y, 0,
      nodeB.x, nodeB.y, 0
    ], 3));
    
    const mat = linkMaterial.clone();
    mat.opacity = lerp(0.2, 0.6, state.flow) * (0.5 + link.weight * 0.5);
    
    // Traffic animation
    if (link.traffic > 0) {
      mat.color.setHex(0x00ff88);
      mat.opacity = Math.min(1, mat.opacity + link.traffic * 0.5);
    }
    
    linkGroup.add(new THREE.Line(geo, mat));
  });
}

// === Nodes ===
const nodeGroup = new THREE.Group();
scene.add(nodeGroup);

const groupColors = [0x00d4ff, 0x00ff88, 0xff6644, 0xaa88ff];

function updateNodes() {
  // Clear old
  while (nodeGroup.children.length) {
    nodeGroup.remove(nodeGroup.children[0]);
  }
  
  // Draw new
  nodes.forEach(node => {
    const size = node.size * lerp(0.8, 1.5, state.energy);
    const pulse = 0.8 + 0.2 * Math.sin(node.pulse);
    const flicker = 1 - state.entropy * 0.3 * Math.random();
    
    // Outer ring
    const ringGeo = new THREE.RingGeometry(size * 0.8, size, 24);
    const ringMat = new THREE.MeshBasicMaterial({
      color: groupColors[node.group],
      transparent: true,
      opacity: 0.6 * pulse * flicker
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.set(node.x, node.y, 0);
    nodeGroup.add(ring);
    
    // Core
    const coreGeo = new THREE.CircleGeometry(size * 0.4, 16);
    const coreMat = new THREE.MeshBasicMaterial({
      color: groupColors[node.group],
      transparent: true,
      opacity: 0.9 * pulse * flicker
    });
    const core = new THREE.Mesh(coreGeo, coreMat);
    core.position.set(node.x, node.y, 0.01);
    nodeGroup.add(core);
    
    // Glow
    const glowGeo = new THREE.CircleGeometry(size * 1.5, 24);
    const glowMat = new THREE.MeshBasicMaterial({
      color: groupColors[node.group],
      transparent: true,
      opacity: 0.15 * state.energy * pulse
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    glow.position.set(node.x, node.y, -0.01);
    nodeGroup.add(glow);
  });
}

// === Heat Overlay ===
const heatGeo = new THREE.PlaneGeometry(4, 3);
const heatMat = new THREE.ShaderMaterial({
  uniforms: {
    u_time: { value: 0 },
    u_pressure: { value: 0 },
    u_color1: { value: new THREE.Color(0x001a33) },
    u_color2: { value: new THREE.Color(0xff4444) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float u_time;
    uniform float u_pressure;
    uniform vec3 u_color1;
    uniform vec3 u_color2;
    varying vec2 vUv;
    
    float noise(vec2 p) {
      return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
    }
    
    void main() {
      float n = noise(vUv * 10.0 + u_time * 0.1);
      float heat = u_pressure * (0.5 + 0.5 * sin(vUv.x * 3.14159 + u_time * 0.5));
      heat *= (0.5 + 0.5 * sin(vUv.y * 3.14159));
      heat *= 0.5 + n * 0.2;
      
      vec3 col = mix(u_color1, u_color2, heat);
      gl_FragColor = vec4(col, heat * 0.3);
    }
  `,
  transparent: true
});
const heat = new THREE.Mesh(heatGeo, heatMat);
heat.position.z = -0.1;
scene.add(heat);

// === Traffic Particles ===
const particleCount = 100;
const particleGeo = new THREE.BufferGeometry();
const particlePositions = new Float32Array(particleCount * 3);
const particleSpeeds = [];

for (let i = 0; i < particleCount; i++) {
  particlePositions[i*3] = (Math.random() - 0.5) * 2;
  particlePositions[i*3+1] = (Math.random() - 0.5) * 1.5;
  particlePositions[i*3+2] = 0.02;
  particleSpeeds.push({
    vx: (Math.random() - 0.5) * 0.01,
    vy: (Math.random() - 0.5) * 0.01
  });
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
const particles = new THREE.Points(particleGeo, new THREE.PointsMaterial({
  color: 0x00ff88,
  size: 3,
  transparent: true,
  opacity: 0.6,
  sizeAttenuation: false
}));
scene.add(particles);

// === Animation ===
let startTime = Date.now();

function animate() {
  requestAnimationFrame(animate);
  
  const t = (Date.now() - startTime) / 1000;
  
  // Update node physics
  nodes.forEach(node => {
    node.pulse += 0.05 + state.flow * 0.1;
    
    // Drift
    node.x += node.vx * lerp(0.5, 2, state.entropy);
    node.y += node.vy * lerp(0.5, 2, state.entropy);
    
    // Boundary
    if (Math.abs(node.x) > 0.9) node.vx *= -1;
    if (Math.abs(node.y) > 0.65) node.vy *= -1;
  });
  
  // Update link traffic
  links.forEach(link => {
    if (Math.random() < state.flow * 0.1) {
      link.traffic = 1;
    }
    link.traffic *= 0.95;
  });
  
  // Update particles
  const pos = particles.geometry.attributes.position.array;
  for (let i = 0; i < particleCount; i++) {
    pos[i*3] += particleSpeeds[i].vx * state.flow;
    pos[i*3+1] += particleSpeeds[i].vy * state.flow;
    
    if (Math.abs(pos[i*3]) > 1) particleSpeeds[i].vx *= -1;
    if (Math.abs(pos[i*3+1]) > 0.75) particleSpeeds[i].vy *= -1;
  }
  particles.geometry.attributes.position.needsUpdate = true;
  particles.material.opacity = lerp(0.2, 0.8, state.flow);
  
  // Update heat
  heatMat.uniforms.u_time.value = t;
  heatMat.uniforms.u_pressure.value = state.pressure;
  
  // Update grid opacity
  gridGroup.children.forEach(c => {
    if (c.material) c.material.opacity = lerp(0.05, 0.15, state.energy);
  });
  
  // Alert
  if (state.risk > 0.7) {
    document.body.classList.add('alert-active');
  } else {
    document.body.classList.remove('alert-active');
  }
  
  updateNodes();
  updateLinks();
  
  // UI
  document.getElementById('v-flow').textContent = state.flow.toFixed(2);
  document.getElementById('v-energy').textContent = state.energy.toFixed(2);
  document.getElementById('v-ent').textContent = state.entropy.toFixed(2);
  document.getElementById('v-nodes').textContent = nodes.length;
  document.getElementById('v-links').textContent = links.length;
  document.getElementById('v-traffic').textContent = links.filter(l => l.traffic > 0.1).length;
  
  renderer.render(scene, camera);
}

// Resize
window.addEventListener('resize', () => {
  const aspect = window.innerWidth / window.innerHeight;
  camera.left = -aspect;
  camera.right = aspect;
  camera.top = 0.75;
  camera.bottom = -0.75;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Fetch real state
async function fetchState() {
  try {
    const r = await fetch('/status');
    const s = await r.json();
    state.entropy = s.signals.entropy;
    state.pressure = s.signals.pressure;
    state.energy = s.signals.gravity;
    state.flow = s.signals.release;
    state.risk = Math.min(1, s.signals.entropy * 1.5 + s.signals.pressure * 0.5);
  } catch(e) {}
}

// Init
initNetwork();
fetchState();
setInterval(fetchState, 3000);
animate();
  </script>
</body>
</html>
