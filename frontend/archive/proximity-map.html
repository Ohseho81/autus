<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0c">
  <title>AUTUS Proximity Map v1.0</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0c;
      color: #b4b4aa;
      font-family: 'JetBrains Mono', 'SF Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      padding-top: calc(24px + env(safe-area-inset-top, 0px));
      padding-bottom: calc(24px + env(safe-area-inset-bottom, 0px));
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      border: 1px solid rgba(180, 180, 170, 0.1);
      border-radius: 2px;
      cursor: grab;
      touch-action: none;
      max-width: 100%;
      max-height: 60vh;
    }

    .zoom-hint {
      margin-top: 16px;
      font-size: 9px;
      letter-spacing: 0.15em;
      color: rgba(180, 180, 170, 0.4);
      text-align: center;
    }

    .controls {
      margin-top: 24px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .controls button {
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(180, 180, 170, 0.15);
      color: #b4b4aa;
      font-family: inherit;
      font-size: 11px;
      letter-spacing: 0.1em;
      cursor: pointer;
      border-radius: 2px;
      transition: all 0.15s ease;
    }

    .controls button:hover,
    .controls button:active {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(180, 180, 170, 0.3);
    }

    .controls button.selected {
      background: rgba(180, 180, 170, 0.1);
      border-color: rgba(180, 180, 170, 0.5);
    }

    .equation {
      margin-top: 24px;
      font-size: 9px;
      letter-spacing: 0.1em;
      color: rgba(180, 180, 170, 0.25);
    }

    .version {
      position: fixed;
      bottom: calc(12px + env(safe-area-inset-bottom, 0px));
      right: 16px;
      font-size: 7px;
      letter-spacing: 0.15em;
      color: rgba(180, 180, 170, 0.15);
    }

    .node-count {
      position: fixed;
      bottom: calc(12px + env(safe-area-inset-bottom, 0px));
      left: 16px;
      font-size: 8px;
      letter-spacing: 0.1em;
      color: rgba(180, 180, 170, 0.3);
    }

    .back-btn {
      position: fixed;
      top: calc(16px + env(safe-area-inset-top, 0px));
      left: 16px;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(180, 180, 170, 0.15);
      border-radius: 2px;
      color: #b4b4aa;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      z-index: 100;
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Mobile optimizations */
    @media (max-width: 600px) {
      body {
        padding: 16px;
      }
      
      canvas {
        max-height: 50vh;
      }
      
      .controls button {
        padding: 10px 16px;
        font-size: 10px;
      }
      
      .zoom-hint {
        font-size: 8px;
      }
    }
  </style>
</head>
<body>
  <a href="autus-mobile-app.html" class="back-btn">‹</a>
  
  <canvas id="proximity-map" width="500" height="500"></canvas>
  
  <div class="zoom-hint">
    PINCH / SCROLL TO ZOOM<br>
    L1 &lt; 80 · L2 &lt; 140 · L3 &lt; 200
  </div>

  <div class="controls">
    <button data-vector="-1">Δv = −1</button>
    <button data-vector="0" class="selected">Δv = 0</button>
    <button data-vector="1">Δv = +1</button>
  </div>

  <div class="equation">S(t+1) = S(t) + ρ·Δv − μ·|v|</div>

  <div class="node-count" id="node-count">NODES: 0</div>
  <div class="version">PROXIMITY MAP v1.0 / SN</div>

  <script>
    /**
     * AUTUS Proximity Map v1.0
     * Semantic Neutrality Compliant
     * 
     * Node = 사람/기업/국가 (no labels, size = mass)
     * Motion = 돈/시간/가치 (always toward Origin)
     * Proximity = distance from Origin
     */

    class ProximityMap {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        // Responsive canvas size
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        
        this.origin = { x: this.width / 2, y: this.height / 2 };
        
        this.zoom = 1;
        this.state = { delta: 0.68, mu: 0.23, rho: 0.81 };
        
        this.colors = {
          primary: 'rgba(180, 180, 170, 0.9)',
          secondary: 'rgba(180, 180, 170, 0.5)',
          dim: 'rgba(180, 180, 170, 0.25)',
          faint: 'rgba(180, 180, 170, 0.08)',
        };

        this.nodes = this.generateNodes();
        this.motions = this.generateMotions();
        
        this.setupEvents();
      }

      resizeCanvas() {
        const maxWidth = Math.min(500, window.innerWidth - 48);
        const maxHeight = Math.min(500, window.innerHeight * 0.55);
        const size = Math.min(maxWidth, maxHeight);
        
        this.canvas.width = size;
        this.canvas.height = size;
        this.width = size;
        this.height = size;
        this.origin = { x: size / 2, y: size / 2 };
      }

      generateNodes() {
        const nodes = [];
        
        // L1: r < 80 (close entities - 사람/기업/국가)
        for (let i = 0; i < 5; i++) {
          nodes.push({
            level: 1,
            angle: (i * Math.PI * 2) / 5 + Math.random() * 0.3,
            r: 50 + Math.random() * 25,
            mass: 1.5 + Math.random() * 1.5,
            velocity: 0.008 + Math.random() * 0.004,
          });
        }
        
        // L2: r < 140 (mid-range entities)
        for (let i = 0; i < 8; i++) {
          nodes.push({
            level: 2,
            angle: (i * Math.PI * 2) / 8 + Math.random() * 0.2,
            r: 90 + Math.random() * 40,
            mass: 0.8 + Math.random() * 1.0,
            velocity: 0.005 + Math.random() * 0.003,
          });
        }
        
        // L3: r < 200 (distant entities)
        for (let i = 0; i < 12; i++) {
          nodes.push({
            level: 3,
            angle: (i * Math.PI * 2) / 12 + Math.random() * 0.15,
            r: 150 + Math.random() * 45,
            mass: 0.3 + Math.random() * 0.6,
            velocity: 0.003 + Math.random() * 0.002,
          });
        }
        
        return nodes;
      }

      generateMotions() {
        // Motions = 돈/시간/가치 flowing toward Origin
        return Array.from({ length: 24 }, () => ({
          angle: Math.random() * Math.PI * 2,
          progress: Math.random(),
          intensity: 0.3 + Math.random() * 0.7,
          startR: 80 + Math.random() * 140,
        }));
      }

      setupEvents() {
        // Mouse wheel zoom
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          this.zoom = Math.max(0.5, Math.min(2.5, this.zoom + delta));
        }, { passive: false });

        // Touch pinch zoom
        let initialDistance = 0;
        let initialZoom = 1;

        this.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 2) {
            initialDistance = Math.hypot(
              e.touches[0].clientX - e.touches[1].clientX,
              e.touches[0].clientY - e.touches[1].clientY
            );
            initialZoom = this.zoom;
          }
        }, { passive: true });

        this.canvas.addEventListener('touchmove', (e) => {
          if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = Math.hypot(
              e.touches[0].clientX - e.touches[1].clientX,
              e.touches[0].clientY - e.touches[1].clientY
            );
            const scale = currentDistance / initialDistance;
            this.zoom = Math.max(0.5, Math.min(2.5, initialZoom * scale));
          }
        }, { passive: false });

        // Vector buttons
        document.querySelectorAll('[data-vector]').forEach(btn => {
          btn.addEventListener('click', () => {
            const dv = parseFloat(btn.dataset.vector);
            this.applyVector(dv);
            
            // Update button states
            document.querySelectorAll('[data-vector]').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(10);
          });
        });
      }

      applyVector(dv) {
        this.state.rho = Math.max(0, Math.min(1, this.state.rho + dv * 0.1));
        this.state.delta = Math.max(0, Math.min(1, 
          this.state.delta - this.state.rho * 0.01 + this.state.mu * 0.005
        ));
      }

      update() {
        const scale = Math.min(this.width, this.height) / 500;
        
        // Update motions (toward Origin)
        this.motions.forEach(m => {
          m.progress += 0.004 * m.intensity * this.state.rho;
          if (m.progress >= 1) {
            m.progress = 0;
            m.angle = Math.random() * Math.PI * 2;
            m.startR = (80 + Math.random() * 140) * scale;
          }
        });

        // Update node orbits
        this.nodes.forEach(node => {
          node.angle += node.velocity * this.state.rho;
        });
      }

      draw() {
        const { ctx, origin, zoom, colors, width, height } = this;
        const scale = Math.min(width, height) / 500;
        
        ctx.clearRect(0, 0, width, height);

        // Apply zoom
        ctx.save();
        ctx.translate(origin.x, origin.y);
        ctx.scale(zoom, zoom);
        ctx.translate(-origin.x, -origin.y);

        // Grid
        this.drawGrid();

        // Proximity rings
        [80, 140, 200].map(r => r * scale).forEach((r, i) => {
          ctx.beginPath();
          ctx.arc(origin.x, origin.y, r, 0, Math.PI * 2);
          ctx.strokeStyle = colors.faint;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          ctx.stroke();
          ctx.setLineDash([]);

          if (zoom > 0.7) {
            ctx.font = `${8 * scale}px monospace`;
            ctx.fillStyle = colors.dim;
            ctx.textAlign = 'center';
            ctx.fillText(`${[80, 140, 200][i]}`, origin.x, origin.y - r - 6 * scale);
          }
        });

        // Draw motions (돈/시간/가치 → Origin)
        this.motions.forEach(m => {
          const startR = m.startR * scale;
          const currentR = startR * (1 - m.progress);
          const x = origin.x + Math.cos(m.angle) * currentR;
          const y = origin.y + Math.sin(m.angle) * currentR;
          const startX = origin.x + Math.cos(m.angle) * startR;
          const startY = origin.y + Math.sin(m.angle) * startR;

          // Trail
          const gradient = ctx.createLinearGradient(startX, startY, x, y);
          gradient.addColorStop(0, 'rgba(180, 180, 170, 0)');
          gradient.addColorStop(1, `rgba(180, 180, 170, ${0.1 + m.progress * 0.2})`);

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 0.5;
          ctx.stroke();

          // Particle
          const size = (1 + m.intensity * 2) * scale;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 180, 170, ${0.2 + m.progress * 0.5})`;
          ctx.fill();
        });

        // Draw nodes (사람/기업/국가 - no labels, no connections)
        let visibleCount = 0;
        this.nodes.forEach(node => {
          // Visibility threshold based on zoom
          const threshold = { 1: 0.5, 2: 0.8, 3: 1.2 };
          if (zoom < threshold[node.level]) return;

          visibleCount++;
          const x = origin.x + Math.cos(node.angle) * node.r * scale;
          const y = origin.y + Math.sin(node.angle) * node.r * scale;
          const size = (2 + node.mass * 4) * scale;
          const opacity = 1 - (node.level - 1) * 0.25;

          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 180, 170, ${opacity * 0.8})`;
          ctx.fill();
        });

        // Update node count display
        document.getElementById('node-count').textContent = 
          `NODES: ${visibleCount} / ${this.nodes.length}`;

        // Origin marker
        this.drawOrigin(scale);

        ctx.restore();

        // State readout (not affected by zoom)
        this.drawState();
      }

      drawGrid() {
        const { ctx, width, height, colors } = this;
        const gridSize = 40;

        ctx.strokeStyle = colors.faint;
        ctx.lineWidth = 0.5;

        for (let x = 0; x <= width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y <= height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      drawOrigin(scale = 1) {
        const { ctx, origin, colors } = this;

        // Crosshair
        ctx.strokeStyle = colors.secondary;
        ctx.lineWidth = 1;
        
        const offset = 12 * scale;
        [-1, 1].forEach(dir => {
          ctx.beginPath();
          ctx.moveTo(origin.x + offset * dir, origin.y);
          ctx.lineTo(origin.x + offset * 0.4 * dir, origin.y);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y + offset * dir);
          ctx.lineTo(origin.x, origin.y + offset * 0.4 * dir);
          ctx.stroke();
        });

        // Ring
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 14 * scale, 0, Math.PI * 2);
        ctx.strokeStyle = colors.primary;
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Center
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 3 * scale, 0, Math.PI * 2);
        ctx.fillStyle = colors.primary;
        ctx.fill();

        // Label
        ctx.font = `${8 * scale}px monospace`;
        ctx.fillStyle = colors.secondary;
        ctx.textAlign = 'center';
        ctx.fillText('ORIGIN', origin.x, origin.y + 28 * scale);
      }

      drawState() {
        const { ctx, state, zoom, colors, width } = this;
        const scale = Math.min(width, this.height) / 500;
        const x = 16;
        let y = 24;

        ctx.font = `${10 * scale}px monospace`;
        ctx.textAlign = 'left';
        ctx.fillStyle = colors.secondary;

        [
          `Δ  ${state.delta.toFixed(2)}`,
          `μ  ${state.mu.toFixed(2)}`,
          `ρ  ${state.rho.toFixed(2)}`,
          `×  ${zoom.toFixed(1)}`,
        ].forEach(text => {
          ctx.fillText(text, x, y);
          y += 14 * scale;
        });
      }

      render() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.render());
      }
    }

    // Initialize
    const map = new ProximityMap('proximity-map');
    map.render();
    window.proximityMap = map;
  </script>
</body>
</html>
