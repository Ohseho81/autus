<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUTUS Route Navigation - L0~L2 Network</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #070910;
      color: #b4b4aa;
      font-family: 'JetBrains Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .container {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 4px;
    }

    .title {
      font-size: 10px;
      font-weight: 500;
      color: rgba(180, 180, 170, 0.4);
      letter-spacing: 0.2em;
    }

    .resetBtn {
      padding: 6px 12px;
      background: rgba(180, 180, 170, 0.06);
      border: 1px solid rgba(180, 180, 170, 0.12);
      color: rgba(180, 180, 170, 0.6);
      font-family: inherit;
      font-size: 9px;
      letter-spacing: 0.1em;
      border-radius: 4px;
      cursor: pointer;
    }

    .resetBtn:hover {
      background: rgba(180, 180, 170, 0.1);
    }

    .mapWrap {
      border-radius: 12px;
      background: rgba(180, 180, 170, 0.02);
      padding: 10px;
    }

    canvas {
      border-radius: 8px;
      display: block;
      width: 100%;
    }

    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      font-size: 9px;
      color: rgba(180, 180, 170, 0.4);
    }

    .legendItem {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legendDot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .legendDot.l0 { background: rgba(180, 180, 170, 0.8); }
    .legendDot.l1 { background: rgba(180, 180, 170, 0.6); }
    .legendDot.l2 { background: rgba(180, 180, 170, 0.4); }

    .legendHatch {
      width: 16px;
      height: 8px;
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 2px,
        rgba(180, 180, 170, 0.2) 2px,
        rgba(180, 180, 170, 0.2) 4px
      );
    }

    .infoPanel {
      padding: 12px;
      background: rgba(180, 180, 170, 0.03);
      border: 1px solid rgba(180, 180, 170, 0.06);
      border-radius: 8px;
    }

    .infoRow {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      margin-bottom: 6px;
    }

    .infoRow:last-child { margin-bottom: 0; }

    .infoLabel {
      color: rgba(180, 180, 170, 0.4);
    }

    .infoValue {
      color: rgba(180, 180, 170, 0.7);
      font-variant-numeric: tabular-nums;
    }

    .routePath {
      font-size: 11px;
      color: rgba(180, 180, 170, 0.5);
      text-align: center;
      padding: 8px;
      background: rgba(180, 180, 170, 0.04);
      border-radius: 4px;
      letter-spacing: 0.05em;
    }

    .version {
      margin-top: 12px;
      font-size: 8px;
      letter-spacing: 0.15em;
      color: rgba(180, 180, 170, 0.15);
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">ROUTE NAV</div>
      <button class="resetBtn" id="resetBtn">RESET</button>
    </div>

    <div class="mapWrap">
      <canvas id="routeMap" width="400" height="400"></canvas>
    </div>

    <div class="legend">
      <div class="legendItem">
        <div class="legendDot l0"></div>
        <span>L0</span>
      </div>
      <div class="legendItem">
        <div class="legendDot l1"></div>
        <span>L1</span>
      </div>
      <div class="legendItem">
        <div class="legendDot l2"></div>
        <span>L2</span>
      </div>
      <div class="legendItem">
        <div class="legendHatch"></div>
        <span>Shadow</span>
      </div>
    </div>

    <div class="routePath" id="routePath">L0 → ... → ...</div>

    <div class="infoPanel">
      <div class="infoRow">
        <span class="infoLabel">L1 Stations</span>
        <span class="infoValue" id="l1Count">0</span>
      </div>
      <div class="infoRow">
        <span class="infoLabel">L2 Stations</span>
        <span class="infoValue" id="l2Count">0</span>
      </div>
      <div class="infoRow">
        <span class="infoLabel">Lines</span>
        <span class="infoValue" id="lineCount">0</span>
      </div>
      <div class="infoRow">
        <span class="infoLabel">Shadow Fields</span>
        <span class="infoValue" id="shadowCount">0</span>
      </div>
      <div class="infoRow">
        <span class="infoLabel">L3 Density</span>
        <span class="infoValue" id="l3Density">0.00</span>
      </div>
    </div>

    <div class="version">ROUTE NAV v1.0 / SN</div>
  </div>

  <script>
    /**
     * AUTUS Route Navigation Engine
     * Semantic Neutrality Compliant
     * 
     * L0 = Self (center)
     * L1 = Primary decision points
     * L2 = Secondary points
     * L3 = Background field
     * Shadow Field = Risk zone (hatch pattern only)
     */

    class RouteNavEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.center = { x: this.width / 2, y: this.height / 2 };
        
        this.stations = [];
        this.lines = [];
        this.shadowFields = [];
        this.activeRoute = [];
        this.l3Density = 0.3;
        
        this.t = 0;
        this.hatchPattern = this.createHatchPattern();
        
        this.initNetwork();
      }

      createHatchPattern() {
        const size = 8;
        const offscreen = document.createElement('canvas');
        offscreen.width = size;
        offscreen.height = size;
        const ctx = offscreen.getContext('2d');
        
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.18)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, size);
        ctx.lineTo(size, 0);
        ctx.stroke();
        
        return this.ctx.createPattern(offscreen, 'repeat');
      }

      initNetwork() {
        this.stations = [];
        this.lines = [];
        this.shadowFields = [];
        
        // L0 = Self
        this.stations.push({
          id: 'L0', layer: 0,
          x: 0, y: 0,
          mass: 2.0, shadowIntensity: 0
        });
        
        // L1 Stations (5)
        const l1Count = 5;
        for (let i = 0; i < l1Count; i++) {
          const angle = (i / l1Count) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
          const r = 0.25 + Math.random() * 0.1;
          const shadowIntensity = Math.random() * 0.5;
          
          const station = {
            id: `L1_${i}`, layer: 1,
            x: Math.cos(angle) * r,
            y: Math.sin(angle) * r,
            mass: 1.0 + Math.random() * 1.0,
            shadowIntensity,
            parentId: 'L0'
          };
          this.stations.push(station);
          
          this.lines.push({
            id: `line_L0_L1_${i}`,
            from: 'L0', to: `L1_${i}`,
            flowRate: 0.4 + Math.random() * 0.4,
            delay: Math.random() * 0.4
          });
          
          if (shadowIntensity > 0.15) {
            this.shadowFields.push({
              stationId: station.id,
              radius: 35 + shadowIntensity * 50,
              intensity: shadowIntensity
            });
          }
        }
        
        // L2 Stations (10)
        const l1Stations = this.stations.filter(s => s.layer === 1);
        const l2Count = 10;
        
        for (let i = 0; i < l2Count; i++) {
          const parent = l1Stations[i % l1Stations.length];
          const offsetAngle = Math.random() * Math.PI * 2;
          const offsetR = 0.14 + Math.random() * 0.1;
          const shadowIntensity = Math.random() * 0.7;
          
          const station = {
            id: `L2_${i}`, layer: 2,
            x: parent.x + Math.cos(offsetAngle) * offsetR,
            y: parent.y + Math.sin(offsetAngle) * offsetR,
            mass: 0.4 + Math.random() * 0.6,
            shadowIntensity,
            parentId: parent.id
          };
          this.stations.push(station);
          
          this.lines.push({
            id: `line_${parent.id}_L2_${i}`,
            from: parent.id, to: `L2_${i}`,
            flowRate: 0.3 + Math.random() * 0.4,
            delay: Math.random() * 0.5
          });
          
          if (shadowIntensity > 0.2) {
            this.shadowFields.push({
              stationId: station.id,
              radius: 25 + shadowIntensity * 35,
              intensity: shadowIntensity
            });
          }
        }
        
        // Set active route
        const randomL1 = l1Stations[Math.floor(Math.random() * l1Stations.length)];
        const l2Children = this.stations.filter(s => s.layer === 2 && s.parentId === randomL1.id);
        const randomL2 = l2Children.length > 0 ? l2Children[Math.floor(Math.random() * l2Children.length)] : null;
        
        this.activeRoute = ['L0', randomL1.id];
        if (randomL2) this.activeRoute.push(randomL2.id);
        
        this.l3Density = 0.25 + Math.random() * 0.2;
        
        this.updateInfo();
      }

      getStation(id) {
        return this.stations.find(s => s.id === id);
      }

      toCanvas(p) {
        const scale = 0.38;
        return {
          x: (p.x * scale + 0.5) * this.width,
          y: (p.y * scale + 0.5) * this.height
        };
      }

      update() {
        this.t += 1;
      }

      draw() {
        const { ctx, width, height, center } = this;
        
        ctx.clearRect(0, 0, width, height);
        
        // Background
        ctx.fillStyle = '#08090d';
        ctx.fillRect(0, 0, width, height);
        
        // L3 Field
        this.drawL3Field();
        
        // Shadow Fields (hatch pattern)
        this.shadowFields.forEach(sf => {
          const station = this.getStation(sf.stationId);
          if (station) this.drawShadowField(station, sf);
        });
        
        // Lines
        this.lines.forEach(line => {
          const from = this.getStation(line.from);
          const to = this.getStation(line.to);
          if (from && to) {
            const isActive = this.activeRoute.includes(line.from) && this.activeRoute.includes(line.to);
            this.drawLine(from, to, line, isActive);
          }
        });
        
        // L2 Stations
        this.stations.filter(s => s.layer === 2).forEach(s => {
          this.drawStation(s, this.activeRoute.includes(s.id));
        });
        
        // L1 Stations
        this.stations.filter(s => s.layer === 1).forEach(s => {
          this.drawStation(s, this.activeRoute.includes(s.id));
        });
        
        // L0 (Self)
        this.drawSelf();
      }

      drawL3Field() {
        const { ctx, width, height, l3Density, t } = this;
        const count = Math.floor(l3Density * 80);
        
        ctx.fillStyle = 'rgba(180, 180, 170, 0.025)';
        
        for (let i = 0; i < count; i++) {
          const seed = i * 1000;
          const x = ((Math.sin(seed + t * 0.008) + 1) / 2) * width;
          const y = ((Math.cos(seed * 1.3 + t * 0.006) + 1) / 2) * height;
          const size = 1 + Math.sin(seed * 0.7) + 1;
          
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawShadowField(station, sf) {
        const { ctx, hatchPattern } = this;
        const pos = this.toCanvas(station);
        const radius = sf.radius * (this.width / 400);
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        
        if (hatchPattern) {
          ctx.fillStyle = hatchPattern;
          ctx.globalAlpha = sf.intensity * 0.5;
          ctx.fill();
        }
        
        ctx.strokeStyle = `rgba(180, 180, 170, ${sf.intensity * 0.15})`;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.restore();
      }

      drawLine(from, to, line, isActive) {
        const { ctx, t } = this;
        const p1 = this.toCanvas(from);
        const p2 = this.toCanvas(to);
        
        const alpha = isActive ? 0.35 : 0.1;
        ctx.strokeStyle = `rgba(180, 180, 170, ${alpha})`;
        ctx.lineWidth = isActive ? 2 : 1;
        
        if (line.delay > 0.3) {
          ctx.setLineDash([5, 5 * line.delay]);
        }
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Flow particle
        if (line.flowRate > 0.2) {
          const progress = ((t * line.flowRate * 0.015) % 1);
          const px = p1.x + (p2.x - p1.x) * progress;
          const py = p1.y + (p2.y - p1.y) * progress;
          
          ctx.beginPath();
          ctx.arc(px, py, 2 + line.flowRate * 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 180, 170, ${0.15 + line.flowRate * 0.25})`;
          ctx.fill();
        }
      }

      drawStation(station, isActive) {
        const { ctx } = this;
        const pos = this.toCanvas(station);
        const size = 3 + station.mass * 4;
        
        const layerAlpha = station.layer === 1 ? 0.65 : 0.45;
        const alpha = isActive ? layerAlpha + 0.2 : layerAlpha;
        
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(180, 180, 170, ${alpha})`;
        ctx.fill();
        
        if (isActive) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, size + 5, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(180, 180, 170, 0.25)';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      }

      drawSelf() {
        const { ctx, t } = this;
        const pos = this.toCanvas({ x: 0, y: 0 });
        
        // Pulse ring
        const pulseSize = 18 + Math.sin(t * 0.04) * 3;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, pulseSize, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Inner ring
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 11, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.55)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Core
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180, 180, 170, 0.8)';
        ctx.fill();
        
        // Crosshair
        ctx.strokeStyle = 'rgba(180, 180, 170, 0.2)';
        ctx.lineWidth = 1;
        
        [-1, 1].forEach(dir => {
          ctx.beginPath();
          ctx.moveTo(pos.x + dir * 20, pos.y);
          ctx.lineTo(pos.x + dir * 28, pos.y);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y + dir * 20);
          ctx.lineTo(pos.x, pos.y + dir * 28);
          ctx.stroke();
        });
      }

      updateInfo() {
        document.getElementById('l1Count').textContent = this.stations.filter(s => s.layer === 1).length;
        document.getElementById('l2Count').textContent = this.stations.filter(s => s.layer === 2).length;
        document.getElementById('lineCount').textContent = this.lines.length;
        document.getElementById('shadowCount').textContent = this.shadowFields.length;
        document.getElementById('l3Density').textContent = this.l3Density.toFixed(2);
        document.getElementById('routePath').textContent = this.activeRoute.join(' → ');
      }

      render() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.render());
      }
    }

    // Initialize
    const engine = new RouteNavEngine(document.getElementById('routeMap'));
    engine.render();

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', () => {
      engine.initNetwork();
    });

    window.routeEngine = engine;
  </script>
</body>
</html>
