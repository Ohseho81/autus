<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AUTUS ATLAS</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; font-family: 'Inter', sans-serif; font-weight: 300; overflow: hidden; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        .ui-layer { position: fixed; z-index: 10; pointer-events: none; }
        .ui-layer > * { pointer-events: auto; }
        .text-dim { color: rgba(255,255,255,0.4); }
        .text-bright { color: rgba(255,255,255,0.9); }
        .slot-bar { height: 2px; background: rgba(255,255,255,0.08); border-radius: 1px; overflow: hidden; }
        .slot-fill { height: 100%; transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1); }
        button { background: transparent; border: 1px solid rgba(255,255,255,0.15); color: rgba(255,255,255,0.7); padding: 8px 16px; border-radius: 4px; font-family: inherit; font-size: 11px; cursor: pointer; transition: all 0.3s; }
        button:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.3); color: #fff; }
        .status-stable { color: #00ff88; text-shadow: 0 0 20px rgba(0,255,136,0.3); }
        .status-warning { color: #ffaa00; text-shadow: 0 0 20px rgba(255,170,0,0.4); }
        .status-unstable { color: #ff6644; text-shadow: 0 0 25px rgba(255,102,68,0.5); }
        .status-collapsed { color: #ff2244; text-shadow: 0 0 30px rgba(255,34,68,0.6); animation: pulse-red 0.5s infinite; }
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .entropy-critical { color: #ff4466; }
        .entropy-warning { color: #ffaa44; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>
    
    <script type="text/babel">
        const API = "https://solar.autus-ai.com";
        
        const LERP_ALPHA = 0.06;
        
        class DeepSpaceRenderer {
            constructor(container) {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 1);
                container.appendChild(this.renderer.domElement);
                
                this.camera.position.set(0, 8, 16);
                this.camera.lookAt(0, 0, 0);
                
                this.orbitGroups = [];
                this.time = 0;
                
                // State
                this.orbitStatus = 'STABLE';
                this.entropy = 0;
                this.gravity = 0.3;
                this.targetOrbitRadius = 1.7;
                this.shownOrbitRadius = 1.7;
                this.collapseShake = 0;
                
                this.createDeepSpace();
                this.animate();
                
                window.addEventListener('resize', () => this.onResize());
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            createDeepSpace() {
                this.scene.add(new THREE.AmbientLight(0x111122, 0.5));
                this.sunLight = new THREE.PointLight(0x00d4ff, 2, 50);
                this.scene.add(this.sunLight);
                
                // Sun
                const sunMat = new THREE.MeshPhysicalMaterial({
                    color: 0x001020, metalness: 0.1, roughness: 0.1,
                    transmission: 0.9, thickness: 2, clearcoat: 1,
                    emissive: 0x003344, emissiveIntensity: 0.5
                });
                this.sun = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), sunMat);
                this.scene.add(this.sun);
                
                // Gravity rings
                this.gravityRings = [];
                for (let i = 0; i < 5; i++) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(1.2 + i * 0.3, 1.25 + i * 0.3, 64),
                        new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.1 - i * 0.015, side: THREE.DoubleSide })
                    );
                    ring.rotation.x = Math.PI / 2;
                    this.gravityRings.push(ring);
                    this.scene.add(ring);
                }
                
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.15 });
                this.sunGlow = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), glowMat);
                this.scene.add(this.sunGlow);
                
                const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
                this.core = new THREE.Mesh(new THREE.SphereGeometry(0.3, 32, 32), coreMat);
                this.scene.add(this.core);
                
                // 7 Orbits
                const orbitData = [
                    { radius: 2.5, color: 0x4488ff },
                    { radius: 3.2, color: 0x44ff88 },
                    { radius: 3.9, color: 0xff4488 },
                    { radius: 4.6, color: 0xffdd44 },
                    { radius: 5.3, color: 0xff8844 },
                    { radius: 6.0, color: 0x8844ff },
                    { radius: 6.7, color: 0xff2244 }
                ];
                
                orbitData.forEach((data, i) => {
                    const group = new THREE.Group();
                    const orbit = new THREE.Mesh(
                        new THREE.TorusGeometry(data.radius, 0.01, 8, 200),
                        new THREE.MeshBasicMaterial({ color: data.color, transparent: true, opacity: 0.15 })
                    );
                    orbit.rotation.x = Math.PI / 2;
                    orbit.userData = { baseRadius: data.radius, index: i, baseColor: data.color };
                    group.add(orbit);
                    group.userData = { orbit, index: i };
                    this.orbitGroups.push(group);
                    this.scene.add(group);
                });
                
                // Planet
                const planetMat = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff, metalness: 0.3, roughness: 0.2, clearcoat: 1
                });
                this.planet = new THREE.Mesh(new THREE.SphereGeometry(0.18, 32, 32), planetMat);
                this.planet.position.x = 4;
                this.planet.userData = { angle: 0, radius: 4 };
                this.scene.add(this.planet);
                
                // Stars
                const starGeo = new THREE.BufferGeometry();
                const positions = [];
                for (let i = 0; i < 800; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 50 + Math.random() * 150;
                    positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }
                starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                this.stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 }));
                this.scene.add(this.stars);
            }
            
            updateFromState(state) {
                if (!state) return;
                
                const orbit = state.orbit || {};
                const entropy = state.entropy || {};
                const gravity = state.gravity || {};
                
                this.orbitStatus = orbit.status || 'STABLE';
                this.entropy = entropy.value || 0;
                this.gravity = gravity.gravity || 0.3;
                this.targetOrbitRadius = orbit.radius || 1.7;
                
                // Color based on status
                const isCollapsed = this.orbitStatus === 'COLLAPSED';
                const isUnstable = this.orbitStatus === 'UNSTABLE';
                const isWarning = this.orbitStatus === 'WARNING';
                
                if (isCollapsed) {
                    this.sunGlow.material.color.setHex(0xff2244);
                    this.core.material.color.setHex(0xff4466);
                    this.sunLight.color.setHex(0xff4466);
                    this.sunGlow.material.opacity = 0.4;
                    this.collapseShake = 0.15;
                } else if (isUnstable) {
                    this.sunGlow.material.color.setHex(0xff6644);
                    this.core.material.color.setHex(0xff8866);
                    this.sunLight.color.setHex(0xff8866);
                    this.sunGlow.material.opacity = 0.3;
                    this.collapseShake = 0.08;
                } else if (isWarning) {
                    this.sunGlow.material.color.setHex(0xffaa00);
                    this.core.material.color.setHex(0xffcc44);
                    this.sunLight.color.setHex(0xffcc44);
                    this.sunGlow.material.opacity = 0.2;
                    this.collapseShake = 0.03;
                } else {
                    this.sunGlow.material.color.setHex(0x00d4ff);
                    this.core.material.color.setHex(0x00ffff);
                    this.sunLight.color.setHex(0x00d4ff);
                    this.sunGlow.material.opacity = 0.15;
                    this.collapseShake = 0;
                }
                
                // Gravity rings
                this.gravityRings.forEach((ring, i) => {
                    const scale = 1 + (1 - this.gravity) * 0.5 + this.entropy * 0.2;
                    ring.scale.setScalar(scale);
                    ring.material.opacity = Math.max(0.02, 0.08 - this.entropy * 0.02 - i * 0.01);
                    
                    if (isCollapsed || isUnstable) {
                        ring.material.color.setHex(isCollapsed ? 0xff2244 : 0xff6644);
                    } else {
                        ring.material.color.setHex(0x00d4ff);
                    }
                });
                
                // Orbit colors
                const energy = state.energy || {};
                const slots = ['Brain', 'Sensors', 'Heart', 'Core', 'Engines', 'Base', 'Boundary'];
                this.orbitGroups.forEach((group, i) => {
                    const orbit = group.userData.orbit;
                    const value = energy[slots[i]] || 0.5;
                    
                    // Scale based on entropy (orbits expand as entropy increases)
                    const entropyScale = 1 + this.entropy * 0.15;
                    orbit.scale.setScalar(entropyScale);
                    
                    if (isCollapsed) {
                        orbit.material.color.setHex(0xff2244);
                        orbit.material.opacity = 0.3 + Math.sin(this.time * 10 + i) * 0.1;
                    } else if (isUnstable) {
                        orbit.material.color.setHex(0xff6644);
                        orbit.material.opacity = 0.2 + Math.sin(this.time * 5 + i) * 0.05;
                    } else {
                        orbit.material.color.setHex(orbit.userData.baseColor);
                        orbit.material.opacity = 0.1 + value * 0.2;
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.time += 0.016;
                
                // Lerp orbit radius
                this.shownOrbitRadius = THREE.MathUtils.lerp(this.shownOrbitRadius, this.targetOrbitRadius, LERP_ALPHA);
                
                // Sun pulse
                const pulse = 1 + Math.sin(this.time * 0.5) * 0.02;
                this.sunGlow.scale.setScalar(pulse * (0.9 + this.gravity * 0.2));
                
                // Collapse shake
                if (this.collapseShake > 0) {
                    const shake = this.collapseShake;
                    this.sun.position.x = (Math.random() - 0.5) * shake;
                    this.sun.position.y = (Math.random() - 0.5) * shake;
                    this.sunGlow.position.copy(this.sun.position);
                    this.core.position.copy(this.sun.position);
                } else {
                    this.sun.position.set(0, 0, 0);
                    this.sunGlow.position.set(0, 0, 0);
                    this.core.position.set(0, 0, 0);
                }
                
                // Orbit rotation (slower when entropy high)
                const rotationSpeed = Math.max(0.001, 0.01 - this.entropy * 0.003);
                this.orbitGroups.forEach((group, i) => {
                    group.rotation.z += rotationSpeed * (1 + i * 0.08);
                    
                    // Wobble when unstable
                    if (this.orbitStatus === 'UNSTABLE' || this.orbitStatus === 'COLLAPSED') {
                        group.rotation.x = Math.sin(this.time * 2 + i) * 0.1 * this.entropy;
                    } else {
                        group.rotation.x = THREE.MathUtils.lerp(group.rotation.x, 0, 0.05);
                    }
                });
                
                // Planet orbit
                const planetSpeed = Math.max(0.002, 0.01 - this.entropy * 0.003);
                this.planet.userData.angle += planetSpeed;
                this.planet.userData.radius = this.shownOrbitRadius * 2;
                const r = this.planet.userData.radius;
                this.planet.position.x = Math.cos(this.planet.userData.angle) * r;
                this.planet.position.z = Math.sin(this.planet.userData.angle) * r;
                
                // Planet wobble when collapsed
                if (this.orbitStatus === 'COLLAPSED') {
                    this.planet.position.y = Math.sin(this.time * 5) * 0.5;
                }
                
                this.stars.rotation.y += 0.00005;
                this.camera.position.x = Math.sin(this.time * 0.1) * 0.5;
                this.camera.lookAt(0, 0, 0);
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        function App() {
            const [solar, setSolar] = React.useState(null);
            const [showUI, setShowUI] = React.useState(true);
            const rendererRef = React.useRef(null);
            
            React.useEffect(() => {
                rendererRef.current = new DeepSpaceRenderer(document.getElementById('canvas-container'));
                fetchState();
                const interval = setInterval(fetchState, 500);
                return () => clearInterval(interval);
            }, []);
            
            React.useEffect(() => {
                if (rendererRef.current && solar) rendererRef.current.updateFromState(solar);
            }, [solar]);
            
            const fetchState = async () => {
                try {
                    const res = await fetch(`${API}/autus/solar/status`);
                    setSolar(await res.json());
                } catch(e) {}
            };
            
            const runCycle = async () => {
                await fetch(`${API}/autus/solar/tick`, { method: 'POST' });
                fetchState();
            };
            
            const applyEnergy = async (slot, value) => {
                await fetch(`${API}/autus/solar/input`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ slot, value })
                });
                fetchState();
            };
            
            const resetSolar = async () => {
                await fetch(`${API}/autus/solar/reset`, { method: 'POST' });
                fetchState();
            };
            
            const orbit = solar?.orbit || {};
            const entropy = solar?.entropy || {};
            const gravity = solar?.gravity || {};
            const twin = solar?.twin || {};
            const brain = solar?.brain || {};
            
            const statusClass = {
                'STABLE': 'status-stable',
                'WARNING': 'status-warning',
                'UNSTABLE': 'status-unstable',
                'COLLAPSED': 'status-collapsed'
            }[orbit.status] || 'status-stable';
            
            return (
                <>
                    {/* Title */}
                    <div className="ui-layer" style={{top: 32, left: 32, opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{letterSpacing: '0.3em', fontSize: 11, fontWeight: 200}} className="text-dim">AUTUS</div>
                        <div style={{fontSize: 24, fontWeight: 200, marginTop: 4}} className="text-bright">Atlas</div>
                        <div style={{fontSize: 9, marginTop: 8, letterSpacing: '0.1em'}} className="text-dim">PHYSICS v1.3</div>
                    </div>
                    
                    {/* Status */}
                    <div className="ui-layer" style={{top: 32, right: 32, textAlign: 'right', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{fontSize: 11, letterSpacing: '0.2em'}} className="text-dim">CYCLE</div>
                        <div style={{fontSize: 32, fontWeight: 200}} className="text-bright">{solar?.cycle || 0}</div>
                        <div style={{fontSize: 10, marginTop: 4}} className="text-dim">tick {solar?.tick || 0}</div>
                        <div style={{marginTop: 16, fontSize: 13, letterSpacing: '0.15em'}} className={statusClass}>
                            ‚óè {orbit.status || 'STABLE'}
                        </div>
                        {solar?.block_reason && <div style={{fontSize: 10, marginTop: 4}} className="text-dim">{solar.block_reason}</div>}
                    </div>
                    
                    {/* Entropy Panel */}
                    <div className="ui-layer" style={{top: 140, right: 32, textAlign: 'right', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{fontSize: 10, letterSpacing: '0.2em', marginBottom: 8}} className="text-dim">ENTROPY</div>
                        <div style={{fontSize: 28, fontWeight: 200}} className={entropy.value > 1 ? 'entropy-critical' : entropy.value > 0.5 ? 'entropy-warning' : 'text-bright'}>
                            {(entropy.value || 0).toFixed(2)}
                        </div>
                        <div style={{fontSize: 10, marginTop: 8}}>
                            <span className="text-dim">Loss </span>
                            <span className={entropy.loss > 0.05 ? 'entropy-warning' : 'text-bright'}>{(entropy.loss || 0).toFixed(3)}</span>
                        </div>
                        <div style={{fontSize: 10, marginTop: 4}}>
                            <span className="text-dim">G_eff </span>
                            <span className="text-bright">{(entropy.G_eff || 0).toFixed(3)}</span>
                        </div>
                    </div>
                    
                    {/* Gravity Panel */}
                    <div className="ui-layer" style={{top: 280, right: 32, textAlign: 'right', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{fontSize: 10, letterSpacing: '0.2em', marginBottom: 8}} className="text-dim">GRAVITY</div>
                        <div style={{fontSize: 11, marginBottom: 4}}>
                            <span className="text-dim">Talent </span>
                            <span className="text-bright">{((gravity.talent || 0.5) * 100).toFixed(0)}%</span>
                        </div>
                        <div style={{fontSize: 11, marginBottom: 4}}>
                            <span className="text-dim">Effort </span>
                            <span className="text-bright">{(gravity.effort || 0).toFixed(2)}</span>
                        </div>
                        <div style={{fontSize: 11, marginBottom: 4}}>
                            <span className="text-dim">Context </span>
                            <span className="text-bright">{((gravity.context || 0.5) * 100).toFixed(0)}%</span>
                        </div>
                        <div style={{fontSize: 14, marginTop: 8, color: '#00d4ff'}}>
                            G = {(gravity.gravity || 0.3).toFixed(3)}
                        </div>
                    </div>
                    
                    {/* Orbit Panel */}
                    <div className="ui-layer" style={{top: 420, right: 32, textAlign: 'right', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{fontSize: 10, letterSpacing: '0.2em', marginBottom: 8}} className="text-dim">ORBIT</div>
                        <div style={{fontSize: 11}}>
                            <span className="text-dim">Radius </span>
                            <span className="text-bright">{(orbit.radius || 1.7).toFixed(2)}</span>
                        </div>
                    </div>
                    
                    {/* Energy Field */}
                    <div className="ui-layer" style={{top: '50%', left: 32, transform: 'translateY(-50%)', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <div style={{fontSize: 10, letterSpacing: '0.2em', marginBottom: 16}} className="text-dim">ENERGY FIELD</div>
                        {solar?.energy && Object.entries(solar.energy).map(([slot, value]) => (
                            <div key={slot} style={{marginBottom: 12, width: 120}}>
                                <div style={{display: 'flex', justifyContent: 'space-between', fontSize: 10, marginBottom: 4}}>
                                    <span className="text-dim">{slot}</span>
                                    <span className="text-bright">{(value * 100).toFixed(0)}%</span>
                                </div>
                                <div className="slot-bar">
                                    <div className="slot-fill" style={{
                                        width: `${Math.max(0, Math.min(100, value * 100))}%`,
                                        background: slot === 'Core' && value < 0.5 ? '#ff4466' : 
                                                   slot === 'Boundary' && value > 0.5 ? '#ff2244' : 
                                                   'rgba(255,255,255,0.4)'
                                    }}></div>
                                </div>
                            </div>
                        ))}
                    </div>
                    
                    {/* Controls */}
                    <div className="ui-layer" style={{bottom: 32, left: '50%', transform: 'translateX(-50%)', display: 'flex', gap: 8, flexWrap: 'wrap', justifyContent: 'center', opacity: showUI ? 1 : 0, transition: 'opacity 0.5s'}}>
                        <button onClick={runCycle}>CYCLE</button>
                        <button onClick={() => applyEnergy('Brain', 0.9)}>BRAIN</button>
                        <button onClick={() => applyEnergy('Sensors', 0.9)}>SENSORS</button>
                        <button onClick={() => applyEnergy('Boundary', 0.95)} style={{color: '#ff6688'}}>PRESSURE</button>
                        <button onClick={() => applyEnergy('Boundary', 0.0)} style={{color: '#00ff88'}}>RELEASE</button>
                        <button onClick={resetSolar} style={{opacity: 0.5}}>RESET</button>
                    </div>
                    
                    {/* Toggle */}
                    <div className="ui-layer" style={{bottom: 32, right: 32}}>
                        <button onClick={() => setShowUI(!showUI)} style={{opacity: 0.3, fontSize: 10}}>{showUI ? 'HIDE' : 'SHOW'}</button>
                    </div>
                </>
            );
        }
        
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
