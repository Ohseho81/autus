<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AUTUS ATLAS</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; font-family: 'Inter', sans-serif; font-weight: 300; overflow: hidden; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        .ui-layer { position: fixed; z-index: 10; pointer-events: none; }
        .ui-layer > * { pointer-events: auto; }
        .text-dim { color: rgba(255,255,255,0.4); }
        .text-bright { color: rgba(255,255,255,0.9); }
        
        /* Action Feedback */
        .action-log { 
            background: rgba(0,0,0,0.8); 
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 16px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.6;
        }
        .log-entry { margin-bottom: 4px; opacity: 0.8; }
        .log-entry.highlight { opacity: 1; color: #00ff88; }
        .log-entry.warning { color: #ffaa00; }
        .log-entry.danger { color: #ff4466; }
        .log-entry.collapse { color: #ff2244; font-weight: 600; }
        
        /* Big Status */
        .big-status {
            font-size: 48px;
            font-weight: 200;
            letter-spacing: 0.1em;
            transition: all 0.3s;
        }
        .big-status.stable { color: #00ff88; text-shadow: 0 0 30px rgba(0,255,136,0.3); }
        .big-status.warning { color: #ffaa00; text-shadow: 0 0 30px rgba(255,170,0,0.4); }
        .big-status.unstable { color: #ff6644; text-shadow: 0 0 30px rgba(255,102,68,0.5); }
        .big-status.collapsed { color: #ff2244; text-shadow: 0 0 40px rgba(255,34,68,0.6); animation: pulse-danger 0.5s infinite; }
        @keyframes pulse-danger { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* Meters */
        .meter-container { margin-bottom: 16px; }
        .meter-label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 12px; }
        .meter-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .meter-fill { height: 100%; transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); border-radius: 4px; }
        .meter-fill.good { background: linear-gradient(90deg, #00ff88, #00d4ff); }
        .meter-fill.warning { background: linear-gradient(90deg, #ffaa00, #ff6644); }
        .meter-fill.danger { background: linear-gradient(90deg, #ff6644, #ff2244); }
        
        /* Buttons */
        button { 
            background: rgba(255,255,255,0.05); 
            border: 1px solid rgba(255,255,255,0.2); 
            color: rgba(255,255,255,0.8); 
            padding: 12px 24px; 
            border-radius: 6px; 
            font-family: inherit; 
            font-size: 12px; 
            font-weight: 400;
            cursor: pointer; 
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        button:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.4); transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button.primary { border-color: #00d4ff; color: #00d4ff; }
        button.danger { border-color: #ff4466; color: #ff4466; }
        button.success { border-color: #00ff88; color: #00ff88; }
        
        /* Delta indicator */
        .delta { font-size: 10px; margin-left: 4px; }
        .delta.up { color: #00ff88; }
        .delta.down { color: #ff4466; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>
    
    <script type="text/babel">
        const API = "https://solar.autus-ai.com";
        
        class DeepSpaceRenderer {
            constructor(container) {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 1);
                container.appendChild(this.renderer.domElement);
                
                this.camera.position.set(0, 10, 20);
                this.camera.lookAt(0, 0, 0);
                
                this.orbitGroups = [];
                this.time = 0;
                this.entropy = 0;
                this.orbitStatus = 'STABLE';
                this.collapseShake = 0;
                
                this.createScene();
                this.animate();
                window.addEventListener('resize', () => this.onResize());
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            createScene() {
                // Lights
                this.scene.add(new THREE.AmbientLight(0x111133, 0.5));
                this.sunLight = new THREE.PointLight(0x00d4ff, 3, 100);
                this.scene.add(this.sunLight);
                
                // Sun
                this.sun = new THREE.Mesh(
                    new THREE.SphereGeometry(1.5, 64, 64),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x002040, emissive: 0x004488, emissiveIntensity: 0.5,
                        metalness: 0.2, roughness: 0.3, transmission: 0.6
                    })
                );
                this.scene.add(this.sun);
                
                // Glow
                this.glow = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 32, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.15 })
                );
                this.scene.add(this.glow);
                
                // Core
                this.core = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 32, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 })
                );
                this.scene.add(this.core);
                
                // Orbits
                const colors = [0x4488ff, 0x44ff88, 0xff4488, 0xffdd44, 0xff8844, 0x8844ff, 0xff4466];
                for (let i = 0; i < 7; i++) {
                    const group = new THREE.Group();
                    const orbit = new THREE.Mesh(
                        new THREE.TorusGeometry(3 + i * 0.8, 0.02, 8, 200),
                        new THREE.MeshBasicMaterial({ color: colors[i], transparent: true, opacity: 0.2 })
                    );
                    orbit.rotation.x = Math.PI / 2;
                    orbit.userData = { baseRadius: 3 + i * 0.8, color: colors[i] };
                    group.add(orbit);
                    this.orbitGroups.push({ group, orbit });
                    this.scene.add(group);
                }
                
                // Planet
                this.planet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 32, 32),
                    new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.2 })
                );
                this.planet.userData = { angle: 0 };
                this.scene.add(this.planet);
                
                // Stars
                const starGeo = new THREE.BufferGeometry();
                const positions = [];
                for (let i = 0; i < 1000; i++) {
                    positions.push((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400);
                }
                starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                this.stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
                this.scene.add(this.stars);
            }
            
            updateFromState(state) {
                if (!state) return;
                
                this.entropy = state.entropy?.value || 0;
                this.orbitStatus = state.orbit?.status || 'STABLE';
                
                const isCollapsed = this.orbitStatus === 'COLLAPSED';
                const isUnstable = this.orbitStatus === 'UNSTABLE';
                const isWarning = this.orbitStatus === 'WARNING';
                
                // Sun color
                if (isCollapsed) {
                    this.glow.material.color.setHex(0xff2244);
                    this.core.material.color.setHex(0xff4466);
                    this.sunLight.color.setHex(0xff4466);
                    this.sun.material.emissive.setHex(0x440000);
                    this.collapseShake = 0.2;
                } else if (isUnstable) {
                    this.glow.material.color.setHex(0xff6644);
                    this.core.material.color.setHex(0xff8866);
                    this.sunLight.color.setHex(0xff8866);
                    this.sun.material.emissive.setHex(0x442200);
                    this.collapseShake = 0.1;
                } else if (isWarning) {
                    this.glow.material.color.setHex(0xffaa00);
                    this.core.material.color.setHex(0xffcc44);
                    this.sunLight.color.setHex(0xffcc44);
                    this.sun.material.emissive.setHex(0x443300);
                    this.collapseShake = 0.03;
                } else {
                    this.glow.material.color.setHex(0x00d4ff);
                    this.core.material.color.setHex(0x00ffff);
                    this.sunLight.color.setHex(0x00d4ff);
                    this.sun.material.emissive.setHex(0x004488);
                    this.collapseShake = 0;
                }
                
                // Orbit colors
                this.orbitGroups.forEach(({ orbit }, i) => {
                    const scale = 1 + this.entropy * 0.2;
                    orbit.scale.setScalar(scale);
                    
                    if (isCollapsed) {
                        orbit.material.color.setHex(0xff2244);
                        orbit.material.opacity = 0.4;
                    } else if (isUnstable) {
                        orbit.material.color.setHex(0xff6644);
                        orbit.material.opacity = 0.3;
                    } else {
                        orbit.material.color.setHex(orbit.userData.color);
                        orbit.material.opacity = 0.2;
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.time += 0.016;
                
                // Shake
                if (this.collapseShake > 0) {
                    this.sun.position.x = (Math.random() - 0.5) * this.collapseShake;
                    this.sun.position.y = (Math.random() - 0.5) * this.collapseShake;
                    this.glow.position.copy(this.sun.position);
                    this.core.position.copy(this.sun.position);
                } else {
                    this.sun.position.set(0, 0, 0);
                    this.glow.position.set(0, 0, 0);
                    this.core.position.set(0, 0, 0);
                }
                
                // Glow pulse
                this.glow.scale.setScalar(1 + Math.sin(this.time) * 0.05);
                
                // Orbit rotation
                const speed = Math.max(0.002, 0.01 - this.entropy * 0.003);
                this.orbitGroups.forEach(({ group }, i) => {
                    group.rotation.z += speed * (1 + i * 0.1);
                    if (this.orbitStatus === 'COLLAPSED' || this.orbitStatus === 'UNSTABLE') {
                        group.rotation.x = Math.sin(this.time * 2 + i) * this.entropy * 0.1;
                    }
                });
                
                // Planet
                this.planet.userData.angle += speed;
                const r = 5 + this.entropy * 2;
                this.planet.position.x = Math.cos(this.planet.userData.angle) * r;
                this.planet.position.z = Math.sin(this.planet.userData.angle) * r;
                if (this.orbitStatus === 'COLLAPSED') {
                    this.planet.position.y = Math.sin(this.time * 5) * 0.5;
                }
                
                this.stars.rotation.y += 0.0001;
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        function App() {
            const [solar, setSolar] = React.useState(null);
            const [prevSolar, setPrevSolar] = React.useState(null);
            const [actionLog, setActionLog] = React.useState([]);
            const rendererRef = React.useRef(null);
            
            React.useEffect(() => {
                rendererRef.current = new DeepSpaceRenderer(document.getElementById('canvas-container'));
                fetchState();
                const interval = setInterval(fetchState, 800);
                return () => clearInterval(interval);
            }, []);
            
            React.useEffect(() => {
                if (rendererRef.current && solar) rendererRef.current.updateFromState(solar);
            }, [solar]);
            
            const addLog = (msg, type = 'normal') => {
                setActionLog(prev => [...prev.slice(-9), { msg, type, time: Date.now() }]);
            };
            
            const fetchState = async () => {
                try {
                    const res = await fetch(`${API}/autus/solar/status`);
                    const data = await res.json();
                    setPrevSolar(solar);
                    setSolar(data);
                } catch(e) {}
            };
            
            const runCycle = async () => {
                const before = solar;
                await fetch(`${API}/autus/solar/tick`, { method: 'POST' });
                await fetchState();
                addLog(`CYCLE ‚Üí tick ${(before?.tick || 0) + 1}`, 'highlight');
            };
            
            const applyPressure = async () => {
                await fetch(`${API}/autus/solar/input`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ slot: 'Boundary', value: 1.0 })
                });
                await fetchState();
                addLog(`PRESSURE ‚Üí Effort +0.1, P Ï¶ùÍ∞Ä`, 'warning');
            };
            
            const applyRelease = async () => {
                await fetch(`${API}/autus/solar/input`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ slot: 'Boundary', value: 0.0 })
                });
                await fetchState();
                addLog(`RELEASE ‚Üí P Í∞êÏÜå`, 'highlight');
            };
            
            const applyBrain = async () => {
                await fetch(`${API}/autus/solar/input`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ slot: 'Brain', value: 1.0 })
                });
                await fetchState();
                addLog(`BRAIN ‚Üí Focus‚Üë, Talent ÏòÅÌñ•`, 'highlight');
            };
            
            const resetSolar = async () => {
                await fetch(`${API}/autus/solar/reset`, { method: 'POST' });
                await fetchState();
                setActionLog([]);
                addLog(`RESET ‚Üí Ï¥àÍ∏∞ ÏÉÅÌÉú`, 'highlight');
            };
            
            // Delta calculations
            const getDelta = (curr, prev, key) => {
                if (!prev) return null;
                const c = key.split('.').reduce((o, k) => o?.[k], curr) || 0;
                const p = key.split('.').reduce((o, k) => o?.[k], prev) || 0;
                const d = c - p;
                if (Math.abs(d) < 0.001) return null;
                return d;
            };
            
            const formatDelta = (d) => {
                if (d === null) return null;
                return <span className={`delta ${d > 0 ? 'up' : 'down'}`}>{d > 0 ? '‚Üë' : '‚Üì'}{Math.abs(d).toFixed(2)}</span>;
            };
            
            const orbit = solar?.orbit || {};
            const entropy = solar?.entropy || {};
            const gravity = solar?.gravity || {};
            const twin = solar?.twin || {};
            
            const statusClass = {
                'STABLE': 'stable',
                'WARNING': 'warning', 
                'UNSTABLE': 'unstable',
                'COLLAPSED': 'collapsed'
            }[orbit.status] || 'stable';
            
            // Check for status change
            React.useEffect(() => {
                if (prevSolar && solar) {
                    const prevStatus = prevSolar.orbit?.status;
                    const currStatus = solar.orbit?.status;
                    if (prevStatus !== currStatus) {
                        if (currStatus === 'WARNING') addLog(`‚ö†Ô∏è WARNING: Entropy ÏÉÅÏäπ Ï§ë`, 'warning');
                        else if (currStatus === 'UNSTABLE') addLog(`üî¥ UNSTABLE: Í∂§ÎèÑ Î∂àÏïàÏ†ï!`, 'danger');
                        else if (currStatus === 'COLLAPSED') addLog(`üí• COLLAPSED: ÏãúÏä§ÌÖú Î∂ïÍ¥¥!`, 'collapse');
                        else if (currStatus === 'STABLE') addLog(`‚úÖ STABLE: ÏïàÏ†ïÌôî ÏôÑÎ£å`, 'highlight');
                    }
                }
            }, [solar?.orbit?.status]);
            
            return (
                <>
                    {/* Header */}
                    <div className="ui-layer" style={{top: 24, left: 24}}>
                        <div style={{fontSize: 10, letterSpacing: '0.3em', opacity: 0.5}}>AUTUS</div>
                        <div style={{fontSize: 28, fontWeight: 200, marginTop: 4}}>Atlas</div>
                        <div style={{fontSize: 9, marginTop: 6, opacity: 0.4}}>PHYSICS v1.3</div>
                    </div>
                    
                    {/* Big Status */}
                    <div className="ui-layer" style={{top: 24, right: 24, textAlign: 'right'}}>
                        <div className={`big-status ${statusClass}`}>{orbit.status || 'STABLE'}</div>
                        <div style={{fontSize: 12, marginTop: 8, opacity: 0.6}}>
                            tick {solar?.tick || 0} ¬∑ cycle {solar?.cycle || 0}
                        </div>
                    </div>
                    
                    {/* Main Meters */}
                    <div className="ui-layer" style={{top: 120, right: 24, width: 200}}>
                        {/* Entropy */}
                        <div className="meter-container">
                            <div className="meter-label">
                                <span>ENTROPY</span>
                                <span style={{color: entropy.value > 1 ? '#ff4466' : entropy.value > 0.5 ? '#ffaa00' : '#00ff88'}}>
                                    {(entropy.value || 0).toFixed(2)}
                                    {formatDelta(getDelta(solar, prevSolar, 'entropy.value'))}
                                </span>
                            </div>
                            <div className="meter-bar">
                                <div className={`meter-fill ${entropy.value > 1 ? 'danger' : entropy.value > 0.5 ? 'warning' : 'good'}`} 
                                     style={{width: `${Math.min(100, (entropy.value || 0) * 40)}%`}}></div>
                            </div>
                        </div>
                        
                        {/* Gravity */}
                        <div className="meter-container">
                            <div className="meter-label">
                                <span>GRAVITY</span>
                                <span style={{color: '#00d4ff'}}>
                                    {(gravity.gravity || 0).toFixed(3)}
                                    {formatDelta(getDelta(solar, prevSolar, 'gravity.gravity'))}
                                </span>
                            </div>
                            <div className="meter-bar">
                                <div className="meter-fill good" style={{width: `${Math.min(100, (gravity.gravity || 0) * 200)}%`}}></div>
                            </div>
                        </div>
                        
                        {/* Effort */}
                        <div className="meter-container">
                            <div className="meter-label">
                                <span>EFFORT</span>
                                <span>
                                    {(gravity.effort || 0).toFixed(2)}
                                    {formatDelta(getDelta(solar, prevSolar, 'gravity.effort'))}
                                </span>
                            </div>
                            <div className="meter-bar">
                                <div className="meter-fill good" style={{width: `${Math.min(100, (gravity.effort || 0) * 100)}%`}}></div>
                            </div>
                        </div>
                        
                        {/* Pressure */}
                        <div className="meter-container">
                            <div className="meter-label">
                                <span>PRESSURE</span>
                                <span style={{color: twin.P > 1 ? '#ff4466' : '#fff'}}>
                                    {(twin.P || 0).toFixed(2)}
                                    {formatDelta(getDelta(solar, prevSolar, 'twin.P'))}
                                </span>
                            </div>
                            <div className="meter-bar">
                                <div className={`meter-fill ${twin.P > 1 ? 'danger' : 'good'}`} 
                                     style={{width: `${Math.min(100, (twin.P || 0) * 30)}%`}}></div>
                            </div>
                        </div>
                        
                        {/* Core */}
                        <div className="meter-container">
                            <div className="meter-label">
                                <span>CORE</span>
                                <span style={{color: (solar?.energy?.Core || 1) < 0.5 ? '#ff4466' : '#fff'}}>
                                    {((solar?.energy?.Core || 1) * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div className="meter-bar">
                                <div className={`meter-fill ${(solar?.energy?.Core || 1) < 0.5 ? 'danger' : 'good'}`} 
                                     style={{width: `${(solar?.energy?.Core || 1) * 100}%`}}></div>
                            </div>
                        </div>
                    </div>
                    
                    {/* Action Log */}
                    <div className="ui-layer" style={{bottom: 100, left: 24, width: 280}}>
                        <div style={{fontSize: 10, letterSpacing: '0.2em', marginBottom: 8, opacity: 0.5}}>ACTION LOG</div>
                        <div className="action-log">
                            {actionLog.length === 0 && <div className="log-entry text-dim">Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî...</div>}
                            {actionLog.map((log, i) => (
                                <div key={log.time} className={`log-entry ${log.type}`}>{log.msg}</div>
                            ))}
                        </div>
                    </div>
                    
                    {/* Controls */}
                    <div className="ui-layer" style={{bottom: 24, left: '50%', transform: 'translateX(-50)', display: 'flex', gap: 12}}>
                        <button className="primary" onClick={runCycle}>CYCLE</button>
                        <button onClick={applyBrain}>BRAIN</button>
                        <button className="danger" onClick={applyPressure}>PRESSURE</button>
                        <button className="success" onClick={applyRelease}>RELEASE</button>
                        <button onClick={resetSolar} style={{opacity: 0.6}}>RESET</button>
                    </div>
                    
                    {/* Instructions */}
                    <div className="ui-layer" style={{bottom: 24, right: 24, fontSize: 10, opacity: 0.4, textAlign: 'right', lineHeight: 1.8}}>
                        <div>PRESSURE √ó 10 ‚Üí CYCLE √ó 30 = Î∂ïÍ¥¥</div>
                        <div>RESET = Î≥µÍµ¨</div>
                    </div>
                </>
            );
        }
        
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
