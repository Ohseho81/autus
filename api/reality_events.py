"""
FastAPI endpoint to receive IoT sensor events via webhook and update Twin graph.
Auto-generated by AUTUS Pack Engine
"""

from datetime import datetime
from typing import Dict, Any, Optional, List
import logging
from uuid import uuid4

from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel, Field, validator

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/reality-events", tags=["Reality Events"])


class IoTSensorPayload(BaseModel):
    """IoT sensor event payload model."""
    
    device_id: str = Field(..., description="Unique device identifier")
    sensor_type: str = Field(..., description="Type of sensor")
    value: float = Field(..., description="Sensor reading value")
    unit: str = Field(..., description="Unit of measurement")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    location: Optional[Dict[str, float]] = Field(None, description="GPS coordinates")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @validator('device_id')
    def validate_device_id(cls, v):
        if not v or len(v.strip()) == 0:
            raise ValueError("Device ID cannot be empty")
        return v.strip()
    
    @validator('sensor_type')
    def validate_sensor_type(cls, v):
        allowed_types = ['temperature', 'humidity', 'pressure', 'motion', 'light', 'air_quality']
        if v.lower() not in allowed_types:
            logger.warning(f"Unknown sensor type: {v}")
        return v.lower()


class WebhookResponse(BaseModel):
    """Webhook response model."""
    
    status: str = Field(..., description="Processing status")
    event_id: str = Field(..., description="Generated event ID")
    message: str = Field(..., description="Response message")
    processed_at: datetime = Field(default_factory=datetime.utcnow)


class BatchSensorPayload(BaseModel):
    """Batch sensor events payload."""
    
    events: List[IoTSensorPayload] = Field(..., description="List of sensor events")
    batch_id: Optional[str] = Field(None, description="Optional batch identifier")


# In-memory storage for demo
twin_graph_data: Dict[str, Any] = {}


@router.post("/webhook/sensor", response_model=WebhookResponse)
async def receive_sensor_event(
    payload: IoTSensorPayload,
    background_tasks: BackgroundTasks
) -> WebhookResponse:
    """Receive single IoT sensor event via webhook and update Twin graph."""
    try:
        event_id = str(uuid4())
        
        # Update Twin Graph
        background_tasks.add_task(
            update_twin_graph,
            payload.device_id,
            payload.dict()
        )
        
        logger.info(f"Received sensor event from device {payload.device_id}")
        
        return WebhookResponse(
            status="accepted",
            event_id=event_id,
            message=f"Sensor event from {payload.device_id} queued for processing"
        )
        
    except Exception as e:
        logger.error(f"Error processing sensor event: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/webhook/sensor/batch")
async def receive_batch_sensor_events(
    payload: BatchSensorPayload,
    background_tasks: BackgroundTasks
) -> List[WebhookResponse]:
    """Receive batch of IoT sensor events."""
    responses = []
    
    for event_payload in payload.events:
        event_id = str(uuid4())
        
        background_tasks.add_task(
            update_twin_graph,
            event_payload.device_id,
            event_payload.dict()
        )
        
        responses.append(WebhookResponse(
            status="accepted",
            event_id=event_id,
            message=f"Batch event from {event_payload.device_id} queued"
        ))
    
    logger.info(f"Received batch of {len(payload.events)} sensor events")
    return responses


@router.get("/devices/{device_id}/status")
async def get_device_status(device_id: str) -> Dict[str, Any]:
    """Get current status for a device."""
    if device_id not in twin_graph_data:
        raise HTTPException(status_code=404, detail=f"Device {device_id} not found")
    
    return twin_graph_data[device_id]


@router.post("/webhook/device/heartbeat")
async def receive_device_heartbeat(
    device_id: str,
    background_tasks: BackgroundTasks
) -> WebhookResponse:
    """Receive device heartbeat."""
    background_tasks.add_task(
        update_device_heartbeat,
        device_id
    )
    
    return WebhookResponse(
        status="accepted",
        event_id=f"heartbeat_{device_id}_{int(datetime.utcnow().timestamp())}",
        message=f"Heartbeat from {device_id} acknowledged"
    )


@router.get("/twin/graph")
async def get_twin_graph() -> Dict[str, Any]:
    """Get current Twin graph state."""
    return {
        "devices": len(twin_graph_data),
        "data": twin_graph_data,
        "updated_at": datetime.utcnow().isoformat()
    }


async def update_twin_graph(device_id: str, sensor_data: Dict[str, Any]) -> None:
    """Update Twin graph with sensor data."""
    if device_id not in twin_graph_data:
        twin_graph_data[device_id] = {
            "device_id": device_id,
            "events": [],
            "last_seen": None
        }
    
    twin_graph_data[device_id]["events"].append(sensor_data)
    twin_graph_data[device_id]["last_seen"] = datetime.utcnow().isoformat()
    
    # Keep only last 100 events per device
    if len(twin_graph_data[device_id]["events"]) > 100:
        twin_graph_data[device_id]["events"] = twin_graph_data[device_id]["events"][-100:]
    
    logger.debug(f"Updated Twin graph for device {device_id}")


async def update_device_heartbeat(device_id: str) -> None:
    """Update device heartbeat timestamp."""
    if device_id not in twin_graph_data:
        twin_graph_data[device_id] = {
            "device_id": device_id,
            "events": [],
            "last_seen": None
        }
    
    twin_graph_data[device_id]["last_heartbeat"] = datetime.utcnow().isoformat()
    logger.debug(f"Updated heartbeat for device {device_id}")
