<!DOCTYPE html>
<html>
<head>
    <title>AUTUS 3D HUD - Universe OS</title>
    <style>
        * { margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; left: 10px; color: #0f0; font: 14px monospace; }
        #wsStatus { position: absolute; bottom: 10px; left: 10px; color: #0f0; font: 12px monospace; }
        #modules { position: absolute; top: 10px; right: 10px; color: #fff; font: 12px sans-serif; }
        .module-btn { display: block; margin: 5px 0; padding: 8px 16px; background: #222; 
                      border: 1px solid #444; color: #0f0; cursor: pointer; }
        .module-btn:hover { background: #333; border-color: #0f0; }
        .module-btn.active { background: #0a3; }
        #eventLog { position: absolute; bottom: 40px; left: 10px; color: #888; font: 10px monospace; 
                    max-height: 150px; overflow-y: auto; width: 300px; }
        .log-entry { padding: 2px 0; border-bottom: 1px solid #333; }
        .log-entry.update { color: #0f0; }
        .log-entry.error { color: #f00; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="info">AUTUS 3D HUD | Loading...</div>
    <div id="wsStatus">WebSocket: Disconnected</div>
    <div id="eventLog"></div>
    <div id="modules">
        <button class="module-btn active" data-module="all">All</button>
        <button class="module-btn" data-module="identity">Identity Surface</button>
        <button class="module-btn" data-module="workflow">Workflow Orbit</button>
        <button class="module-btn" data-module="memory">Memory Galaxy</button>
        <button class="module-btn" data-module="risk">Risk Nebula</button>
        <button class="module-btn" data-module="packs">Pack Universe</button>
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const API_BASE = "http://127.0.0.1:8000/api";
        const WS_URL = "ws://127.0.0.1:8000/stream";
        
        const nodes = {};
        let currentModule = "all";
        let ws = null;
        let scene = null;
        
        // 로그 함수
        const log = (msg, type = "info") => {
            const logEl = document.getElementById("eventLog");
            const entry = document.createElement("div");
            entry.className = "log-entry " + type;
            entry.textContent = new Date().toLocaleTimeString() + " " + msg;
            logEl.insertBefore(entry, logEl.firstChild);
            if (logEl.children.length > 20) logEl.removeChild(logEl.lastChild);
        };
        
        // WebSocket 연결
        const connectWebSocket = () => {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                document.getElementById("wsStatus").textContent = "WebSocket: Connected ✓";
                document.getElementById("wsStatus").style.color = "#0f0";
                log("WebSocket connected", "update");
            };
            
            ws.onclose = () => {
                document.getElementById("wsStatus").textContent = "WebSocket: Disconnected";
                document.getElementById("wsStatus").style.color = "#f00";
                log("WebSocket disconnected", "error");
                // 재연결 시도
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = (err) => {
                log("WebSocket error", "error");
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleServerUpdate(data);
                } catch (e) {
                    log("Parse error: " + e.message, "error");
                }
            };
        };
        
        // 서버 업데이트 처리
        const handleServerUpdate = (data) => {
            log("Update: " + (data.type || data.update || "unknown"), "update");
            
            if (data.type === "node_update" && data.node) {
                updateNode(scene, data.node);
            } else if (data.type === "state_change") {
                // 전체 상태 새로고침
                renderModule(scene, currentModule);
            } else if (data.update) {
                // 단일 노드 업데이트
                updateNode(scene, data);
            }
        };
        
        // 노드 업데이트/생성
        const updateNode = (scene, data) => {
            const id = data.node_id;
            const pos = data.position;
            const props = data.properties || {};
            
            if (nodes[id]) {
                // 기존 노드 업데이트 (애니메이션)
                const mesh = nodes[id];
                BABYLON.Animation.CreateAndStartAnimation(
                    "move", mesh, "position", 30, 15,
                    mesh.position,
                    new BABYLON.Vector3(pos[0], pos[1], pos[2]),
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
                
                // 색상 업데이트
                if (props.color && mesh.material) {
                    const newColor = BABYLON.Color3.FromHexString(props.color);
                    mesh.material.diffuseColor = newColor;
                    mesh.material.emissiveColor = newColor.scale(0.3);
                }
                
                // 스케일 업데이트
                if (props.scale) {
                    mesh.scaling = new BABYLON.Vector3(props.scale, props.scale, props.scale);
                }
            } else {
                // 새 노드 생성
                createNode(scene, data);
            }
        };
        
        // 씬 생성
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);
            
            const camera = new BABYLON.ArcRotateCamera(
                "camera", Math.PI/4, Math.PI/3, 20, 
                BABYLON.Vector3.Zero(), scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 50;
            
            const light = new BABYLON.HemisphericLight(
                "light", new BABYLON.Vector3(0, 1, 0), scene
            );
            light.intensity = 0.7;
            
            createStars(scene);
            return scene;
        };
        
        const createStars = (scene) => {
            const starMaterial = new BABYLON.StandardMaterial("starMat", scene);
            starMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
            for (let i = 0; i < 500; i++) {
                const star = BABYLON.MeshBuilder.CreateSphere("star" + i, {diameter: 0.05}, scene);
                star.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                star.material = starMaterial;
            }
        };
        
        const createNode = (scene, data) => {
            const id = data.node_id;
            const pos = data.position;
            const props = data.properties || {};
            
            if (nodes[id]) nodes[id].dispose();
            
            let mesh;
            const shape = props.shape || "sphere";
            const scale = props.scale || 1;
            
            if (shape === "icosahedron") {
                mesh = BABYLON.MeshBuilder.CreatePolyhedron(id, {type: 3, size: scale}, scene);
            } else if (shape === "dodecahedron") {
                mesh = BABYLON.MeshBuilder.CreatePolyhedron(id, {type: 2, size: scale}, scene);
            } else {
                mesh = BABYLON.MeshBuilder.CreateSphere(id, {diameter: scale * 2}, scene);
            }
            
            mesh.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);
            
            const mat = new BABYLON.StandardMaterial(id + "_mat", scene);
            const color = BABYLON.Color3.FromHexString(props.color || "#ffffff");
            mat.diffuseColor = color;
            mat.emissiveColor = color.scale(0.3);
            
            if (props.state === "running") {
                mat.emissiveColor = color.scale(0.8);
            }
            
            mesh.material = mat;
            nodes[id] = mesh;
            
            // 클릭 이벤트
            mesh.actionManager = new BABYLON.ActionManager(scene);
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    () => {
                        sendEvent("node_click", id, "open_details");
                        log("Clicked: " + id);
                    }
                )
            );
            
            return mesh;
        };
        
        const loadModule = async (module) => {
            try {
                let url = module === "all" ? `${API_BASE}/nodes/all` : `${API_BASE}/state/${module}`;
                const res = await fetch(url);
                return await res.json();
            } catch (e) {
                log("Load error: " + e.message, "error");
                return null;
            }
        };
        
        const renderModule = async (scene, module) => {
            Object.values(nodes).forEach(n => n.dispose());
            Object.keys(nodes).forEach(k => delete nodes[k]);
            
            if (module === "all") {
                const data = await loadModule("all");
                if (!data) return;
                if (data.identity) createNode(scene, data.identity);
                (data.workflow || []).forEach(n => createNode(scene, n));
                (data.memory || []).forEach(n => createNode(scene, n));
                (data.risk || []).forEach(n => createNode(scene, n));
                (data.packs || []).forEach(n => createNode(scene, n));
            } else if (module === "identity") {
                const data = await loadModule("identity");
                if (data) createNode(scene, data);
            } else {
                const data = await loadModule(module);
                if (data && data.nodes) data.nodes.forEach(n => createNode(scene, n));
            }
            
            updateInfo(module);
        };
        
        const sendEvent = async (event, nodeId, action) => {
            // REST API로 전송
            try {
                await fetch(`${API_BASE}/event`, {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({event, node_id: nodeId, action})
                });
            } catch (e) {}
            
            // WebSocket으로도 전송
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({event, node_id: nodeId, action}));
            }
        };
        
        const updateInfo = (module) => {
            const count = Object.keys(nodes).length;
            document.getElementById("info").textContent = 
                `AUTUS 3D HUD | Module: ${module} | Nodes: ${count}`;
        };
        
        // 버튼 이벤트
        document.querySelectorAll(".module-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                document.querySelectorAll(".module-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                currentModule = btn.dataset.module;
                renderModule(scene, currentModule);
            });
        });
        
        // 초기화
        scene = createScene();
        
        engine.runRenderLoop(() => {
            // 애니메이션: 노드 부드러운 회전
            Object.values(nodes).forEach(mesh => {
                if (mesh.name.includes("workflow")) {
                    mesh.rotation.y += 0.005;
                }
            });
            scene.render();
        });
        
        window.addEventListener("resize", () => engine.resize());
        
        // 초기 로드
        renderModule(scene, "all");
        
        // WebSocket 연결
        connectWebSocket();
    </script>
</body>
</html>
