<!DOCTYPE html>
<html>
<head>
    <title>AUTUS 3D HUD - Universe OS</title>
    <style>
        * { margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; left: 10px; color: #0f0; font: 14px monospace; }
        #wsStatus { position: absolute; bottom: 10px; left: 10px; color: #0f0; font: 12px monospace; }
        #modules { position: absolute; top: 10px; right: 10px; color: #fff; font: 12px sans-serif; }
        .module-btn { display: block; margin: 5px 0; padding: 8px 16px; background: #222; 
                      border: 1px solid #444; color: #0f0; cursor: pointer; }
        .module-btn:hover { background: #333; border-color: #0f0; }
        .module-btn.active { background: #0a3; }
        #eventLog { position: absolute; bottom: 40px; left: 10px; color: #888; font: 10px monospace; 
                    max-height: 100px; overflow-y: auto; width: 300px; }
        .log-entry { padding: 2px 0; }
        .log-entry.update { color: #0f0; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="info">AUTUS 3D HUD | Loading...</div>
    <div id="wsStatus">WebSocket: Connecting...</div>
    <div id="eventLog"></div>
    <div id="modules">
        <button class="module-btn active" data-module="all">전체</button>
        <button class="module-btn" data-module="identity">정체성 표면</button>
        <button class="module-btn" data-module="workflow">워크플로 궤도</button>
        <button class="module-btn" data-module="memory">기억의 은하계</button>
        <button class="module-btn" data-module="risk">위험 성운</button>
        <button class="module-btn" data-module="packs">팩 유니버스</button>
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const WS_URL = "ws://127.0.0.1:8000/stream";
        const nodes = {};
        const nodeData = {};  // 노드 메타데이터 저장
        let currentModule = "all";
        let ws = null;
        let scene = null;
        let time = 0;

        // 3중 구 구조용 /3d/state API 로드
        const load3DSphereState = async () => {
            const res = await fetch("http://127.0.0.1:8000/3d/state");
            return await res.json();
        };

        // Triple Sphere 노드 배치 (레이어별 구의 반지름)
        const LAYER_RADIUS = { core: 3, protocols: 6, packs: 10 };
        function spherePosition(idx, total, radius) {
            // 골고루 분포: 골드 스파이럴
            const phi = Math.acos(1 - 2 * (idx + 0.5) / total);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (idx + 0.5);
            return [
                radius * Math.cos(theta) * Math.sin(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(phi)
            ];
        }

        // Triple Sphere 렌더
        const render3DSphere = async (scene) => {
            Object.values(nodes).forEach(n => n.dispose());
            Object.keys(nodes).forEach(k => delete nodes[k]);
            const data = await load3DSphereState();
            if (!data) return;
            // Core
            (data.core.nodes || []).forEach((n, i, arr) => createNode(scene, {
                node_id: n.id,
                position: spherePosition(i, arr.length, LAYER_RADIUS.core),
                properties: { label: n.label, color: "#00ffff", scale: 1.2, type: "core" }
            }));
            // Protocols
            (data.protocols.nodes || []).forEach((n, i, arr) => createNode(scene, {
                node_id: n.id,
                position: spherePosition(i, arr.length, LAYER_RADIUS.protocols),
                properties: { label: n.label, color: "#ff00ff", scale: 1.0, type: "protocol" }
            }));
            // Packs
            (data.packs.nodes || []).forEach((n, i, arr) => createNode(scene, {
                node_id: n.id,
                position: spherePosition(i, arr.length, LAYER_RADIUS.packs),
                properties: { label: n.label, color: "#ffff00", scale: 0.8, type: "pack" }
            }));
            updateInfo("3중구");
        };
        
        // 로그
        const log = (msg, type = "info") => {
            const logEl = document.getElementById("eventLog");
            const entry = document.createElement("div");
            entry.className = "log-entry " + type;
            entry.textContent = new Date().toLocaleTimeString() + " " + msg;
            logEl.insertBefore(entry, logEl.firstChild);
            if (logEl.children.length > 10) logEl.removeChild(logEl.lastChild);
        };
        
        // WebSocket
        const connectWebSocket = () => {
            ws = new WebSocket(WS_URL);
            ws.onopen = () => {
                document.getElementById("wsStatus").textContent = "WebSocket: 연결됨 ✓";
                document.getElementById("wsStatus").style.color = "#0f0";
                log("WebSocket 연결됨", "update");
            };
            ws.onclose = () => {
                document.getElementById("wsStatus").textContent = "WebSocket: 연결 끊김";
                document.getElementById("wsStatus").style.color = "#f00";
                setTimeout(connectWebSocket, 3000);
            };
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === "node_update" && data.node) {
                        updateNode(scene, data.node);
                        log("노드 업데이트: " + data.node.node_id, "update");
                    }
                } catch (e) {}
            };
        };
        
        // 노드 업데이트
        const updateNode = (scene, data) => {
            const id = data.node_id;
            const pos = data.position;
            const props = data.properties || {};
            
            if (nodes[id]) {
                const mesh = nodes[id];
                // 부드러운 이동 애니메이션
                BABYLON.Animation.CreateAndStartAnimation(
                    "move", mesh, "position", 60, 30,
                    mesh.position,
                    new BABYLON.Vector3(pos[0], pos[1], pos[2]),
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
                if (props.color && mesh.material) {
                    const newColor = BABYLON.Color3.FromHexString(props.color);
                    mesh.material.diffuseColor = newColor;
                    mesh.material.emissiveColor = newColor.scale(0.4);
                }
                if (props.scale) {
                    BABYLON.Animation.CreateAndStartAnimation(
                        "scale", mesh, "scaling", 60, 20,
                        mesh.scaling,
                        new BABYLON.Vector3(props.scale, props.scale, props.scale),
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );
                }
                nodeData[id] = { ...nodeData[id], ...props };
            } else {
                createNode(scene, data);
            }
        };
        
        // 씬 생성
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.01, 0.01, 0.03, 1);
            
            const camera = new BABYLON.ArcRotateCamera(
                "camera", Math.PI/4, Math.PI/3, 25, 
                BABYLON.Vector3.Zero(), scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 60;
            
            // 조명
            const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 0.6;
            const light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 5, 0), scene);
            light2.intensity = 0.4;
            
            // 글로우 효과
            const gl = new BABYLON.GlowLayer("glow", scene);
            gl.intensity = 0.5;
            
            createStars(scene);
            createOrbitRings(scene);
            return scene;
        };
        
        // 별 배경
        const createStars = (scene) => {
            const starMat = new BABYLON.StandardMaterial("starMat", scene);
            starMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            starMat.disableLighting = true;
            
            for (let i = 0; i < 800; i++) {
                const star = BABYLON.MeshBuilder.CreateSphere("star" + i, {diameter: 0.03 + Math.random() * 0.05}, scene);
                star.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 150,
                    (Math.random() - 0.5) * 150,
                    (Math.random() - 0.5) * 150
                );
                star.material = starMat;
            }
        };
        
        // 궤도 링
        const createOrbitRings = (scene) => {
            const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
            ringMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.3);
            ringMat.alpha = 0.3;
            ringMat.disableLighting = true;
            
            [3, 5, 8, 12].forEach(radius => {
                const ring = BABYLON.MeshBuilder.CreateTorus("ring" + radius, {
                    diameter: radius * 2,
                    thickness: 0.02,
                    tessellation: 64
                }, scene);
                ring.rotation.x = Math.PI / 2;
                ring.material = ringMat;
            });
        };
        
        // 노드 생성
        const createNode = (scene, data) => {
            const id = data.node_id;
            const pos = data.position;
            const props = data.properties || {};
            
            if (nodes[id]) nodes[id].dispose();
            
            let mesh;
            const shape = props.shape || "sphere";
            const scale = props.scale || 1;
            
            if (shape === "icosahedron") {
                mesh = BABYLON.MeshBuilder.CreatePolyhedron(id, {type: 3, size: scale * 0.8}, scene);
            } else if (shape === "dodecahedron") {
                mesh = BABYLON.MeshBuilder.CreatePolyhedron(id, {type: 2, size: scale * 0.8}, scene);
            } else if (shape === "octahedron") {
                mesh = BABYLON.MeshBuilder.CreatePolyhedron(id, {type: 1, size: scale * 0.8}, scene);
            } else {
                mesh = BABYLON.MeshBuilder.CreateSphere(id, {diameter: scale * 2, segments: 32}, scene);
            }
            
            mesh.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);
            
            const mat = new BABYLON.StandardMaterial(id + "_mat", scene);
            const color = BABYLON.Color3.FromHexString(props.color || "#ffffff");
            mat.diffuseColor = color;
            mat.emissiveColor = color.scale(0.4);
            mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            
            if (props.state === "running") {
                mat.emissiveColor = color.scale(0.8);
            }
            
            mesh.material = mat;
            nodes[id] = mesh;
            nodeData[id] = { type: id.split("_")[0], state: props.state || "idle", ...props };
            
            // 클릭
            mesh.actionManager = new BABYLON.ActionManager(scene);
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    () => {
                        log("클릭: " + id);
                        // 클릭 시 확대 효과
                        BABYLON.Animation.CreateAndStartAnimation(
                            "click", mesh, "scaling", 60, 10,
                            mesh.scaling,
                            mesh.scaling.scale(1.3),
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                            null,
                            () => {
                                BABYLON.Animation.CreateAndStartAnimation(
                                    "click2", mesh, "scaling", 60, 10,
                                    mesh.scaling,
                                    mesh.scaling.scale(1/1.3),
                                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                );
                            }
                        );
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({event: "node_click", node_id: id}));
                        }
                    }
                )
            );
            
            return mesh;
        };
        
        // API 로드
        const loadModule = async (module) => {
            try {
                const url = module === "all" ? `${API_BASE}/nodes/all` : `${API_BASE}/state/${module}`;
                const res = await fetch(url);
                return await res.json();
            } catch (e) {
                return null;
            }
        };
        
        const renderModule = async (scene, module) => {
            if (module === "all") {
                await render3DSphere(scene);
            } else {
                // 기존 방식 유지 (identity, workflow 등)
                const data = await loadModule(module);
                if (data && data.nodes) data.nodes.forEach(n => createNode(scene, n));
                updateInfo(module);
            }
        };
        
        const updateInfo = (module) => {
            const moduleNames = {all: "전체", identity: "정체성", workflow: "워크플로", memory: "기억", risk: "위험", packs: "팩"};
            document.getElementById("info").textContent = 
                `AUTUS 3D HUD | 모듈: ${moduleNames[module] || module} | 노드: ${Object.keys(nodes).length}`;
        };
        
        // 버튼
        document.querySelectorAll(".module-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                document.querySelectorAll(".module-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                currentModule = btn.dataset.module;
                renderModule(scene, currentModule);
            });
        });
        
        // 초기화
        scene = createScene();
        
        // 렌더 루프 - 애니메이션
        engine.runRenderLoop(() => {
            time += 0.016;
            
            Object.entries(nodes).forEach(([id, mesh]) => {
                const data = nodeData[id] || {};
                const type = data.type || "";
                
                // 워크플로 노드: 궤도 회전
                if (type === "workflow") {
                    mesh.rotation.y += 0.01;
                    // running 상태면 펄스
                    if (data.state === "running" && mesh.material) {
                        const pulse = 0.4 + Math.sin(time * 5) * 0.3;
                        mesh.material.emissiveColor = mesh.material.diffuseColor.scale(pulse);
                    }
                }
                
                // Identity: 천천히 회전 + 호흡
                if (type === "identity") {
                    mesh.rotation.y += 0.005;
                    mesh.rotation.x += 0.002;
                    const breathe = 1 + Math.sin(time * 2) * 0.05;
                    mesh.scaling = new BABYLON.Vector3(breathe, breathe, breathe);
                }
                
                // Pack: 자전
                if (type === "pack") {
                    mesh.rotation.y += 0.008;
                }
                
                // Pattern: 부유
                if (type === "pattern") {
                    mesh.position.y += Math.sin(time * 3 + mesh.position.x) * 0.002;
                }
                
                // Risk: 경고 시 점멸
                if (type === "risk" && data.level > 0.3 && mesh.material) {
                    const blink = 0.5 + Math.sin(time * 8) * 0.4;
                    mesh.material.emissiveColor = mesh.material.diffuseColor.scale(blink);
                }
            });
            
            scene.render();
        });
        
        window.addEventListener("resize", () => engine.resize());
        
        // 시작
        renderModule(scene, "all");
        connectWebSocket();
    </script>
</body>
</html>
