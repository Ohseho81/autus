<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUTUS Goal Network</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Inter:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --cyan: #5de6e6;
      --cyan-light: #7fffff;
      --cyan-glow: rgba(93, 230, 230, 0.5);
      --bg-dark: #1a2332;
      --bg-darker: #0f1620;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      font-family: 'Inter', sans-serif;
      color: #fff;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 20px;
    }

    /* ============================================ */
    /* SUBWAY MAP (상단 연결 레이어)                  */
    /* ============================================ */
    .subway-layer {
      flex-shrink: 0;
      padding: 20px 10px;
      background: var(--bg-darker);
      border-radius: 16px;
      margin-bottom: 20px;
      overflow-x: auto;
    }

    .subway-map {
      position: relative;
      height: 100px;
      min-width: 1200px;
    }

    .subway-line {
      position: absolute;
      height: 4px;
      background: var(--cyan);
      border-radius: 2px;
    }

    .subway-node {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translateX(-50%);
    }

    .node-dot {
      width: 16px;
      height: 16px;
      background: var(--cyan);
      border: 3px solid var(--bg-darker);
      border-radius: 50%;
      box-shadow: 0 0 10px var(--cyan-glow);
    }

    .node-dot.branch {
      width: 20px;
      height: 20px;
      background: #fff;
      border: 4px solid var(--cyan);
    }

    .node-label {
      font-size: 10px;
      color: var(--cyan-light);
      margin-top: 6px;
      white-space: nowrap;
      font-weight: 500;
    }

    .node-label.top {
      position: absolute;
      bottom: 100%;
      margin-bottom: 6px;
      margin-top: 0;
    }

    /* Branch lines */
    .branch-line {
      position: absolute;
      width: 3px;
      background: var(--cyan);
    }

    /* ============================================ */
    /* GOAL NETWORK (중앙 신경망)                    */
    /* ============================================ */
    .network-layer {
      flex: 1;
      position: relative;
      background: radial-gradient(ellipse at center, #1a3040 0%, #0a1520 50%, #050a10 100%);
      border-radius: 16px;
      overflow: hidden;
    }

    #networkCanvas {
      width: 100%;
      height: 100%;
    }

    /* ============================================ */
    /* PROGRESS BAR (하단)                          */
    /* ============================================ */
    .progress-layer {
      flex-shrink: 0;
      margin-top: 20px;
      padding: 12px 20px;
      background: var(--bg-darker);
      border-radius: 12px;
    }

    .progress-bar {
      height: 12px;
      background: #2a3a4a;
      border-radius: 6px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--cyan), var(--cyan-light));
      border-radius: 6px;
      width: 65%;
      box-shadow: 0 0 20px var(--cyan-glow);
      transition: width 0.5s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- 상단: 지하철 노선도 스타일 연결 레이어 -->
    <div class="subway-layer">
      <div class="subway-map" id="subwayMap"></div>
    </div>

    <!-- 중앙: GOAL 네트워크 -->
    <div class="network-layer">
      <canvas id="networkCanvas"></canvas>
    </div>

    <!-- 하단: 프로그레스 바 -->
    <div class="progress-layer">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // SUBWAY MAP DATA
    // ============================================
    const subwayNodes = [
      { id: 'airbnb', label: 'Airbnb', x: 40, y: 50, branch: false },
      { id: 'clothes', label: 'Clothes', x: 100, y: 50, branch: false },
      { id: 'health', label: 'Health', x: 160, y: 30, branch: true, labelTop: true },
      { id: 'weather', label: 'Weather', x: 160, y: 70, branch: false },
      { id: 'bro', label: 'Bro', x: 220, y: 50, branch: true },
      { id: 'jobci', label: 'Job Ci Works', x: 280, y: 30, branch: false, labelTop: true },
      { id: 'interview', label: 'Interview', x: 280, y: 70, branch: false },
      { id: 'deal', label: 'Deal', x: 340, y: 50, branch: true },
      { id: 'wellness', label: 'Wellness', x: 400, y: 30, branch: false, labelTop: true },
      { id: 'email', label: 'M. Email', x: 400, y: 70, branch: false },
      { id: 'noarms', label: 'No Arms', x: 460, y: 50, branch: false },
      { id: 'blog', label: 'Blog', x: 520, y: 50, branch: true },
      { id: 'draft', label: 'Draft', x: 580, y: 30, branch: false, labelTop: true },
      { id: 'charlotte', label: 'Charlotte', x: 580, y: 70, branch: false },
      { id: 'startup', label: 'Startup', x: 640, y: 50, branch: false },
      { id: 'growth', label: 'Growth', x: 700, y: 50, branch: true },
      { id: 'charity', label: 'Charity', x: 760, y: 30, branch: false, labelTop: true },
      { id: 'seroku', label: 'Ser0ku', x: 760, y: 70, branch: false },
      { id: 'conflicts', label: 'Conflicts', x: 820, y: 50, branch: false },
      { id: 'benefits', label: 'Benefits', x: 900, y: 30, branch: false, labelTop: true },
      { id: 'doubles', label: 'Doubles', x: 900, y: 50, branch: true },
      { id: 'changes', label: 'Changes', x: 980, y: 50, branch: false },
    ];

    // ============================================
    // RENDER SUBWAY MAP
    // ============================================
    function renderSubwayMap() {
      const container = document.getElementById('subwayMap');
      
      // Main horizontal line
      const mainLine = document.createElement('div');
      mainLine.className = 'subway-line';
      mainLine.style.left = '40px';
      mainLine.style.top = '50px';
      mainLine.style.width = '960px';
      container.appendChild(mainLine);

      // Nodes
      subwayNodes.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'subway-node';
        nodeEl.style.left = node.x + 'px';
        nodeEl.style.top = node.y + 'px';

        const dot = document.createElement('div');
        dot.className = 'node-dot' + (node.branch ? ' branch' : '');
        nodeEl.appendChild(dot);

        const label = document.createElement('div');
        label.className = 'node-label' + (node.labelTop ? ' top' : '');
        label.textContent = node.label;
        nodeEl.appendChild(label);

        container.appendChild(nodeEl);

        // Branch lines for nodes not on main line
        if (node.y !== 50) {
          const branchLine = document.createElement('div');
          branchLine.className = 'branch-line';
          branchLine.style.left = node.x + 'px';
          if (node.y < 50) {
            branchLine.style.top = node.y + 'px';
            branchLine.style.height = (50 - node.y) + 'px';
          } else {
            branchLine.style.top = '50px';
            branchLine.style.height = (node.y - 50) + 'px';
          }
          container.appendChild(branchLine);
        }
      });
    }

    // ============================================
    // GOAL NETWORK (Canvas 2D)
    // ============================================
    const canvas = document.getElementById('networkCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Network nodes
    class NetworkNode {
      constructor(x, y, radius, isGoal = false) {
        this.x = x;
        this.y = y;
        this.baseRadius = radius;
        this.radius = radius;
        this.isGoal = isGoal;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.phase = Math.random() * Math.PI * 2;
        this.pulseSpeed = 0.02 + Math.random() * 0.02;
      }

      update(t) {
        if (!this.isGoal) {
          this.x += this.vx;
          this.y += this.vy;
          
          // Boundary bounce
          const margin = 100;
          if (this.x < margin || this.x > canvas.width - margin) this.vx *= -1;
          if (this.y < margin || this.y > canvas.height - margin) this.vy *= -1;
        }
        
        // Pulse
        this.radius = this.baseRadius + Math.sin(t * this.pulseSpeed + this.phase) * (this.baseRadius * 0.1);
      }

      draw(ctx) {
        // Outer glow
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius * 2
        );
        
        if (this.isGoal) {
          gradient.addColorStop(0, 'rgba(93, 230, 230, 0.9)');
          gradient.addColorStop(0.5, 'rgba(93, 230, 230, 0.3)');
          gradient.addColorStop(1, 'rgba(93, 230, 230, 0)');
        } else {
          gradient.addColorStop(0, 'rgba(30, 100, 110, 0.8)');
          gradient.addColorStop(0.6, 'rgba(20, 80, 90, 0.4)');
          gradient.addColorStop(1, 'rgba(10, 60, 70, 0)');
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Inner sphere
        const innerGradient = ctx.createRadialGradient(
          this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
          this.x, this.y, this.radius
        );
        
        if (this.isGoal) {
          innerGradient.addColorStop(0, 'rgba(180, 255, 255, 1)');
          innerGradient.addColorStop(0.5, 'rgba(93, 230, 230, 0.9)');
          innerGradient.addColorStop(1, 'rgba(40, 150, 160, 0.8)');
        } else {
          innerGradient.addColorStop(0, 'rgba(80, 160, 170, 0.9)');
          innerGradient.addColorStop(0.5, 'rgba(40, 100, 110, 0.7)');
          innerGradient.addColorStop(1, 'rgba(20, 60, 70, 0.5)');
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = innerGradient;
        ctx.fill();

        // Stroke
        ctx.strokeStyle = this.isGoal ? 'rgba(93, 230, 230, 0.8)' : 'rgba(60, 140, 150, 0.5)';
        ctx.lineWidth = this.isGoal ? 3 : 1;
        ctx.stroke();

        // GOAL text
        if (this.isGoal) {
          ctx.font = 'bold 24px Inter';
          ctx.fillStyle = '#0a1520';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('GOAL', this.x, this.y);
        }
      }
    }

    // Create nodes
    let nodes = [];
    let goalNode = null;

    function initNodes() {
      nodes = [];
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // Goal node (center)
      goalNode = new NetworkNode(cx, cy, 60, true);
      nodes.push(goalNode);

      // Surrounding nodes
      const nodeCount = 15;
      for (let i = 0; i < nodeCount; i++) {
        const angle = (i / nodeCount) * Math.PI * 2 + Math.random() * 0.5;
        const dist = 120 + Math.random() * 180;
        const x = cx + Math.cos(angle) * dist;
        const y = cy + Math.sin(angle) * dist;
        const radius = 25 + Math.random() * 35;
        nodes.push(new NetworkNode(x, y, radius));
      }
    }

    // Draw connections
    function drawConnections(ctx, t) {
      nodes.forEach((node, i) => {
        if (node.isGoal) return;

        // Connection to goal
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        
        // Curved line to goal
        const midX = (node.x + goalNode.x) / 2 + Math.sin(t * 0.001 + i) * 20;
        const midY = (node.y + goalNode.y) / 2 + Math.cos(t * 0.001 + i) * 20;
        ctx.quadraticCurveTo(midX, midY, goalNode.x, goalNode.y);
        
        ctx.strokeStyle = 'rgba(93, 230, 230, 0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Small dots along the line
        const dotCount = 3;
        for (let d = 0; d < dotCount; d++) {
          const progress = (d + 1) / (dotCount + 1);
          const dotX = node.x + (goalNode.x - node.x) * progress + Math.sin(t * 0.002 + i + d) * 10;
          const dotY = node.y + (goalNode.y - node.y) * progress + Math.cos(t * 0.002 + i + d) * 10;
          
          ctx.beginPath();
          ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(93, 230, 230, 0.4)';
          ctx.fill();
        }
      });
    }

    // Draw stars background
    const stars = [];
    function initStars() {
      for (let i = 0; i < 100; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 1.5,
          alpha: Math.random() * 0.5 + 0.2
        });
      }
    }

    function drawStars(ctx) {
      stars.forEach(star => {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
        ctx.fill();
      });
    }

    // Animation
    let animationTime = 0;

    function animate() {
      animationTime++;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background gradient
      const bgGradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, canvas.height
      );
      bgGradient.addColorStop(0, '#1a3040');
      bgGradient.addColorStop(0.5, '#0f2030');
      bgGradient.addColorStop(1, '#050a10');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      drawStars(ctx);

      // Connections
      drawConnections(ctx, animationTime);

      // Update and draw nodes
      nodes.forEach(node => {
        node.update(animationTime);
        node.draw(ctx);
      });

      requestAnimationFrame(animate);
    }

    // Initialize
    renderSubwayMap();
    initStars();
    initNodes();
    animate();

    // Reinitialize on resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      stars.length = 0;
      initStars();
      initNodes();
    });

    // Update progress bar dynamically
    let progress = 65;
    setInterval(() => {
      progress = 50 + Math.sin(Date.now() * 0.001) * 15;
      document.getElementById('progressFill').style.width = progress + '%';
    }, 100);
  </script>
</body>
</html>





