<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUTUS Physics Map</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --teal: #00d4aa;
      --teal-light: #00ffcc;
      --teal-glow: rgba(0, 212, 170, 0.4);
      --cyan: #00d4ff;
      --red: #ff4444;
      --red-dim: rgba(255, 68, 68, 0.3);
      --bg: #000000;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      color: #fff;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* ============================================ */
    /* ÏÉÅÎã®: ÎÖ∏ÏÑ†ÎèÑ (20%)                            */
    /* ============================================ */
    .route-layer {
      height: 20vh;
      position: relative;
      background: linear-gradient(180deg, rgba(0,20,15,0.8) 0%, transparent 100%);
      overflow: hidden;
    }

    .route-canvas {
      width: 100%;
      height: 100%;
    }

    /* ============================================ */
    /* Ï§ëÎã®: Physics Map (65%)                      */
    /* ============================================ */
    .physics-layer {
      height: 65vh;
      position: relative;
      overflow: hidden;
    }

    #physicsCanvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #physicsCanvas:active {
      cursor: grabbing;
    }

    /* Entity tooltip */
    .entity-tooltip {
      position: fixed;
      padding: 8px 14px;
      background: rgba(0, 20, 15, 0.95);
      border: 1px solid var(--teal);
      border-radius: 8px;
      font-size: 12px;
      color: var(--teal-light);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      box-shadow: 0 0 20px var(--teal-glow);
    }

    .entity-tooltip.visible {
      opacity: 1;
    }

    /* ============================================ */
    /* ÌïòÎã®: ÌîÑÎ°úÍ∑∏Î†àÏä§ Î∞î (15%)                     */
    /* ============================================ */
    .progress-layer {
      height: 15vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 10%;
      background: linear-gradient(0deg, rgba(0,20,15,0.8) 0%, transparent 100%);
    }

    .progress-container {
      width: 100%;
      max-width: 800px;
      position: relative;
    }

    .progress-track {
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: visible;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--teal), var(--teal-light));
      border-radius: 4px;
      width: 0%;
      transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      box-shadow: 0 0 20px var(--teal-glow), 0 0 40px var(--teal-glow);
    }

    .progress-glow {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      background: var(--teal-light);
      border-radius: 50%;
      filter: blur(8px);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; transform: translateY(-50%) scale(1); }
      50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
    }

    .progress-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- ÏÉÅÎã®: ÎÖ∏ÏÑ†ÎèÑ -->
    <div class="route-layer">
      <canvas class="route-canvas" id="routeCanvas"></canvas>
    </div>

    <!-- Ï§ëÎã®: Physics Map -->
    <div class="physics-layer">
      <canvas id="physicsCanvas"></canvas>
    </div>

    <!-- ÌïòÎã®: ÌîÑÎ°úÍ∑∏Î†àÏä§ Î∞î -->
    <div class="progress-layer">
      <div class="progress-container">
        <div class="progress-track">
          <div class="progress-fill" id="progressFill">
            <div class="progress-glow"></div>
          </div>
          <canvas class="progress-particles" id="progressParticles"></canvas>
        </div>
      </div>
    </div>

    <!-- Tooltip -->
    <div class="entity-tooltip" id="tooltip"></div>
  </div>

  <script>
    // ============================================
    // CONSTANTS
    // ============================================
    const TEAL = '#00d4aa';
    const TEAL_LIGHT = '#00ffcc';
    const CYAN = '#00d4ff';
    const RED = '#ff4444';

    // ============================================
    // ENTITY DATA (Ï∂îÏÉÅ ÏïÑÏù¥ÏΩò)
    // ============================================
    const ENTITY_TYPES = {
      book: { icon: 'üìö', label: 'Learning', positive: true },
      globe: { icon: 'üåç', label: 'Travel', positive: true },
      heart: { icon: 'üíö', label: 'Relations', positive: true },
      rocket: { icon: 'üöÄ', label: 'Career', positive: true },
      dollar: { icon: 'üí∞', label: 'Wealth', positive: true },
      clock: { icon: '‚è∞', label: 'Time', positive: false },
      cloud: { icon: '‚òÅÔ∏è', label: 'Uncertainty', positive: false },
      chain: { icon: '‚õìÔ∏è', label: 'Constraints', positive: false },
    };

    // ============================================
    // ROUTE CANVAS (ÏÉÅÎã® ÎÖ∏ÏÑ†ÎèÑ)
    // ============================================
    const routeCanvas = document.getElementById('routeCanvas');
    const routeCtx = routeCanvas.getContext('2d');

    function resizeRouteCanvas() {
      routeCanvas.width = routeCanvas.parentElement.clientWidth;
      routeCanvas.height = routeCanvas.parentElement.clientHeight;
    }
    resizeRouteCanvas();

    // Route nodes
    let routeNodes = [];
    let currentRouteIndex = 3;

    function initRouteNodes() {
      routeNodes = [];
      const count = 12;
      const startX = 60;
      const endX = routeCanvas.width - 60;
      const spacing = (endX - startX) / (count - 1);
      const baseY = routeCanvas.height / 2;

      for (let i = 0; i < count; i++) {
        routeNodes.push({
          x: startX + i * spacing,
          y: baseY + Math.sin(i * 0.8) * 15,
          isCurrent: i === currentRouteIndex,
          isPast: i < currentRouteIndex,
          isFuture: i > currentRouteIndex
        });
      }
    }

    // Route particles (ÎØ∏Îûò Í≤ΩÎ°ú)
    let routeParticles = [];

    function initRouteParticles() {
      routeParticles = [];
      for (let i = currentRouteIndex; i < routeNodes.length - 1; i++) {
        const from = routeNodes[i];
        const to = routeNodes[i + 1];
        for (let j = 0; j < 3; j++) {
          routeParticles.push({
            fromIndex: i,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.002
          });
        }
      }
    }

    function drawRoute(t) {
      routeCtx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);

      // Draw lines
      for (let i = 0; i < routeNodes.length - 1; i++) {
        const from = routeNodes[i];
        const to = routeNodes[i + 1];

        routeCtx.beginPath();
        routeCtx.moveTo(from.x, from.y);
        routeCtx.lineTo(to.x, to.y);

        if (i < currentRouteIndex) {
          routeCtx.strokeStyle = TEAL;
          routeCtx.lineWidth = 3;
          routeCtx.globalAlpha = 0.8;
        } else {
          routeCtx.strokeStyle = TEAL;
          routeCtx.lineWidth = 2;
          routeCtx.globalAlpha = 0.3;
        }
        routeCtx.stroke();
        routeCtx.globalAlpha = 1;
      }

      // Draw particles on future path
      routeParticles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) p.progress = 0;

        const from = routeNodes[p.fromIndex];
        const to = routeNodes[p.fromIndex + 1];
        const x = from.x + (to.x - from.x) * p.progress;
        const y = from.y + (to.y - from.y) * p.progress;

        routeCtx.beginPath();
        routeCtx.arc(x, y, 3, 0, Math.PI * 2);
        routeCtx.fillStyle = TEAL_LIGHT;
        routeCtx.globalAlpha = 0.6;
        routeCtx.fill();
        routeCtx.globalAlpha = 1;
      });

      // Draw nodes
      routeNodes.forEach((node, i) => {
        // Glow for current
        if (node.isCurrent) {
          const glowRadius = 20 + Math.sin(t * 0.003) * 5;
          const gradient = routeCtx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);
          gradient.addColorStop(0, 'rgba(0, 212, 170, 0.6)');
          gradient.addColorStop(1, 'rgba(0, 212, 170, 0)');
          routeCtx.beginPath();
          routeCtx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);
          routeCtx.fillStyle = gradient;
          routeCtx.fill();
        }

        // Node circle
        routeCtx.beginPath();
        routeCtx.arc(node.x, node.y, node.isCurrent ? 10 : 6, 0, Math.PI * 2);
        
        if (node.isPast) {
          routeCtx.fillStyle = TEAL;
          routeCtx.globalAlpha = 0.8;
        } else if (node.isCurrent) {
          routeCtx.fillStyle = TEAL_LIGHT;
          routeCtx.globalAlpha = 1;
        } else {
          routeCtx.fillStyle = TEAL;
          routeCtx.globalAlpha = 0.3;
        }
        routeCtx.fill();
        routeCtx.globalAlpha = 1;

        // Inner dot
        if (node.isCurrent) {
          routeCtx.beginPath();
          routeCtx.arc(node.x, node.y, 4, 0, Math.PI * 2);
          routeCtx.fillStyle = '#000';
          routeCtx.fill();
        }
      });
    }

    // ============================================
    // PHYSICS MAP (Ï§ëÎã®)
    // ============================================
    const physicsCanvas = document.getElementById('physicsCanvas');
    const physicsCtx = physicsCanvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    function resizePhysicsCanvas() {
      physicsCanvas.width = physicsCanvas.parentElement.clientWidth;
      physicsCanvas.height = physicsCanvas.parentElement.clientHeight;
    }
    resizePhysicsCanvas();

    // Goal orb
    let goalOrb = {
      x: 0, y: 0,
      radius: 70,
      label: 'GOAL',
      glow: 1.0
    };

    // Entities
    let entities = [];

    function initEntities() {
      const cx = physicsCanvas.width / 2;
      const cy = physicsCanvas.height / 2;
      goalOrb.x = cx;
      goalOrb.y = cy;

      entities = [];
      const types = Object.keys(ENTITY_TYPES);
      
      types.forEach((type, i) => {
        const angle = (i / types.length) * Math.PI * 2 - Math.PI / 2;
        const dist = 180 + Math.random() * 80;
        const data = ENTITY_TYPES[type];
        
        entities.push({
          id: type,
          x: cx + Math.cos(angle) * dist,
          y: cy + Math.sin(angle) * dist,
          radius: 35 + Math.random() * 15,
          icon: data.icon,
          label: data.label,
          positive: data.positive,
          dragging: false,
          influence: 0.5 + Math.random() * 0.5
        });
      });
    }

    // Connection calculation
    function getConnectionStrength(entity) {
      const dx = goalOrb.x - entity.x;
      const dy = goalOrb.y - entity.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = 400;
      return Math.max(0, 1 - dist / maxDist);
    }

    // Draw connections
    function drawConnections() {
      entities.forEach(entity => {
        const strength = getConnectionStrength(entity);
        const lineCount = Math.ceil(strength * 4);
        
        for (let i = 0; i < lineCount; i++) {
          const offset = (i - lineCount / 2) * 8;
          const midX = (entity.x + goalOrb.x) / 2;
          const midY = (entity.y + goalOrb.y) / 2 + offset;

          physicsCtx.beginPath();
          physicsCtx.moveTo(entity.x, entity.y);
          physicsCtx.quadraticCurveTo(midX, midY, goalOrb.x, goalOrb.y);

          if (entity.positive) {
            physicsCtx.strokeStyle = `rgba(0, 212, 255, ${0.1 + strength * 0.4})`;
            physicsCtx.lineWidth = 1 + strength * 2;
          } else {
            physicsCtx.strokeStyle = `rgba(255, 68, 68, ${0.1 + strength * 0.3})`;
            physicsCtx.lineWidth = 0.5 + strength;
          }
          physicsCtx.stroke();
        }
      });
    }

    // Draw goal orb
    function drawGoalOrb(t) {
      // Calculate glow based on positive entities proximity
      let positiveInfluence = 0;
      let negativeInfluence = 0;
      
      entities.forEach(e => {
        const strength = getConnectionStrength(e);
        if (e.positive) positiveInfluence += strength * e.influence;
        else negativeInfluence += strength * e.influence;
      });
      
      goalOrb.glow = 0.5 + positiveInfluence * 0.3 - negativeInfluence * 0.2;
      goalOrb.glow = Math.max(0.3, Math.min(1.2, goalOrb.glow));

      // Outer glow
      const glowSize = goalOrb.radius * 2 * goalOrb.glow;
      const gradient = physicsCtx.createRadialGradient(
        goalOrb.x, goalOrb.y, goalOrb.radius * 0.5,
        goalOrb.x, goalOrb.y, glowSize
      );
      gradient.addColorStop(0, `rgba(0, 212, 170, ${0.4 * goalOrb.glow})`);
      gradient.addColorStop(0.5, `rgba(0, 212, 170, ${0.1 * goalOrb.glow})`);
      gradient.addColorStop(1, 'rgba(0, 212, 170, 0)');

      physicsCtx.beginPath();
      physicsCtx.arc(goalOrb.x, goalOrb.y, glowSize, 0, Math.PI * 2);
      physicsCtx.fillStyle = gradient;
      physicsCtx.fill();

      // Pulsing ring
      const pulseRadius = goalOrb.radius + Math.sin(t * 0.002) * 10;
      physicsCtx.beginPath();
      physicsCtx.arc(goalOrb.x, goalOrb.y, pulseRadius, 0, Math.PI * 2);
      physicsCtx.strokeStyle = `rgba(0, 255, 204, ${0.3 * goalOrb.glow})`;
      physicsCtx.lineWidth = 2;
      physicsCtx.stroke();

      // Main orb
      const orbGradient = physicsCtx.createRadialGradient(
        goalOrb.x - goalOrb.radius * 0.3, goalOrb.y - goalOrb.radius * 0.3, 0,
        goalOrb.x, goalOrb.y, goalOrb.radius
      );
      orbGradient.addColorStop(0, `rgba(0, 255, 220, ${0.9 * goalOrb.glow})`);
      orbGradient.addColorStop(0.5, `rgba(0, 212, 170, ${0.8 * goalOrb.glow})`);
      orbGradient.addColorStop(1, `rgba(0, 150, 120, ${0.6 * goalOrb.glow})`);

      physicsCtx.beginPath();
      physicsCtx.arc(goalOrb.x, goalOrb.y, goalOrb.radius, 0, Math.PI * 2);
      physicsCtx.fillStyle = orbGradient;
      physicsCtx.fill();

      // Label
      physicsCtx.font = 'bold 24px -apple-system, sans-serif';
      physicsCtx.fillStyle = '#000';
      physicsCtx.textAlign = 'center';
      physicsCtx.textBaseline = 'middle';
      physicsCtx.fillText(goalOrb.label, goalOrb.x, goalOrb.y);
    }

    // Draw entities
    function drawEntities() {
      entities.forEach(entity => {
        const strength = getConnectionStrength(entity);
        const scale = 0.8 + strength * 0.4;
        const radius = entity.radius * scale;

        // Glow
        const gradient = physicsCtx.createRadialGradient(
          entity.x, entity.y, radius * 0.3,
          entity.x, entity.y, radius * 1.5
        );
        
        if (entity.positive) {
          gradient.addColorStop(0, `rgba(0, 212, 170, ${0.3 + strength * 0.3})`);
          gradient.addColorStop(1, 'rgba(0, 212, 170, 0)');
        } else {
          gradient.addColorStop(0, `rgba(255, 68, 68, ${0.2 + strength * 0.2})`);
          gradient.addColorStop(1, 'rgba(255, 68, 68, 0)');
        }

        physicsCtx.beginPath();
        physicsCtx.arc(entity.x, entity.y, radius * 1.5, 0, Math.PI * 2);
        physicsCtx.fillStyle = gradient;
        physicsCtx.fill();

        // Circle
        physicsCtx.beginPath();
        physicsCtx.arc(entity.x, entity.y, radius, 0, Math.PI * 2);
        physicsCtx.fillStyle = entity.positive 
          ? `rgba(0, 40, 35, ${0.7 + strength * 0.3})`
          : `rgba(40, 20, 20, ${0.7 + strength * 0.3})`;
        physicsCtx.fill();

        physicsCtx.strokeStyle = entity.positive ? TEAL : RED;
        physicsCtx.lineWidth = entity.dragging ? 3 : 1.5;
        physicsCtx.globalAlpha = 0.5 + strength * 0.5;
        physicsCtx.stroke();
        physicsCtx.globalAlpha = 1;

        // Icon
        physicsCtx.font = `${radius * 0.8}px Arial`;
        physicsCtx.textAlign = 'center';
        physicsCtx.textBaseline = 'middle';
        physicsCtx.fillText(entity.icon, entity.x, entity.y);
      });
    }

    // Background particles
    let bgParticles = [];

    function initBgParticles() {
      bgParticles = [];
      for (let i = 0; i < 50; i++) {
        bgParticles.push({
          x: Math.random() * physicsCanvas.width,
          y: Math.random() * physicsCanvas.height,
          size: Math.random() * 2,
          speed: 0.2 + Math.random() * 0.3,
          alpha: Math.random() * 0.3
        });
      }
    }

    function drawBgParticles() {
      bgParticles.forEach(p => {
        p.y -= p.speed;
        if (p.y < 0) {
          p.y = physicsCanvas.height;
          p.x = Math.random() * physicsCanvas.width;
        }

        physicsCtx.beginPath();
        physicsCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        physicsCtx.fillStyle = `rgba(0, 212, 170, ${p.alpha})`;
        physicsCtx.fill();
      });
    }

    // Draw physics map
    function drawPhysicsMap(t) {
      physicsCtx.clearRect(0, 0, physicsCanvas.width, physicsCanvas.height);

      // Background gradient
      const bgGrad = physicsCtx.createRadialGradient(
        goalOrb.x, goalOrb.y, 0,
        goalOrb.x, goalOrb.y, physicsCanvas.height
      );
      bgGrad.addColorStop(0, 'rgba(0, 30, 25, 0.3)');
      bgGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      physicsCtx.fillStyle = bgGrad;
      physicsCtx.fillRect(0, 0, physicsCanvas.width, physicsCanvas.height);

      drawBgParticles();
      drawConnections();
      drawGoalOrb(t);
      drawEntities();
    }

    // ============================================
    // DRAG INTERACTION
    // ============================================
    let draggedEntity = null;
    let dragOffset = { x: 0, y: 0 };

    function getMousePos(e) {
      const rect = physicsCanvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (physicsCanvas.width / rect.width),
        y: (e.clientY - rect.top) * (physicsCanvas.height / rect.height)
      };
    }

    function findEntityAt(pos) {
      for (let i = entities.length - 1; i >= 0; i--) {
        const e = entities[i];
        const dx = pos.x - e.x;
        const dy = pos.y - e.y;
        if (dx * dx + dy * dy < e.radius * e.radius) {
          return e;
        }
      }
      return null;
    }

    physicsCanvas.addEventListener('mousedown', e => {
      const pos = getMousePos(e);
      const entity = findEntityAt(pos);
      if (entity) {
        draggedEntity = entity;
        draggedEntity.dragging = true;
        dragOffset.x = pos.x - entity.x;
        dragOffset.y = pos.y - entity.y;
      }
    });

    physicsCanvas.addEventListener('mousemove', e => {
      const pos = getMousePos(e);

      // Tooltip
      const hovered = findEntityAt(pos);
      if (hovered) {
        tooltip.textContent = hovered.label;
        tooltip.style.left = e.clientX + 15 + 'px';
        tooltip.style.top = e.clientY + 15 + 'px';
        tooltip.classList.add('visible');
      } else {
        tooltip.classList.remove('visible');
      }

      // Drag
      if (draggedEntity) {
        draggedEntity.x = pos.x - dragOffset.x;
        draggedEntity.y = pos.y - dragOffset.y;

        // Clamp to bounds
        const margin = draggedEntity.radius;
        draggedEntity.x = Math.max(margin, Math.min(physicsCanvas.width - margin, draggedEntity.x));
        draggedEntity.y = Math.max(margin, Math.min(physicsCanvas.height - margin, draggedEntity.y));

        updateProgress();
        updateRoute();
      }
    });

    physicsCanvas.addEventListener('mouseup', () => {
      if (draggedEntity) {
        draggedEntity.dragging = false;
        draggedEntity = null;
      }
    });

    physicsCanvas.addEventListener('mouseleave', () => {
      tooltip.classList.remove('visible');
      if (draggedEntity) {
        draggedEntity.dragging = false;
        draggedEntity = null;
      }
    });

    // ============================================
    // PROGRESS BAR
    // ============================================
    const progressFill = document.getElementById('progressFill');
    const progressParticlesCanvas = document.getElementById('progressParticles');
    const progressCtx = progressParticlesCanvas.getContext('2d');

    function resizeProgressCanvas() {
      const rect = progressParticlesCanvas.parentElement.getBoundingClientRect();
      progressParticlesCanvas.width = rect.width;
      progressParticlesCanvas.height = rect.height;
    }
    resizeProgressCanvas();

    let progressParticles = [];

    function updateProgress() {
      // Calculate progress based on positive vs negative
      let positiveTotal = 0;
      let negativeTotal = 0;

      entities.forEach(e => {
        const strength = getConnectionStrength(e);
        if (e.positive) positiveTotal += strength * e.influence;
        else negativeTotal += strength * e.influence;
      });

      const progress = Math.max(0, Math.min(100, (positiveTotal / 3) * 100 - negativeTotal * 20));
      progressFill.style.width = progress + '%';

      // Spawn particles when progress increases
      if (progress > 50 && Math.random() < 0.1) {
        progressParticles.push({
          x: progressFill.offsetWidth,
          y: Math.random() * 20 - 10,
          vx: Math.random() * 2 - 1,
          vy: -Math.random() * 2 - 1,
          life: 1
        });
      }
    }

    function drawProgressParticles() {
      progressCtx.clearRect(0, 0, progressParticlesCanvas.width, progressParticlesCanvas.height);

      progressParticles = progressParticles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;

        if (p.life > 0) {
          progressCtx.beginPath();
          progressCtx.arc(p.x, progressParticlesCanvas.height / 2 + p.y, 3, 0, Math.PI * 2);
          progressCtx.fillStyle = `rgba(0, 255, 204, ${p.life})`;
          progressCtx.fill();
          return true;
        }
        return false;
      });
    }

    // ============================================
    // ROUTE UPDATE
    // ============================================
    function updateRoute() {
      // Adjust route based on entity positions
      const positiveStrength = entities
        .filter(e => e.positive)
        .reduce((sum, e) => sum + getConnectionStrength(e), 0);

      // More positive = route straightens
      routeNodes.forEach((node, i) => {
        if (i > currentRouteIndex) {
          const baseY = routeCanvas.height / 2;
          const variance = Math.sin(i * 0.8) * 15;
          const straightenFactor = Math.min(1, positiveStrength / 2);
          node.y = baseY + variance * (1 - straightenFactor * 0.7);
        }
      });
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let time = 0;

    function animate() {
      time++;
      
      drawRoute(time);
      drawPhysicsMap(time);
      drawProgressParticles();

      requestAnimationFrame(animate);
    }

    // ============================================
    // INIT
    // ============================================
    function init() {
      initRouteNodes();
      initRouteParticles();
      initEntities();
      initBgParticles();
      updateProgress();
      animate();
    }

    window.addEventListener('resize', () => {
      resizeRouteCanvas();
      resizePhysicsCanvas();
      resizeProgressCanvas();
      initRouteNodes();
      initRouteParticles();
      initEntities();
      initBgParticles();
    });

    init();
  </script>
</body>
</html>





