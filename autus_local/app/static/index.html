<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AUTUS - Teal Core Loop</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Rajdhani:wght@300;400;500&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --teal: #00FFCC;
      --teal-dim: rgba(0, 255, 204, 0.3);
      --red: #FF4444;
      --orange: #FF8800;
      --blue: #00AAFF;
      --bg: #0a0f14;
      --panel-bg: rgba(0, 20, 30, 0.85);
    }

    html, body {
      height: 100%;
      background: var(--bg);
      font-family: 'Rajdhani', sans-serif;
      color: #fff;
      overflow: hidden;
    }

    #canvas3d {
      position: fixed;
      inset: 0;
      z-index: 1;
      cursor: pointer;
    }

    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }
    .hud > * { pointer-events: auto; }

    /* Top Bar */
    .top-bar {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 24px;
      background: linear-gradient(180deg, rgba(0,20,30,0.9) 0%, transparent 100%);
    }

    .logo {
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      letter-spacing: 3px;
      color: var(--teal);
    }

    .page-indicator {
      display: flex;
      gap: 8px;
    }

    .page-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transition: all 0.3s;
    }

    .page-dot.active {
      background: var(--teal);
      box-shadow: 0 0 10px var(--teal);
    }

    /* Physics Display - Left */
    .physics-left {
      position: absolute;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
    }

    .physics-item {
      margin: 16px 0;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    .physics-item:hover { opacity: 1; }

    .physics-label {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .physics-value {
      font-family: 'Orbitron', monospace;
      font-size: 18px;
      color: var(--teal);
    }

    .physics-bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.1);
      margin-top: 4px;
      border-radius: 2px;
      overflow: hidden;
    }

    .physics-bar-fill {
      height: 100%;
      background: var(--teal);
      transition: width 0.3s;
    }

    /* Physics Display - Right */
    .physics-right {
      position: absolute;
      right: 24px;
      top: 50%;
      transform: translateY(-50%);
      text-align: right;
    }

    /* Sigma Zone Indicator */
    .sigma-zone {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 20px;
      background: var(--panel-bg);
      border: 1px solid var(--teal-dim);
      border-radius: 20px;
      font-family: 'Orbitron', monospace;
      font-size: 11px;
    }

    .sigma-zone.high {
      border-color: var(--red);
      color: var(--red);
    }

    .sigma-zone.mid {
      border-color: var(--orange);
      color: var(--orange);
    }

    /* Tap Feedback */
    .tap-feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      background: var(--panel-bg);
      border: 1px solid var(--teal);
      border-radius: 12px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .tap-feedback.visible { opacity: 1; }

    .tap-feedback-label {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 4px;
    }

    .tap-feedback-value {
      font-family: 'Orbitron', monospace;
      font-size: 28px;
      color: var(--teal);
    }

    /* Bottom Controls */
    .bottom-bar {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 24px;
      background: linear-gradient(0deg, rgba(0,20,30,0.9) 0%, transparent 100%);
    }

    .action-btn {
      padding: 12px 28px;
      background: transparent;
      border: 1px solid var(--teal-dim);
      border-radius: 8px;
      color: var(--teal);
      font-family: 'Orbitron', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .action-btn:hover {
      background: var(--teal-dim);
      border-color: var(--teal);
    }

    .action-btn.active {
      background: var(--teal);
      color: #000;
    }

    /* No Judgment Notice */
    .no-judgment {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: rgba(255,255,255,0.3);
      letter-spacing: 1px;
    }

    /* Consent Modal */
    .consent-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .consent-modal.visible { display: flex; }

    .consent-box {
      background: var(--panel-bg);
      border: 1px solid var(--teal);
      border-radius: 16px;
      padding: 32px;
      text-align: center;
      max-width: 360px;
    }

    .consent-title {
      font-family: 'Orbitron', monospace;
      font-size: 12px;
      color: var(--teal);
      margin-bottom: 20px;
    }

    .consent-physics {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
    }

    .consent-row {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 12px;
    }

    .consent-row span:first-child { color: rgba(255,255,255,0.5); }
    .consent-row span:last-child { 
      font-family: 'Orbitron', monospace;
      color: var(--teal);
    }

    .consent-notice {
      font-size: 9px;
      color: rgba(255,255,255,0.4);
      margin: 16px 0;
      padding: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }

    .consent-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .consent-btn {
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      font-family: 'Orbitron', monospace;
      font-size: 10px;
      cursor: pointer;
    }

    .consent-btn.confirm {
      background: var(--teal);
      color: #000;
    }

    .consent-btn.cancel {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.3);
      color: rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <div id="canvas3d"></div>

  <div class="hud">
    <!-- Top Bar -->
    <div class="top-bar">
      <div class="logo">AUTUS</div>
      <div class="page-indicator">
        <div class="page-dot active"></div>
        <div class="page-dot"></div>
        <div class="page-dot"></div>
      </div>
    </div>

    <!-- Left Physics -->
    <div class="physics-left">
      <div class="physics-item">
        <div class="physics-label">σ ENTROPY</div>
        <div class="physics-value" id="sigmaVal">0.300</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="sigmaBar" style="width:30%"></div></div>
      </div>
      <div class="physics-item">
        <div class="physics-label">STABILITY</div>
        <div class="physics-value" id="stabVal">0.500</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="stabBar" style="width:50%"></div></div>
      </div>
      <div class="physics-item">
        <div class="physics-label">MOMENTUM</div>
        <div class="physics-value" id="momVal">0.000</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="momBar" style="width:0%"></div></div>
      </div>
    </div>

    <!-- Right Physics -->
    <div class="physics-right">
      <div class="physics-item">
        <div class="physics-label">RECOVERY</div>
        <div class="physics-value" id="recVal">0.100</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="recBar" style="width:10%"></div></div>
      </div>
      <div class="physics-item">
        <div class="physics-label">DENSITY</div>
        <div class="physics-value" id="densVal">0.500</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="densBar" style="width:50%"></div></div>
      </div>
      <div class="physics-item">
        <div class="physics-label">r RADIUS</div>
        <div class="physics-value" id="radiusVal">1.000</div>
        <div class="physics-bar"><div class="physics-bar-fill" id="radiusBar" style="width:100%"></div></div>
      </div>
    </div>

    <!-- Sigma Zone -->
    <div class="sigma-zone" id="sigmaZone">σ = 0.300</div>

    <!-- Tap Feedback -->
    <div class="tap-feedback" id="tapFeedback">
      <div class="tap-feedback-label">STABILITY</div>
      <div class="tap-feedback-value" id="tapValue">0.500</div>
    </div>

    <!-- No Judgment Notice -->
    <div class="no-judgment">[NO JUDGMENT PROVIDED] • NUMBERS ONLY</div>

    <!-- Bottom Controls -->
    <div class="bottom-bar">
      <button class="action-btn" id="pushBtn" data-motion="U001">PUSH</button>
      <button class="action-btn active" id="holdBtn" data-motion="U002">HOLD</button>
      <button class="action-btn" id="driftBtn" data-motion="U003">DRIFT</button>
    </div>
  </div>

  <!-- Consent Modal -->
  <div class="consent-modal" id="consentModal">
    <div class="consent-box">
      <div class="consent-title">CONSENT REQUIRED</div>
      <div class="consent-physics">
        <div class="consent-row">
          <span>Motion</span>
          <span id="consentMotion">U001</span>
        </div>
        <div class="consent-row">
          <span>Δσ</span>
          <span id="consentSigma">+0.050</span>
        </div>
        <div class="consent-row">
          <span>ΔStability</span>
          <span id="consentStab">-0.100</span>
        </div>
        <div class="consent-row">
          <span>ΔRecovery</span>
          <span id="consentRec">+0.000</span>
        </div>
      </div>
      <div class="consent-notice">[NO RECOMMENDATION PROVIDED]<br>User decides. System displays physics only.</div>
      <div class="consent-buttons">
        <button class="consent-btn cancel" id="consentCancel">CANCEL</button>
        <button class="consent-btn confirm" id="consentConfirm">CONFIRM</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // AUTUS TEAL CORE LOOP
    // Physics Visualization (No Judgment)
    // ============================================

    const TEAL = 0x00FFCC;
    const RED = 0xFF4444;
    const ORANGE = 0xFF8800;
    const BLUE = 0x00AAFF;

    // Physics State
    const state = {
      sigma: 0.3,       // Entropy
      stability: 0.5,   // Stability
      momentum: 0.0,    // Momentum
      recovery: 0.1,    // Recovery
      density: 0.5,     // Density
      r: 1.0,           // Goal radius
      step: 0
    };

    // Motion Effects (from Kernel)
    const MOTION_EFFECTS = {
      'U001': { sigma: +0.05, stability: -0.1, recovery: 0, name: 'PUSH' },
      'U002': { sigma: 0, stability: +0.05, recovery: +0.02, name: 'HOLD' },
      'U003': { sigma: +0.02, stability: 0, recovery: +0.03, name: 'DRIFT' }
    };

    // Three.js Setup
    const container = document.getElementById('canvas3d');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 6);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // ============================================
    // ORB - Goal Radius Visualization
    // ============================================
    const orbGroup = new THREE.Group();
    
    // Core Orb
    const orbGeom = new THREE.SphereGeometry(1, 64, 64);
    const orbMat = new THREE.MeshBasicMaterial({
      color: TEAL,
      transparent: true,
      opacity: 0.15,
    });
    const orb = new THREE.Mesh(orbGeom, orbMat);
    orbGroup.add(orb);

    // Inner Core (Density)
    const coreGeom = new THREE.SphereGeometry(0.3, 32, 32);
    const coreMat = new THREE.MeshBasicMaterial({
      color: TEAL,
      transparent: true,
      opacity: 0.8,
    });
    const core = new THREE.Mesh(coreGeom, coreMat);
    orbGroup.add(core);

    // Glow
    const glowGeom = new THREE.SphereGeometry(1.2, 32, 32);
    const glowMat = new THREE.MeshBasicMaterial({
      color: TEAL,
      transparent: true,
      opacity: 0.05,
      side: THREE.BackSide
    });
    orbGroup.add(new THREE.Mesh(glowGeom, glowMat));

    scene.add(orbGroup);

    // ============================================
    // RINGS - Momentum Visualization
    // ============================================
    const ringGroup = new THREE.Group();
    
    const ringGeom = new THREE.TorusGeometry(1.5, 0.02, 16, 100);
    const ringMat = new THREE.MeshBasicMaterial({ color: TEAL, transparent: true, opacity: 0.6 });
    
    const ring1 = new THREE.Mesh(ringGeom, ringMat);
    ring1.rotation.x = Math.PI / 2;
    ringGroup.add(ring1);

    const ring2 = new THREE.Mesh(ringGeom, ringMat.clone());
    ring2.rotation.x = Math.PI / 2;
    ring2.rotation.y = Math.PI / 6;
    ringGroup.add(ring2);

    const ring3 = new THREE.Mesh(ringGeom, ringMat.clone());
    ring3.rotation.x = Math.PI / 2;
    ring3.rotation.y = -Math.PI / 6;
    ringGroup.add(ring3);

    // 2.5D tilt
    ringGroup.rotation.x = Math.PI / 6;
    scene.add(ringGroup);

    // ============================================
    // PARTICLES - Entropy (σ) Visualization
    // ============================================
    const particleCount = 800;
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities = [];

    for (let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 1 + Math.random() * 0.5;
      
      particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      particlePositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      particlePositions[i * 3 + 2] = r * Math.cos(phi);
      
      particleVelocities.push({
        vx: (Math.random() - 0.5) * 0.01,
        vy: (Math.random() - 0.5) * 0.01,
        vz: (Math.random() - 0.5) * 0.01
      });
    }

    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particleMat = new THREE.PointsMaterial({
      color: TEAL,
      size: 0.03,
      transparent: true,
      opacity: 0.6
    });
    const particles = new THREE.Points(particleGeom, particleMat);
    scene.add(particles);

    // ============================================
    // WAVE RINGS - Recovery Feedback
    // ============================================
    const waveRings = [];
    
    function emitWave() {
      const waveGeom = new THREE.RingGeometry(0.1, 0.15, 64);
      const waveMat = new THREE.MeshBasicMaterial({
        color: TEAL,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const wave = new THREE.Mesh(waveGeom, waveMat);
      wave.rotation.x = -Math.PI / 2;
      wave.userData = { scale: 0.1, opacity: 0.8 };
      scene.add(wave);
      waveRings.push(wave);
    }

    // ============================================
    // BACKGROUND STARS
    // ============================================
    const starGeom = new THREE.BufferGeometry();
    const starPos = new Float32Array(500 * 3);
    for (let i = 0; i < 500; i++) {
      starPos[i * 3] = (Math.random() - 0.5) * 40;
      starPos[i * 3 + 1] = (Math.random() - 0.5) * 40;
      starPos[i * 3 + 2] = (Math.random() - 0.5) * 40;
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.3 });
    scene.add(new THREE.Points(starGeom, starMat));

    // ============================================
    // UPDATE FUNCTIONS
    // ============================================

    function updateUI() {
      // Left panel
      document.getElementById('sigmaVal').textContent = state.sigma.toFixed(3);
      document.getElementById('sigmaBar').style.width = (state.sigma * 100) + '%';
      
      document.getElementById('stabVal').textContent = state.stability.toFixed(3);
      document.getElementById('stabBar').style.width = (state.stability * 100) + '%';
      
      document.getElementById('momVal').textContent = Math.abs(state.momentum).toFixed(3);
      document.getElementById('momBar').style.width = (Math.abs(state.momentum) * 100) + '%';
      
      // Right panel
      document.getElementById('recVal').textContent = state.recovery.toFixed(3);
      document.getElementById('recBar').style.width = (state.recovery * 100) + '%';
      
      document.getElementById('densVal').textContent = state.density.toFixed(3);
      document.getElementById('densBar').style.width = (state.density * 100) + '%';
      
      document.getElementById('radiusVal').textContent = state.r.toFixed(3);
      document.getElementById('radiusBar').style.width = (state.r * 100) + '%';
      
      // Sigma zone indicator
      const sigmaZone = document.getElementById('sigmaZone');
      sigmaZone.textContent = `σ = ${state.sigma.toFixed(3)}`;
      sigmaZone.classList.remove('high', 'mid');
      if (state.sigma > 0.6) {
        sigmaZone.classList.add('high');
      } else if (state.sigma > 0.3) {
        sigmaZone.classList.add('mid');
      }
    }

    function update3D() {
      // Orb size = r (goal radius)
      const orbScale = 0.5 + state.r * 0.5;
      orb.scale.setScalar(orbScale);
      
      // Core intensity = density
      coreMat.opacity = 0.3 + state.density * 0.7;
      const coreScale = 0.2 + state.density * 0.3;
      core.scale.setScalar(coreScale);
      
      // Ring rotation = momentum
      const baseSpeed = 0.002;
      const momentumSpeed = state.momentum * 0.02;
      ringGroup.rotation.y += baseSpeed + momentumSpeed;
      ringGroup.rotation.z += (baseSpeed + momentumSpeed) * 0.3;
      
      // Particle spread = sigma
      const positions = particles.geometry.attributes.position.array;
      const spread = 1 + state.sigma * 2;
      
      for (let i = 0; i < particleCount; i++) {
        const vel = particleVelocities[i];
        const idx = i * 3;
        
        // Move particles
        positions[idx] += vel.vx * spread;
        positions[idx + 1] += vel.vy * spread;
        positions[idx + 2] += vel.vz * spread;
        
        // Keep in bounds
        const dist = Math.sqrt(
          positions[idx] ** 2 + 
          positions[idx + 1] ** 2 + 
          positions[idx + 2] ** 2
        );
        
        if (dist > spread * 2 || dist < 0.5) {
          vel.vx *= -1;
          vel.vy *= -1;
          vel.vz *= -1;
        }
      }
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Particle color based on sigma (no judgment, just physics)
      if (state.sigma > 0.6) {
        particleMat.color.setHex(RED);
      } else if (state.sigma > 0.3) {
        particleMat.color.setHex(ORANGE);
      } else {
        particleMat.color.setHex(TEAL);
      }
      
      // Wave rings animation (recovery visualization)
      for (let i = waveRings.length - 1; i >= 0; i--) {
        const wave = waveRings[i];
        wave.userData.scale += state.recovery * 0.1;
        wave.userData.opacity -= 0.02;
        
        wave.scale.setScalar(wave.userData.scale);
        wave.material.opacity = wave.userData.opacity;
        
        if (wave.userData.opacity <= 0) {
          scene.remove(wave);
          waveRings.splice(i, 1);
        }
      }
    }

    // ============================================
    // MOTION EXECUTION
    // ============================================

    let pendingMotion = null;

    function showConsent(motionId) {
      pendingMotion = motionId;
      const effects = MOTION_EFFECTS[motionId];
      
      document.getElementById('consentMotion').textContent = motionId;
      document.getElementById('consentSigma').textContent = 
        (effects.sigma >= 0 ? '+' : '') + effects.sigma.toFixed(3);
      document.getElementById('consentStab').textContent = 
        (effects.stability >= 0 ? '+' : '') + effects.stability.toFixed(3);
      document.getElementById('consentRec').textContent = 
        (effects.recovery >= 0 ? '+' : '') + effects.recovery.toFixed(3);
      
      document.getElementById('consentModal').classList.add('visible');
    }

    function hideConsent() {
      document.getElementById('consentModal').classList.remove('visible');
      pendingMotion = null;
    }

    function executeMotion(motionId) {
      const effects = MOTION_EFFECTS[motionId];
      
      // Apply effects (clamped)
      state.sigma = Math.max(0, Math.min(1, state.sigma + effects.sigma));
      state.stability = Math.max(0, Math.min(1, state.stability + effects.stability));
      state.recovery = Math.max(0, state.recovery + effects.recovery);
      
      // Update momentum based on action
      if (motionId === 'U001') state.momentum = Math.min(1, state.momentum + 0.2);
      if (motionId === 'U002') state.momentum *= 0.9;
      if (motionId === 'U003') state.momentum = Math.max(0, state.momentum - 0.1);
      
      // Update density
      state.density = state.stability * (1 - state.sigma * 0.5);
      
      state.step++;
      updateUI();
      
      // Emit wave on any action
      emitWave();
    }

    // Button handlers
    document.querySelectorAll('.action-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        showConsent(btn.dataset.motion);
      });
    });

    document.getElementById('consentConfirm').addEventListener('click', () => {
      if (pendingMotion) {
        executeMotion(pendingMotion);
        
        // Update button states
        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`[data-motion="${pendingMotion}"]`).classList.add('active');
      }
      hideConsent();
    });

    document.getElementById('consentCancel').addEventListener('click', hideConsent);

    // Tap feedback on orb
    container.addEventListener('click', (e) => {
      const rect = container.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      
      // Check if click is near center (orb area)
      if (Math.abs(x) < 0.3 && Math.abs(y) < 0.3) {
        // Show stability value (no judgment)
        const feedback = document.getElementById('tapFeedback');
        document.getElementById('tapValue').textContent = state.stability.toFixed(3);
        feedback.classList.add('visible');
        
        // Emit wave (recovery visualization)
        emitWave();
        
        setTimeout(() => {
          feedback.classList.remove('visible');
        }, 1500);
      }
    });

    // ============================================
    // ANIMATION LOOP
    // ============================================

    function animate() {
      requestAnimationFrame(animate);
      update3D();
      renderer.render(scene, camera);
    }

    animate();
    updateUI();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Periodic decay (physics simulation)
    setInterval(() => {
      // Natural entropy decay
      state.sigma *= 0.998;
      // Stability recovery
      state.stability = Math.min(1, state.stability + state.recovery * 0.001);
      // Momentum decay
      state.momentum *= 0.995;
      // Update density
      state.density = state.stability * (1 - state.sigma * 0.5);
      
      updateUI();
    }, 100);
  </script>
</body>
</html>






