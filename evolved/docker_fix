"""
Docker Fix - Main module for fixing common Docker issues.

This module provides utilities to diagnose and fix common Docker problems
such as container issues, network problems, and resource management.
"""

import logging
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import docker
from docker.errors import DockerException, NotFound, APIError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class DockerFix:
    """Main class for Docker diagnostics and fixes."""
    
    def __init__(self) -> None:
        """Initialize DockerFix with Docker client."""
        try:
            self.client = docker.from_env()
            self.client.ping()
            logger.info("Docker client initialized successfully")
        except DockerException as e:
            logger.error(f"Failed to initialize Docker client: {e}")
            raise
    
    def diagnose_system(self) -> Dict[str, Union[bool, str]]:
        """
        Perform comprehensive Docker system diagnosis.
        
        Returns:
            Dict containing diagnosis results with status and messages.
        """
        diagnosis = {
            "docker_running": False,
            "disk_space": False,
            "containers_status": False,
            "networks_status": False,
            "images_status": False,
            "daemon_logs": ""
        }
        
        try:
            # Check if Docker daemon is running
            self.client.ping()
            diagnosis["docker_running"] = True
            logger.info("Docker daemon is running")
            
            # Check disk space
            diagnosis["disk_space"] = self._check_disk_space()
            
            # Check containers
            diagnosis["containers_status"] = self._check_containers()
            
            # Check networks
            diagnosis["networks_status"] = self._check_networks()
            
            # Check images
            diagnosis["images_status"] = self._check_images()
            
            # Get daemon logs
            diagnosis["daemon_logs"] = self._get_daemon_logs()
            
        except DockerException as e:
            logger.error(f"System diagnosis failed: {e}")
            diagnosis["daemon_logs"] = str(e)
        
        return diagnosis
    
    def fix_common_issues(self) -> Dict[str, bool]:
        """
        Attempt to fix common Docker issues automatically.
        
        Returns:
            Dict with fix results for each attempted repair.
        """
        fixes = {
            "pruned_containers": False,
            "pruned_images": False,
            "pruned_networks": False,
            "pruned_volumes": False,
            "restarted_daemon": False
        }
        
        try:
            # Prune stopped containers
            fixes["pruned_containers"] = self._prune_containers()
            
            # Prune unused images
            fixes["pruned_images"] = self._prune_images()
            
            # Prune unused networks
            fixes["pruned_networks"] = self._prune_networks()
            
            # Prune unused volumes
            fixes["pruned_volumes"] = self._prune_volumes()
            
        except DockerException as e:
            logger.error(f"Failed to apply fixes: {e}")
        
        return fixes
    
    def restart_container(self, container_name: str) -> bool:
        """
        Restart a specific container.
        
        Args:
            container_name: Name or ID of the container to restart.
            
        Returns:
            True if restart was successful, False otherwise.
        """
        try:
            container = self.client.containers.get(container_name)
            container.restart()
            logger.info(f"Container {container_name} restarted successfully")
            return True
        except NotFound:
            logger.error(f"Container {container_name} not found")
            return False
        except APIError as e:
            logger.error(f"Failed to restart container {container_name}: {e}")
            return False
    
    def get_container_logs(self, container_name: str, tail: int = 100) -> Optional[str]:
        """
        Get logs from a specific container.
        
        Args:
            container_name: Name or ID of the container.
            tail: Number of lines to retrieve from the end of logs.
            
        Returns:
            Container logs as string, or None if failed.
        """
        try:
            container = self.client.containers.get(container_name)
            logs = container.logs(tail=tail, timestamps=True).decode('utf-8')
            return logs
        except NotFound:
            logger.error(f"Container {container_name} not found")
            return None
        except APIError as e:
            logger.error(f"Failed to get logs for {container_name}: {e}")
            return None
    
    def list_containers(self, all_containers: bool = True) -> List[Dict[str, str]]:
        """
        List all containers with their status.
        
        Args:
            all_containers: If True, include stopped containers.
            
        Returns:
            List of dictionaries containing container information.
        """
        containers_info = []
        try:
            containers = self.client.containers.list(all=all_containers)
            for container in containers:
                info = {
                    "id": container.short_id,
                    "name": container.name,
                    "status": container.status,
                    "image": container.image.tags[0] if container.image.tags else "unknown"
                }
                containers_info.append(info)
        except APIError as e:
            logger.error(f"Failed to list containers: {e}")
        
        return containers_info
    
    def _check_disk_space(self) -> bool:
        """Check if there's sufficient disk space for Docker operations."""
        try:
            df_info = self.client.df()
            # Check if any storage driver is above 80% usage
            for item in df_info.get('LayersSize', []):
                if item.get('Size', 0) > 0:
                    return True
            return True
        except APIError:
            return False
    
    def _check_containers(self) -> bool:
        """Check container status and health."""
        try:
            containers = self.client.containers.list(all=True)
            unhealthy_count = 0
            for container in containers:
                if container.status in ['exited', 'dead', 'paused']:
                    unhealthy_count += 1
            
            return unhealthy_count < len(containers) * 0.5  # Less than 50% unhealthy
        except APIError:
            return False
    
    def _check_networks(self) -> bool:
        """Check network connectivity and configuration."""
        try:
            networks = self.client.networks.list()
            return len(networks) > 0
        except APIError:
            return False
    
    def _check_images(self) -> bool:
        """Check for corrupted or dangling images."""
        try:
            images = self.client.images.list()
            dangling = self.client.images.list(filters={"dangling": True})
            return len(dangling) < len(images) * 0.3  # Less than 30% dangling
        except APIError:
            return False
    
    def _get_daemon_logs(self) -> str:
        """Get Docker daemon logs."""
        try:
            # Try to get logs from common locations
            log_paths = [
                "/var/log/docker.log",
                "/var/log/docker/daemon.log"
            ]
            
            for log_path in log_paths:
                if Path(log_path).exists():
                    with open(log_path, 'r') as f:
                        return f.read()[-2000:]  # Last 2000 characters
            
            # Try systemd logs
            result = subprocess.run(
                ["journalctl", "-u", "docker", "--no-pager", "-n", "50"],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout if result.returncode == 0 else "No logs available"
            
        except Exception as e:
            return f"Failed to retrieve daemon logs: {e}"
    
    def _prune_containers(self) -> bool:
        """Remove stopped containers."""
        try:
            pruned = self.client.containers.prune()
            logger.info(f"Pruned {len(pruned.get('ContainersDeleted', []))} containers")
            return True
        except APIError as e:
            logger.error(f"Failed to prune containers: {e}")
            return False
    
    def _prune_images(self) -> bool:
        """Remove unused images."""
        try:
            pruned = self.client.images.prune(filters={"dangling": False})
            logger.info(f"Freed {pruned.get('SpaceReclaimed', 0)} bytes from images")
            return True
        except APIError as e:
            logger.error(f"Failed to prune images: {e}")
            return False
    
    def _prune_networks(self) -> bool:
        """Remove unused networks."""
        try:
            pruned = self.client.networks.prune()
            logger.info(f"Pruned {len(pruned.get('NetworksDeleted', []))} networks")
            return True
        except APIError as e:
            logger.error(f"Failed to prune networks: {e}")
            return False
    
    def _prune_volumes(self) -> bool:
        """Remove unused volumes."""
        try:
            pruned = self.client.volumes.prune()
            logger.info(f"Pruned {len(pruned.get('VolumesDeleted', []))} volumes")
            return True
        except APIError as e:
            logger.error(f"Failed to prune volumes: {e}")
            return False


def main() -> None:
    """Main entry point for the docker_fix module."""
    try:
        docker_fix = DockerFix()
        
        print("Running Docker system diagnosis...")
        diagnosis = docker_fix.diagnose_system()
        
        print("\n=== Diagnosis Results ===")
        for key, value in diagnosis.items():
            if key != "daemon_logs":
                status = "✓" if value else "✗"
                print(f"{status} {key.replace('_', ' ').title()}: {value}")
        
        print("\nAttempting to fix common issues...")
        fixes = docker_fix.fix_common_issues()
        
        print("\n=== Fix Results ===")
        for key, value in fixes.items():
            status = "✓" if value else "✗"
            print(f"{status} {key.replace('_', ' ').title()}: {'Success' if value else 'Failed'}")
            
    except Exception as e:
        logger.error(f"Docker fix failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
